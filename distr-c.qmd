---
title: "Phân phối liên tục"
format: html
---

## Phân phối exponential

## Phân phối Pareto



## Phân phối gamma



## Phân phối chuẩn

## Phân phối Chi-bình phương

Nếu $Z_1, \dots, Z_k$ là các biến ngẫu nhiên có phân phối chuẩn tắc (standard normal, là phân phối chuẩn có $\mu = 0$ và $\sigma = 1$) độc lập, thì tổng bình phương của chúng:

$$X = \sum_{i=1}^{k} Z_i^2$$

sẽ tuân theo phân phối Chi-bình phương (chi-squared distribution) với $k$ bậc tự do. Kí hiệu:

$$X \sim \chi^2(k) \quad \text{hoặc} \quad X \sim \chi_k^2$$

```{ojs}
//| echo: false
viewof chi_squared_mechanism = (() => {
  // --- 1. CONFIGURATION & STATE ---
  const state = {
    running: true,
    k: 3,
    speed: 5, // 1 (Slow) to 10 (Fast)
    histogram: new Float32Array(100), // 100 bins
    totalSamples: 0,
    xMax: 15 // Range of the histogram
  };

  const colors = ["#ef4444", "#3b82f6", "#10b981", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#84cc16"];

  // --- 2. SETUP DOM ---
  const wrapper = document.createElement("div");
  wrapper.style.cssText = `
    font-family: -apple-system, system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 850px;
    margin: 0 auto;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    padding: 20px;
  `;

  // Controls Row
  const controls = document.createElement("div");
  controls.style.cssText = "display: flex; gap: 30px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;";

  // Helper for inputs
  const createControl = (label, type, min, max, val, fn) => {
    const div = document.createElement("div");
    div.style.cssText = "display: flex; flex-direction: column; width: 150px;";
    const lbl = document.createElement("label");
    lbl.textContent = `${label}: ${val}`;
    lbl.style.cssText = "font-size: 13px; font-weight: 700; color: #4b5563; margin-bottom: 4px;";
    
    const inp = document.createElement("input");
    inp.type = type;
    inp.min = min;
    inp.max = max;
    inp.value = val;
    inp.style.width = "100%";
    inp.style.accentColor = "#2563eb";

    inp.oninput = (e) => {
      const v = parseFloat(e.target.value);
      lbl.textContent = `${label}: ${v}`;
      fn(v);
    };
    
    div.appendChild(lbl);
    div.appendChild(inp);
    return { div, inp, lbl };
  };

  const kCtrl = createControl("Degrees (k)", "range", 1, 8, 3, (v) => {
    state.k = v;
    resetSim();
  });
  
  const speedCtrl = createControl("Speed", "range", 1, 50, 5, (v) => state.speed = v);

  const resetBtn = document.createElement("button");
  resetBtn.textContent = "Reset Simulation";
  resetBtn.style.cssText = "padding: 0 16px; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; font-weight: 600; color: #374151; cursor: pointer; height: 36px; align-self: flex-end;";
  resetBtn.onclick = resetSim;

  controls.appendChild(kCtrl.div);
  controls.appendChild(speedCtrl.div);
  controls.appendChild(resetBtn);
  wrapper.appendChild(controls);

  // Canvas
  const canvas = document.createElement("canvas");
  const width = 800;
  const height = 400;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = "100%";
  canvas.style.maxWidth = "800px";
  canvas.style.height = "auto";
  const ctx = canvas.getContext("2d");
  ctx.scale(dpr, dpr);
  wrapper.appendChild(canvas);

  // --- 3. MATH HELPERS ---
  function randn() {
    return Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
  }

  function gamma(n) { // Lanczos approx for gamma
      var p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
      var g = 7;
      if (n < 0.5) return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));
      n -= 1;
      var a = p[0];
      var t = n + g + 0.5;
      for (var i = 1; i < p.length; i++) a += p[i] / (n + i);
      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * a;
  }

  function pdf(x, k) {
      if (x <= 0) return 0;
      return (1 / (Math.pow(2, k / 2) * gamma(k / 2))) * Math.pow(x, k / 2 - 1) * Math.exp(-x / 2);
  }

  function resetSim() {
    state.histogram = new Float32Array(100);
    state.totalSamples = 0;
    // Adjust xMax based on k to keep it framed
    state.xMax = state.k * 2.5 + 4; 
  }

  // --- 4. RENDER LOOP ---
  function draw() {
    ctx.clearRect(0, 0, width, height);
    
    // Layout Constants
    const leftW = 300; // Width of "Mechanism" area
    const chartX = 340; // Start of Chart
    const chartW = width - chartX - 20;
    const chartH = 300;
    const chartY = 50;

    // --- A. DRAW MECHANISM (Left Side) ---
    // Background box
    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(10, 10, leftW, height - 20);
    ctx.strokeStyle = "#e5e7eb";
    ctx.strokeRect(10, 10, leftW, height - 20);

    // Labels
    ctx.fillStyle = "#111827";
    ctx.font = "bold 14px sans-serif";
    ctx.fillText("Independent Z", 30, 40);
    ctx.fillText("Z² Blocks", 140, 40);
    ctx.fillText("Sum", 260, 40);

    const rowH = (height - 60) / 9; // Max 8 rows comfortably
    const barScale = 20; // Scale for Z visual

    // Run Simulation Step(s) based on speed
    const steps = state.speed;
    let lastZ = []; // Store for visual
    let lastZ2 = [];
    let lastSum = 0;

    for(let s=0; s<steps; s++) {
      let sum = 0;
      let zVals = [];
      let z2Vals = [];
      
      for(let i=0; i<state.k; i++) {
        const z = randn();
        const z2 = z*z;
        sum += z2;
        zVals.push(z);
        z2Vals.push(z2);
      }

      // Record Histogram
      const binWidth = state.xMax / state.histogram.length;
      const binIdx = Math.floor(sum / binWidth);
      if(binIdx >= 0 && binIdx < state.histogram.length) {
        state.histogram[binIdx]++;
        state.totalSamples++;
      }

      // Only save last frame for "Mechanism" drawing
      if(s === steps - 1) {
        lastZ = zVals;
        lastZ2 = z2Vals;
        lastSum = sum;
      }
    }

    // Draw the Bars (Mechanism)
    let stackY = height - 40; // Start stacking from bottom of left panel area
    const stackX = 250;
    
    // 1. Draw Individual Rows
    for(let i=0; i<state.k; i++) {
       const y = 70 + i * 35; // Row vertical pos
       const color = colors[i % colors.length];

       // Z Value (Dot on line)
       ctx.beginPath();
       ctx.strokeStyle = "#d1d5db";
       ctx.moveTo(30, y); ctx.lineTo(110, y); // Axis
       ctx.stroke();
       ctx.beginPath();
       ctx.moveTo(70, y-5); ctx.lineTo(70, y+5); // Zero mark
       ctx.stroke();

       const zX = 70 + lastZ[i] * 15; // Z visual position
       ctx.beginPath();
       ctx.fillStyle = "#374151";
       ctx.arc(zX, y, 4, 0, Math.PI*2);
       ctx.fill();

       // Z² Block (Horizontal Bar)
       const z2W = lastZ2[i] * 20; // Block width scale
       ctx.fillStyle = color;
       ctx.fillRect(140, y - 6, z2W, 12);
       
       // Draw Arrow
       ctx.beginPath();
       ctx.strokeStyle = "#9ca3af";
       ctx.moveTo(115, y); ctx.lineTo(135, y);
       ctx.stroke();
    }

    // 2. Draw The Stack (Total)
    // We visually stack the squares from the bottom up to show summation
    let currentStackY = height - 40;
    for(let i=0; i<state.k; i++) {
        const color = colors[i % colors.length];
        const h = lastZ2[i] * 30; // Scale height for stack visibility
        
        ctx.fillStyle = color;
        // Draw segment of stack
        ctx.fillRect(stackX, currentStackY - h, 20, h);
        ctx.strokeStyle = "white";
        ctx.strokeRect(stackX, currentStackY - h, 20, h);
        
        currentStackY -= h;
    }
    
    // Label Total
    ctx.fillStyle = "#000";
    ctx.font = "bold 12px monospace";
    ctx.fillText(`Σ = ${lastSum.toFixed(2)}`, stackX - 10, currentStackY - 10);


    // --- B. DRAW HISTOGRAM (Right Side) ---
    // Axis Lines
    ctx.beginPath();
    ctx.strokeStyle = "#374151";
    ctx.moveTo(chartX, chartY + chartH); ctx.lineTo(chartX + chartW, chartY + chartH); // X
    ctx.moveTo(chartX, chartY + chartH); ctx.lineTo(chartX, chartY); // Y
    ctx.stroke();

    // Calculate Scale
    // Find max density for scaling Y axis
    let maxCount = 0;
    for(let i=0; i<state.histogram.length; i++) if(state.histogram[i] > maxCount) maxCount = state.histogram[i];
    
    // Normalize histogram to probability density to match PDF curve
    // Density = Count / (Total * BinWidth)
    const binWidth = state.xMax / state.histogram.length;
    // We want the graphical max to align with theoretical max roughly
    // Or just scale purely on observed counts for robustness
    
    const yScale = maxCount > 0 ? (chartH * 0.9) / maxCount : 1;

    // Draw Bins
    ctx.fillStyle = "#93c5fd"; // Blue bars
    for(let i=0; i<state.histogram.length; i++) {
        const h = state.histogram[i] * yScale;
        const x = chartX + (i / state.histogram.length) * chartW;
        const w = (chartW / state.histogram.length) + 0.5; // +0.5 to close gaps
        
        if (h > 0) ctx.fillRect(x, chartY + chartH - h, w, h);
    }

    // Draw Theoretical PDF (Red Line)
    ctx.beginPath();
    ctx.strokeStyle = "#ef4444";
    ctx.lineWidth = 3;
    
    // We need to scale PDF y-value to match the Histogram pixel height
    // Histogram Bar Height (pixels) = Count * yScale
    // Density = Count / (N * W)  => Count = Density * N * W
    // Pixel Y = Density * N * W * yScale
    // We can just find the peak of the PDF and match it to the peak of the histogram visually or mathematically
    
    const pixelFactor = state.totalSamples * binWidth * yScale;
    
    for(let px = 0; px <= chartW; px+=2) {
        const xVal = (px / chartW) * state.xMax;
        const yVal = pdf(xVal, state.k);
        const plotY = chartY + chartH - (yVal * pixelFactor);
        
        if (px === 0) ctx.moveTo(chartX + px, plotY);
        else ctx.lineTo(chartX + px, plotY);
    }
    ctx.stroke();

    // Chart Labels
    ctx.fillStyle = "#374151";
    ctx.textAlign = "center";
    ctx.fillText("0", chartX, chartY + chartH + 15);
    ctx.fillText(state.xMax.toFixed(0), chartX + chartW, chartY + chartH + 15);
    ctx.font = "bold 14px sans-serif";
    ctx.fillText(`Histogram of Sums (N=${state.totalSamples})`, chartX + chartW/2, chartY - 10);
    
    ctx.fillStyle = "#ef4444";
    ctx.textAlign = "right";
    ctx.fillText(`Theoretical χ²(k=${state.k})`, chartX + chartW - 10, chartY + 30);

    requestAnimationFrame(draw);
  }

  // Start
  requestAnimationFrame(draw);

  return wrapper;
})();
```

## Phân phối log-normal

### Biến tỉ số

Biến tỉ số (ratio scale variables) là loại biến mà các đơn vị được đo lường trên thang tỉ số. Loại biến này có các đặc điểm sau [@motulsky2025]:

1.  Không tồn tại giá trị âm. Biến chỉ có thể nhận các giá trị dương

2.  Giá trị 0 mang ý nghĩa tuyệt đối: Số 0 hoặc đại diện cho sự vắng mặt hoàn toàn của biến đó (không có), hoặc là một giới hạn tiệm cận.

-   0 = không có: Cân nặng hoặc chiều dài. Cân nặng bằng 0 nghĩa là không có trọng lượng. Chiều cao bằng 0 nghĩa là không có chiều cao.

-   0 = tiệm cận: Các chỉ số như EC50 hoặc Km. Các tham số này về lý thuyết không thể bằng 0, nhưng giá trị của chúng có thể cực nhỏ và tiến dần về 0.

3.  Chuyển đổi đơn vị chỉ dùng phép Nhân hoặc Chia

4.  Việc tính tỉ số (ratio) mang ý nghĩa thực tiễn: Ví dụ, 4 cm dài gấp đôi 2 cm; 6 lít nước nhiều gấp 3 lần 2 lít nước

Khi 1 biến là biến tỉ số thì sự khác biệt cần phải được đo bằng tỉ số (gấp bao nhiêu lần, bằng phép chia) chứ không phải là chênh lệch bao nhiêu giá trị (phép trừ).

Ví dụ: Nhiệt độ không phải là biến tỉ số

1.  Có giá trị âm

2.  Điểm 0 là quy ước, không phải tuyệt đối. 0°C không có nghĩa là "không có nhiệt độ"

3.  Công thức chuyển đổi từ độ C sang độ F

$$^\circ C = (^\circ F - 32) \times \frac{5}{9}$$

4.  Tỉ số (ratio) không có ý nghĩa thực tiễn: 200°C không nóng gấp đôi 100°C. Sự thay đổi nhiệt độ phải được diễn đạt dưới dạng chênh lệch bao nhiêu giá trị (hiệu số).

::: callout-note
Biến nào là biến tỉ số? Tại sao?

-   Tuổi
-   Nồng độ kháng thể
-   Khoảng thời gian
-   Chỉ số IQ
-   Tải lượng virus (viral load)
:::

Khi log(biến) có phân phối chuẩn

Khi có outliers làm cho phân phối bị lệch phải.

### Tại sao dùng log?

$$\log(a \times b) = \log(a) + \log(b)$$

### Cơ chế tạo ra log-normal

Đặc trưng của phân phối log-normal là phép nhân.

Định lý giới hạn trung tâm cho biết rằng **tổng** của nhiều biến ngẫu nhiên độc lập sẽ tạo ra phân phối Chuẩn. Tương tự, **tích** của nhiều biến ngẫu nhiên sẽ tạo ra phân phối log-normal [@motulsky2025]. Đây được gọi là Quy luật Tác động Tỉ lệ (Law of Proportionate Effect).

Một số cơ chế tạo ra phân phối này [@koch1966]:

- Sự tăng trưởng tích lũy: Giá trị của bước tiếp theo là kết quả của bước hiện tại nhân với một tỉ lệ biến động ngẫu nhiên (lãi suất, tốc độ tăng trưởng)

$X_{t+1} = X_t \times (1 + r)$

- Sự phân mảnh: Ngược lại với quá trình tích lũy, là quá trình phá vỡ một vật thể lớn thành nhiều mảnh nhỏ. Ví dụ: Kích thước của sỏi đá trong địa chất, hoặc các mảnh vụn khi nghiền bánh quy.

- Sự phân chia sinh học: tế bào phân chia


