---
title: "Phân phối rời rạc"
format: html
---

## Phép thử Bernoulli (Bernoulli trial, hay binomial trial)

Là một lần thử nghiệm duy nhất, không gian mẫu chỉ có đúng 2 kết quả: Thành công (Success) hoặc Thất bại (Failure)

Ví dụ: tung đồng xu (mặt sấp, mặt ngửa), xét nghiệm một ca nghi ngờ (dương tính, âm tính)

Khi ta thực hiện phép thử Bernoulli nhiều lần liên tiếp (ví dụ: tung một đồng xu nhiều lần, dùng một loại xét nghiệm để test nhiều người), ta đang thực hiện 1 chuỗi Bernoulli (Bernoulli process). Chuỗi Bernoulli chuẩn cần thỏa 2 điều kiện:

-   Độc lập (Independent): Kết quả của lần thử này không ảnh hưởng đến lần thử khác.
-   Xác suất không đổi: Xác suất thành công ($p$) phải giống hệt nhau ở mọi lần thử.

Hầu hết các phân phối rời rạc đều xuất phát từ chuỗi Bernoulli với các mục tiêu khác nhau.

## Đếm số lần thành công

Chúng ta quyết định trước sẽ bỏ ra bao nhiêu công sức ($n$ lần thử), và đếm xem thu được bao nhiêu phần thưởng ($k$ thành công).

### Phân phối nhị nhức (binomial distribution)

Đếm số lần thành công ($k$) trong một số lượng cố định các phép thử Bernoulli độc lập ($n$).

Xác suất để đạt được đúng $k$ lần thành công là:

$$P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}$$

Với:

- $n$: Tổng số lần thực hiện phép thử
- $p$: Xác suất thành công của mỗi lần thử (không đổi)

#### Ví dụ

Tung 1 đồng xu 10 lần, sau 10 lần tung, khả năng đếm được 1, 2, 3... mặt ngửa là bao nhiêu?

- Tổng số lần thực hiện phép thử: $n = 10$
- Xác suất ra mặt ngửa mỗi lần: $p = 0.5$

```{ojs}
//| echo: false

viewof n_coins = Inputs.range([1, 20], {label: "Coins per Flip (n)", value: 10, step: 1})
viewof p_head = Inputs.range([0.01, 0.99], {label: "Prob. of Heads (p)", value: 0.5, step: 0.01})
viewof speed = Inputs.range([10, 1000], {label: "Speed (ms)", value: 200, transform: x => 1010 - x})

viewof flipBtn = Inputs.button("Flip Once")
viewof autoBtn = Inputs.button("Start/Stop Auto-Flip")
viewof resetCoinBtn = Inputs.button("Reset Data")

// A. STATE CONTAINER
// Holds the data history.
coin_state = {
  // We define it once. It persists until you reload the page.
  return {
    history: [], 
    currentToss: [],
    totalHeads: 0,
    count: 0,
    lastReset: 0
  };
}

// B. GAME LOGIC
// This cell runs whenever you click a button.
coin_logic = {
  // 1. LISTEN TO TRIGGERS
  flipBtn;
  autoBtn;
  resetCoinBtn;
  
  // 2. HANDLE RESET
  // We check if the reset button counter has increased
  if (resetCoinBtn > coin_state.lastReset) {
      coin_state.history = [];
      coin_state.currentToss = [];
      coin_state.totalHeads = 0;
      coin_state.count = 0;
      coin_state.lastReset = resetCoinBtn;
      // Return immediately to clear the plot
      return coin_state.count; 
  }

  // 3. DEFINE THE FLIP FUNCTION
  const doFlip = () => {
    let heads = 0;
    const outcome = [];
    for(let i=0; i<n_coins; i++) {
      const isHead = Math.random() < p_head;
      outcome.push(isHead ? 1 : 0);
      if(isHead) heads++;
    }
    coin_state.currentToss = outcome;
    coin_state.history.push(heads);
    coin_state.totalHeads = heads;
    coin_state.count++;
  };

  // 4. EXECUTION MODE
  // If Auto Button is ODD (1, 3, 5...), we are in Auto Mode
  const isAuto = (autoBtn % 2) !== 0;

  if (isAuto) {
    // --- AUTO MODE (Loop) ---
    while (true) {
      doFlip();
      yield coin_state.count; // Yield updates the plot!
      await new Promise(r => setTimeout(r, 1010 - speed));
    }
  } else {
    // --- MANUAL MODE (Single Shot) ---
    // If we aren't in auto, and this cell ran, it means 'flipBtn' was clicked
    // (or a slider changed). We flip once.
    if (coin_state.count > 0 || flipBtn > 0) {
       doFlip();
    }
    return coin_state.count;
  }
}

// 3. THE VISUALIZATION (Fixed: Split into two plots)
{
  // DEPENDENCY: Listen to the logic!
  coin_logic; 
  
  // Plot A: The Coins (Top Strip)
  const coinPlot = Plot.plot({
    width: 600,
    height: 80, // Fixed height for just the coins
    title: `Toss #${coin_state.count}: Result`,
    x: {axis: null, domain: [0, n_coins]},
    y: {axis: null},
    marks: [
      Plot.dot(coin_state.currentToss.map((d, i) => ({x: i, val: d})), {
        x: (d, i) => mapRange(i, 0, n_coins-1, 0.5, n_coins-0.5), 
        y: 0, 
        r: 12,
        fill: d => d.val === 1 ? "#f7941d" : "#ccc", 
        stroke: "black",
        strokeWidth: 2
      }),
      Plot.text(coin_state.currentToss.map((d, i) => ({x: i, val: d})), {
        x: (d, i) => mapRange(i, 0, n_coins-1, 0.5, n_coins-0.5), 
        y: 0, 
        text: d => d.val === 1 ? "H" : "T",
        fill: "black", fontWeight: "bold", dy: 1
      })
    ]
  });

  // Plot B: The Histogram (Bottom Chart)
  const histPlot = Plot.plot({
    width: 600,
    height: 350,
    title: `Distribution of Heads (Total: ${coin_state.history.length} experiments)`,
    x: {label: "Number of Heads", domain: [0, n_coins]},
    y: {label: "Frequency", grid: true}, // Standard quantitative axis (Bottom-Up)
    marks: [
      // 1. The Blue Histogram
      Plot.rectY(coin_state.history, Plot.binX(
        {y: "count"}, 
        {x: d => d, domain: [0, n_coins], thresholds: d3.range(0, n_coins + 2), fill: "#4e79a7", opacity: 0.6}
      )),
      
      // 2. The Theoretical Red Line
      Plot.line(d3.range(0, n_coins + 1), {
        x: d => d + 0.5, 
        y: d => binomialPMF(d, n_coins, p_head) * coin_state.history.length,
        stroke: "red", strokeWidth: 2, curve: "natural"
      }),
      
      Plot.ruleY([0])
    ]
  });

  // Return both stacked together
  return htl.html`<div>${coinPlot}${histPlot}</div>`;
}

// Helper Functions
function mapRange(value, low1, high1, low2, high2) {
    if (high1 === low1) return low2;
    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
}

function factorial(n) {
  if (n === 0 || n === 1) return 1;
  let result = 1; 
  for (let i = 2; i <= n; i++) result *= i; 
  return result; 
}

function combination(n, k) {
  return factorial(n) / (factorial(k) * factorial(n - k));
}

function binomialPMF(k, n, p) {
  return combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
}
```

#### Bảng Galton

Bảng Galton (Galton board) là một tấm bảng dựng đứng, được đóng các hàng đinh so le nhau theo hình tam giác. Ta thả những viên bi nhỏ từ đỉnh tháp. Khi một viên bi chạm vào một chiếc đinh, nó sẽ nảy sang trái hoặc sang phải. Sau khi đi hết các hàng đinh, viên bi sẽ rơi vào các ô chứa để hứng bi. Số lượng bi trong các ô chứa này tuân theo phân phối nhị thức.

```{ojs}
//| echo: false
viewof galton_sharp = Inputs.form({
  rows: Inputs.range([8, 20], {value: 10, step: 1, label: "Số hàng đinh"}),
  speed: Inputs.range([0.5, 3], {value: 2, step: 0.1, label: "Tốc độ"}),
  total: Inputs.range([50, 800], {value: 200, step: 10, label: "Số viên bi"})
})

viewof control_sharp = Inputs.form({
  start: Inputs.button("Bắt đầu", {value: null, reduce: () => "START"}),
  stop: Inputs.button("Dừng", {value: null, reduce: () => "STOP"})
})

{
  const rows = galton_sharp.rows;
  const speed = galton_sharp.speed;
  const maxBalls = galton_sharp.total;
  
  // 1. DIMENSIONS
  // The "Logical" size (how big it looks on screen)
  const logicalWidth = 360;
  const logicalHeight = 600;

  // 2. HIGH-DPI SCALING
  // We detect the user's screen density (e.g., 2.0 for Retina)
  const dpr = window.devicePixelRatio || 1;
  
  const canvas = document.createElement("canvas");
  // Set the "Real" size (pixels in memory) higher
  canvas.width = logicalWidth * dpr;
  canvas.height = logicalHeight * dpr;
  // Set the "CSS" size (pixels on screen) standard
  canvas.style.width = `${logicalWidth}px`;
  canvas.style.height = `${logicalHeight}px`;
  
  const ctx = canvas.getContext("2d");
  // Scale all drawing operations automatically
  ctx.scale(dpr, dpr);

  // --- GEOMETRY (Uses logical units) ---
  const pegSpacing = logicalWidth / (rows + 2);
  const rowHeight = pegSpacing * 0.85; 
  const startY = 60;
  const pegRadius = pegSpacing * 0.12; 
  const ballRadius = pegSpacing * 0.23; 

  const floorY = logicalHeight - 10;
  const binWidth = pegSpacing;
  const totalBinWidth = (rows + 1) * binWidth;
  const binsStartX = (logicalWidth - totalBinWidth) / 2;
  const wallsTopY = startY + (rows) * rowHeight + 10;

  // PRE-COMPUTE BOARD
  const pegGrid = []; 
  for (let r = 0; r < rows; r++) {
    const rowPegs = [];
    const pegsInThisRow = r + 1;
    const rowWidth = (pegsInThisRow - 1) * pegSpacing;
    const rowStartX = (logicalWidth - rowWidth) / 2;
    for (let p = 0; p < pegsInThisRow; p++) {
      rowPegs.push({
        x: rowStartX + p * pegSpacing,
        y: startY + r * rowHeight
      });
    }
    pegGrid.push(rowPegs);
  }

  // STATE
  let balls = [];
  let bins = new Array(rows + 1).fill(0);
  let spawnedCount = 0;
  let isRunning = false;

  // CONTROLS
  const startBtn = viewof control_sharp.querySelector("button"); 
  const stopBtn = viewof control_sharp.querySelectorAll("button")[1];

  startBtn.onclick = () => {
    balls = [];
    bins = new Array(rows + 1).fill(0);
    spawnedCount = 0;
    isRunning = true;
  };
  stopBtn.onclick = () => { isRunning = false; };

  // PATH LOGIC
  function createBall() {
    let currentInd = 0; 
    let path = [];
    path.push({ x: logicalWidth / 2, y: startY - 20 });

    for (let r = 0; r < rows; r++) {
       const peg = pegGrid[r][currentInd];
       path.push({ x: peg.x, y: peg.y - pegRadius - ballRadius });
       if (Math.random() > 0.5) currentInd++; 
    }

    const binX = binsStartX + currentInd * binWidth + binWidth/2;
    path.push({ x: binX, y: wallsTopY });
    path.push({ x: binX, y: floorY - ballRadius, isFloor: true, binIndex: currentInd });

    return {
      path: path,
      segment: 0, t: 0, active: true,
      x: path[0].x, y: path[0].y
    };
  }

  function spawnBall() {
    if (!isRunning) return;
    if (spawnedCount >= maxBalls) return;
    
    const centerBinIdx = Math.floor(rows / 2);
    const maxCapacity = (floorY - wallsTopY) / (ballRadius * 0.6); 
    if (bins[centerBinIdx] >= maxCapacity) return;

    balls.push(createBall());
    spawnedCount++;
  }

  function update(dt) {
    const spawnRate = 0.15 / speed; 
    if (isRunning && Math.random() < dt / spawnRate) spawnBall();

    for (let b of balls) {
      if (!b.active) continue;
      if (!isRunning) continue; 

      const moveSpeed = 3.5 * speed * dt; 
      b.t += moveSpeed;

      if (b.t >= 1) {
        b.t = 0;
        b.segment++;
        if (b.segment >= b.path.length - 1) {
           b.active = false;
           const finalPt = b.path[b.path.length - 1];
           bins[finalPt.binIndex]++;
           continue;
        }
      }

      const p0 = b.path[b.segment];
      const p1 = b.path[b.segment + 1];
      
      b.x = p0.x + (p1.x - p0.x) * b.t;
      if (p1.isFloor) {
         b.y = p0.y + (p1.y - p0.y) * (b.t * b.t); 
      } else {
         b.y = p0.y + (p1.y - p0.y) * (b.t * b.t); 
      }
    }
    balls = balls.filter(b => b.active);
  }

  function draw() {
    // Clear the full logical area
    ctx.fillStyle = "#E8E0C5";
    ctx.fillRect(0, 0, logicalWidth, logicalHeight);

    // Pegs
    ctx.fillStyle = "#666";
    for (let row of pegGrid) {
      for (let p of row) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, pegRadius, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Walls
    ctx.strokeStyle = "#998866";
    ctx.lineWidth = 1;
    for (let i = 0; i <= rows + 1; i++) {
      const x = binsStartX + i * binWidth;
      ctx.beginPath();
      ctx.moveTo(x, wallsTopY);
      ctx.lineTo(x, logicalHeight);
      ctx.stroke();
    }

    // Active Balls
    ctx.fillStyle = "#0033CC";
    for (let b of balls) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2);
      ctx.fill();
    }

    // Stacked Balls
    for (let i = 0; i < bins.length; i++) {
      const count = bins[i];
      const cx = binsStartX + i * binWidth + binWidth/2;
      ctx.strokeStyle = "#4d79ff";
      ctx.lineWidth = 0.5;

      for (let j = 0; j < count; j++) {
        const cy = floorY - j * (ballRadius * 0.6); 
        if (cy < wallsTopY) break;
        ctx.beginPath();
        ctx.arc(cx, cy, ballRadius, 0, Math.PI*2);
        ctx.fillStyle = "#0033CC";
        ctx.fill();
        ctx.stroke();
      }
    }
    
    // Status Text
    ctx.fillStyle = "#444";
    ctx.font = "bold 14px sans-serif";
    ctx.fillText(`Số viên bi: ${spawnedCount} / ${maxBalls}`, 10, 25);
  }

  let lastTime = performance.now();
  let frameId;
  function tick(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    update(dt);
    draw();
    frameId = requestAnimationFrame(tick);
  }
  
  draw();
  tick(lastTime);
  
  return Object.assign(canvas, {
    remove: () => cancelAnimationFrame(frameId)
  });
}
```

**Tại sao lại là phân phối nhị thức?**

- Mỗi lần viên bi chạm vào chiếc đinh, có hai trường hợp xảy ra: viên bi sẽ nảy sang trái hoặc sang phải, xác suất nảy sang mỗi bên là $p = 0.5$, giống như tung đồng xu. Đây là một phép thử Bernoulli.
- Nếu bảng có 10 hàng đinh, viên bi sẽ thực hiện 10 lần tung đồng xu liên tiếp.
- Các ô chứa tương ứng với số lần viên bi nảy về bên phải. Để vào ô giữa, viên bi phải nảy sang bên phải 5 lần, để vào ô cuối cùng, viên bi phải nảy sang bên phải 10 lần.

#### Hồi quy logistic

```{r}
#| eval: false
glm(formula, data, family = binomial(link = "logit"))
glm(formula, data, family = "binomial")
```

**Tại sao trong hồi quy logistic lại ghi `family = "binomial"`?**

Ví dụ: Hút thuốc lá có làm tăng nguy cơ ung thư phổi không?

- Biến độc lập: Số điếu thuốc hút mỗi ngày
- Biến phụ thuộc: Tình trạng ung thư phổi (1 = Có bệnh, 0 = Không bệnh)

Khi xây dựng mô hình, chúng ta xem xét từng cá nhân trong dữ liệu như một phép thử ngẫu nhiên:

- Với một người cụ thể (ví dụ: anh A, hút 1 gói/ngày), việc anh ta có bị ung thư hay không giống như việc tung một đồng xu: mặt ngửa (1) là bị ung thư, mặt sấp (0) là không bị ung thư. **Nhưng** xác suất tung ra mặt ngửa của đồng xu này không phải là 0.5, mà phụ thuộc vào việc anh ta hút bao nhiêu thuốc.
- Khi chúng ta tiến hành nghiên cứu trên $n$ người, đây là 1 chuỗi Bernoulli, vì vậy có thể chọn phân phối Binomial để mô hình nó.

Khai báo `family = "binomial"` nghĩa là: "Biến kết quả ($Y$) là đếm số lần thành công (hoặc thất bại) từ các phép thử nhị phân, hãy dùng công thức xác suất của phân phối nhị thức để ước lượng."

### Phân phối siêu bội (hypergeometric distribution)

Tình huống: Bạn có bộ bài 52 lá, trong đó có 4 lá A. Bạn rút 10 lá.

Luật chơi:

-   Số lần thử cố định ($n$)
-   Các lần thử phụ thuộc nhau
-   Lấy mẫu không hoàn lại từ một quần thể hữu hạn ($N$)

Câu hỏi: "Tôi rút được bao nhiêu lá A?"

```{ojs}
//| echo: false
viewof ace_sim_fixed = Inputs.form({
  draw: Inputs.button("Rút 10 lá"),
  auto: Inputs.toggle({label: "Chạy tự động", value: false}),
  reset: Inputs.button("Lại từ đầu")
})

{
  // 1. SETUP
  const width = 400;
  const height = 400;
  const canvas = document.createElement("canvas");
  const dpr = window.devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.scale(dpr, dpr);

  // COLORS
  const BG_COLOR = "#f4f6f8"; 
  const TEXT_COLOR = "#333333";
  const ACE_COLOR = "#d35400"; 
  const ACE_BG = "#fffbe6"; 
  const CARD_BG_STD = "#ffffff"; 
  const CARD_BORDER = "#cccccc"; 
  const CARD_RED = "#e74c3c";
  const CARD_BLACK = "#2c3e50";
  
  const CHART_THEO = "rgba(0, 0, 0, 0.05)";
  const CHART_ACTUAL = "#009688"; 
  const CHART_ACTIVE = "#00796b"; 

  // MATH
  function hypergeom(k, N, K, n) {
     function nCr(n, r) {
        if (r < 0 || r > n) return 0;
        let res = 1;
        for(let i=0; i<r; i++) res = res * (n - i) / (i + 1);
        return res;
     }
     return (nCr(K, k) * nCr(N - K, n - k)) / nCr(N, n);
  }
  const THEORETICAL = [];
  for(let k=0; k<=4; k++) THEORETICAL[k] = hypergeom(k, 52, 4, 10);

  // 2. STATE (Persistent)
  if (!this.stateFixed) {
    this.stateFixed = {
       counts: [0, 0, 0, 0, 0], 
       totalDeals: 0,
       lastHand: [],
       animation: 0, 
       cooldown: 0,
       // TRACKERS to detect real clicks
       lastDrawVal: ace_sim_fixed.draw,
       lastResetVal: ace_sim_fixed.reset
    };
  }
  const S = this.stateFixed;

  // 3. LOGIC
  const SUITS = ["♠", "♥", "♣", "♦"];
  const RANKS = ["2","3","4","5","6","7","8","9","10","J","Q","K","A"];
  const CARD_W = 30;
  const CARD_H = 45;

  function runDeal() {
    let deck = [];
    for(let s of SUITS) {
      for(let r of RANKS) {
        deck.push({ rank: r, suit: s, isAce: r === "A" });
      }
    }
    for(let i=deck.length-1; i>0; i--) {
       const j = Math.floor(Math.random() * (i+1));
       [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    
    const hand = deck.slice(0, 10);
    const aceCount = hand.filter(c => c.isAce).length;
    
    S.counts[aceCount]++;
    S.totalDeals++;
    
    const startX = (width - (5 * (CARD_W + 8))) / 2 + 4;
    S.lastHand = hand.map((c, i) => {
       const row = Math.floor(i / 5);
       const col = i % 5;
       return {
         ...c,
         x: 20, y: 20, 
         targetX: startX + col * (CARD_W + 8),
         targetY: 70 + row * (CARD_H + 12),
         t: 0
       };
    });
    S.animation = 1;
    S.cooldown = 0; 
  }

  // --- BUTTON HANDLING (The Fix) ---
  
  // 1. Detect RESET Click
  if (ace_sim_fixed.reset > S.lastResetVal) {
     S.counts = [0,0,0,0,0];
     S.totalDeals = 0;
     S.lastHand = [];
     S.animation = 0;
     // Update tracker so we don't reset again until next click
     S.lastResetVal = ace_sim_fixed.reset;
  }

  // 2. Detect DRAW Click
  // We only run deal if the button count is HIGHER than last time
  if (ace_sim_fixed.draw > S.lastDrawVal) {
     runDeal();
     S.lastDrawVal = ace_sim_fixed.draw;
  }

  // 4. RENDER LOOP
  function update() {
    const form = viewof ace_sim_fixed;
    const checkbox = form.querySelector("input[type=checkbox]");
    const isAutoRunning = checkbox ? checkbox.checked : false;

    if (S.animation === 1) {
       let done = true;
       for (let c of S.lastHand) {
          if (c.t < 1) {
             c.t += 0.08; 
             if (c.t > 1) c.t = 1;
             c.x = 20 + (c.targetX - 20) * c.t;
             c.y = 20 + (c.targetY - 20) * c.t;
             done = false;
          }
       }
       if (done) S.animation = 0;
    } else if (isAutoRunning) {
       S.cooldown++;
       if (S.cooldown > 100) runDeal(); 
    }
  }

  function draw() {
    const form = viewof ace_sim_fixed;
    const checkbox = form.querySelector("input[type=checkbox]");
    const isAutoRunning = checkbox ? checkbox.checked : false;

    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, width, height);

    // Text
    ctx.textAlign = "left";
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = "14px sans-serif";
    ctx.fillText(`Lần rút thứ: ${S.totalDeals}`, 60, 30);
    
    if (isAutoRunning) {
        ctx.fillStyle = CHART_ACTUAL;
        ctx.fillText("● Tự động", 60, 50);
    } else if (S.lastHand.length > 0) {
       const aces = S.lastHand.filter(c=>c.isAce).length;
       ctx.fillStyle = ACE_COLOR;
       ctx.fillText(`Kết quả: ${aces} lá A`, 60, 50);
    }

    // Deck
    ctx.fillStyle = CARD_BG_STD;
    ctx.strokeStyle = CARD_BORDER;
    for(let i=0; i<3; i++) {
      ctx.fillRect(20-i, 20-i, CARD_W, CARD_H);
      ctx.strokeRect(20-i, 20-i, CARD_W, CARD_H);
    }

    // Hand
    for (let c of S.lastHand) {
        ctx.fillStyle = c.isAce ? ACE_BG : CARD_BG_STD;
        ctx.fillRect(c.x, c.y, CARD_W, CARD_H);
        
        ctx.lineWidth = 1;
        ctx.strokeStyle = c.isAce ? ACE_COLOR : CARD_BORDER;
        ctx.strokeRect(c.x, c.y, CARD_W, CARD_H);

        const isRed = (c.suit === "♥" || c.suit === "♦");
        ctx.fillStyle = c.isAce ? ACE_COLOR : (isRed ? CARD_RED : CARD_BLACK);
        
        ctx.textAlign = "left"; ctx.textBaseline = "top";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText(c.rank, c.x + 3, c.y + 4);
        ctx.font = "16px sans-serif";
        ctx.fillText(c.suit, c.x + 3, c.y + 20);
    }

    // Chart
    const chartY = 340; 
    const chartH = 80; 
    const chartX = 40;
    const barW = 40;
    const gap = 25;
    
    ctx.beginPath();
    ctx.strokeStyle = "#999999";
    ctx.lineWidth = 1;
    ctx.moveTo(chartX - 10, chartY);
    ctx.lineTo(width - 20, chartY);
    ctx.stroke();
    
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = "12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Số lá A rút được (k)", width/2 + 10, chartY + 35);

    const activeAces = S.lastHand.filter(c=>c.isAce).length;

    for (let k = 0; k <= 4; k++) {
       const x = chartX + k * (barW + gap);
       
       const prob = THEORETICAL[k];
       const scaleH = chartH / 0.5;
       const theoH = prob * scaleH;
       ctx.fillStyle = CHART_THEO;
       ctx.fillRect(x, chartY - theoH, barW, theoH);
       
       let count = S.counts[k];
       let pct = S.totalDeals > 0 ? count / S.totalDeals : 0;
       let barH = pct * scaleH;
       
       const isActive = (S.animation === 0 && S.totalDeals > 0 && k === activeAces);
       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_ACTUAL;
       ctx.fillRect(x, chartY - barH, barW, barH);
       
       ctx.fillStyle = TEXT_COLOR;
       ctx.font = "bold 12px sans-serif";
       ctx.fillText(k, x + barW/2, chartY + 15);
       
       if (pct > 0) {
          ctx.fillStyle = isActive ? CHART_ACTIVE : TEXT_COLOR;
          ctx.font = "10px sans-serif";
          const labelY = barH > 20 ? chartY - barH + 12 : chartY - barH - 5;
          if (isActive && barH > 20) ctx.fillStyle = "#ffffff";
          ctx.fillText((pct*100).toFixed(0)+"%", x+barW/2, labelY);
       }
    }
  }

  let frameId;
  function tick() {
    update();
    draw();
    frameId = requestAnimationFrame(tick);
  }
  tick();
  
  return Object.assign(canvas, {
    remove: () => cancelAnimationFrame(frameId)
  });
}
```

## Đếm số lần thử

Chúng ta quyết định trước phần thưởng mình muốn đạt được ($k$ thành công), và đếm xem phải tốn bao nhiêu công sức ($n$ lần thử) để đạt được nó. Nhánh này mô hình hóa sự "kiên trì" hoặc "sức chịu đựng".

### Phân phối hình học (geometric distribution)

Tình huống: Một gia đình phong kiến trọng nam khinh nữ muốn có một đứa con trai, họ cứ sinh con cho đến khi có con trai thì thôi

Câu hỏi: Họ phải sinh bao nhiêu con cho đến khi có con trai?

Đặc tính: Không có bộ nhớ (Memoryless). Dù đã sinh 10 con gái liên tiếp, xác suất đứa tiếp theo là trai vẫn y như lúc bắt đầu.

### Phân phối nhị thức âm (negative binomial distribution)

Tình huống: Gia đình phong kiến đã sinh được con trai nhưng vẫn muốn có con trai nữa, thầy bói nói nhà phải có 3 đứa con trai mới giàu được

Câu hỏi: Họ sẽ sinh bao nhiêu con trước khi có được đứa con trai thứ 3?

Về lý thuyết, đây là tổng của $k$ biến thuộc phân phối hình học.

Trong sinh học thực tế (ví dụ: đếm số ký sinh trùng, ấu trùng muỗi), phương sai thường lớn hơn trung bình rất nhiều (do hiện tượng tụ đám/clumping). Phân phối Nhị thức Âm khớp với kiểu dữ liệu này tốt hơn nhiều so với Poisson hay Nhị thức.

## Đếm sự kiện khi biết tốc độ trung bình

### Phân phối Poisson

Poisson là giới hạn của nhị thức khi $n \to \infty$ và $p \to 0$, sao cho $np = \lambda$

Các phân phối phức tạp có thể được tạo ra bằng cách cộng các phân phối đơn giản:

| Nếu cộng | Sẽ có | Điều kiện |
|------------------------|------------------------|------------------------|
| Nhiều Bernoulli | Nhị thức | Cùng $p$. |
| Nhiều Nhị thức | Nhị thức | $X+Y \sim \text{Bin}(n+m, p)$ |
| Nhiều Hình học | Nhị thức âm | Chờ $k$ thành công thực chất là chờ 1 thành công, lặp lại $k$ lần |
| Nhiều Nhị thức âm | Nhị thức âm | $X+Y \sim \text{NB}(r_1+r_2, p)$ |
| Nhiều Poisson | Poisson | $X+Y \sim \text{Pois}(\lambda_1 + \lambda_2)$ |
