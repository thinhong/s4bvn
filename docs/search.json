[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistics for babies",
    "section": "",
    "text": "Preface\nSách được biên soạn dựa trên các tài liệu:\n\nGiáo trình “STATS 210: Statistical Theory” của Bộ môn Thống kê, Đại học Auckland\nSách “Ecological Models and Data in R” của Benjamin M. Bolker (2008)\n\nCách dịch các thuật ngữ tiếng Việt được tham khảo từ Wikipedia.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "prob.html",
    "href": "prob.html",
    "title": "1  Xác suất",
    "section": "",
    "text": "1.1 Nguồn gốc\nLý thuyết xác suất ra đời để giải quyết một vấn đề trong cờ bạc. Vấn đề cụ thể khai sinh ra lĩnh vực này được gọi là “Bài toán Chia điểm” (Problem of Points).\nNăm 1654, nhà văn kiêm tay cờ bạc Antoine Gombaud viết thư cho nhà toán học Blaise Pascal để hỏi cách giải quyết một ván bài dang dở:\nCâu hỏi: Làm sao chia 100$ cho công bằng?\nTại sao đây là một bài toán khó?\nVào thời đó, con người chưa biết cách xử lý “tương lai” bằng toán học. Có người đề nghị: “A được 2 điểm, B được 1 điểm. Vậy chia 100$ làm 3, A được 67$, B được 33$.” Cách này không công bằng vì chỉ nhìn vào quá khứ mà phớt lờ lợi thế của A: A chỉ cần thắng thêm đúng 1 ván là xong, trong khi B phải thắng liên tiếp 2 ván.\nPascal thấy bài toán này rất thú vị và gửi nó cho nhà toán học Pierre de Fermat. Họ giải quyết vấn đề bằng cách thay đổi góc nhìn. Thay vì nhìn vào quá khứ (những gì đã xảy ra trong ván bài), họ nhìn vào tương lai (các khả năng sẽ xảy ra của trò chơi).\nLời giải:\nFermat tưởng tượng xem trò chơi có thể diễn ra như thế nào nếu tiếp tục chơi cho đến cùng. Trò chơi sẽ kết thúc tối đa trong 2 ván nữa (vì A thắng 1 ván là xong, hoặc B thắng 2 ván là xong). Để cho công bằng, ta cho A và B chơi thêm 2 ván.\nCó 4 kịch bản của 2 ván này:\nKết quả:\nNếu tiếp tục chơi, chỉ có 4 kịch bản có thể xảy ra, trong đó A thắng 3 lần, B thắng 1 lần. Vậy khả năng A thắng là 3/4 trường hợp, và B thắng 1/4 trường hợp. Vậy A nên được chia 3/4 của 100$ là 75$, và B được chia 25$.\nNhu cầu “xử lý tương lai” là rất lớn. Khi đánh bài, nên bỏ bài, theo, tố hay cược hết (all-in) luôn? Nhà cái cần tính toán luật chơi sao cho họ luôn có lợi thế. Nếu mua mã cổ phiếu này thì sau 1 tháng, 3 tháng, 6 tháng có lên giá không? Vì tương lai chưa xảy ra nên không có câu trả lời chắc chắn, nhưng không có nghĩa là ta phải nhắm mắt làm liều. Xác suất ra đời để giải quyết vấn đề này, bằng cách gán một con số để phản ánh mức độ chắc chắn.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#nguồn-gốc",
    "href": "prob.html#nguồn-gốc",
    "title": "1  Xác suất",
    "section": "",
    "text": "Hai người A và B chơi một trò hoàn toàn may rủi (ví dụ tung đồng xu, kéo-búa-bao), ai thắng 3 ván trước sẽ là người chiến thắng cuối cùng\nMỗi người đặt 50$, tổng là 100$, ai thắng sẽ được toàn bộ tiền thưởng 100$\nTrò chơi phải dừng đột ngột khi A đang dẫn trước 2-1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVán 1\nVán 2\nChung cuộc\nTỉ số A:B\n\n\n\n\nA thắng\nA thắng\nA thắng\n4-1\n\n\nB thắng\nA thắng\n3-2\n\n\nB thắng\nA thắng\nA thắng\n3-2\n\n\nB thắng\nB thắng\n2-3",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#định-nghĩa",
    "href": "prob.html#định-nghĩa",
    "title": "1  Xác suất",
    "section": "1.2 Định nghĩa",
    "text": "1.2 Định nghĩa\nTrong “Bài toán Chia điểm” trên, khả năng thắng cuộc chính là xác suất.\nXác suất (Probability): là một con số nằm trong khoảng từ 0 đến 1, dùng để đo lường khả năng xảy ra của một sự kiện.\n\n0 = chắc chắn không xảy ra\n1 = chắc chắn sẽ xảy ra\n\nCó 2 cách tiếp cận xác suất:\n\nTần suất (frequentist):\n\n\\[\\text{Xác suất} = \\frac{\\text{Số lần sự kiện xảy ra}}{\\text{Tổng số lần quan sát}}\\]\n\nNiềm tin (degree of belief, Bayesian): mức độ tin tưởng của người đánh giá về khả năng xảy ra của sự kiện.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#các-khái-niệm-cơ-bản",
    "href": "prob.html#các-khái-niệm-cơ-bản",
    "title": "1  Xác suất",
    "section": "1.3 Các khái niệm cơ bản",
    "text": "1.3 Các khái niệm cơ bản",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#phép-thử-ngẫu-nhiên-random-experiment",
    "href": "prob.html#phép-thử-ngẫu-nhiên-random-experiment",
    "title": "1  Xác suất",
    "section": "1.4 Phép thử ngẫu nhiên (random experiment)",
    "text": "1.4 Phép thử ngẫu nhiên (random experiment)\nLà một thử nghiệm mà chúng ta không biết trước kết quả cho đến khi nó thực sự diễn ra.\nVí dụ: tung đồng xu (không biết sẽ ra mặt sấp hay mặt ngửa), làm xét nghiệm cho một người (không biết là âm tính hay dương tính)\n\n1.4.1 Không gian mẫu (sample space \\(\\Omega\\))\nLà tập hợp chứa tất cả các kết quả có thể xảy ra của một phép thử ngẫu nhiên, mỗi kết quả liệt kê đúng một lần duy nhất.\nVí dụ: không gian mẫu của tung đồng xu là \\(\\Omega = \\{ \\text{sấp}, \\text{ngửa} \\}\\)\nKhông gian mẫu là 1 tập hợp, nên có thể sử dụng các phép toán của tập hợp cho không gian mẫu (\\(\\cup\\) hay \\(\\cap\\)).\n\n\n1.4.2 Điểm mẫu (sample point)\nLà một phần tử của không gian mẫu.\nVí dụ: không gian mẫu của tung đồng xu là \\(\\Omega = \\{ \\text{sấp}, \\text{ngửa} \\}\\) thì \\(\\{ \\text{sấp} \\}\\) hoặc \\(\\{ \\text{ngửa} \\}\\) là một điểm mẫu.\n\n\n1.4.3 Kết quả (outcome)\nLà điểm mẫu quan sát được, khi chúng ta cho thực hiện phép thử ngẫu nhiên.\n\n\n1.4.4 Biến cố/Sự kiện (event)\nLà một tập hợp con của không gian mẫu. Bất kỳ tập hợp nào chứa các kết quả đều tạo thành một biến cố.\nVí dụ: Tung một đồng xu hai lần. Không gian mẫu: \\(\\Omega = \\{ SS, SN, NS, NN \\}\\).\nGọi biến cố \\(A\\) là “có đúng một mặt ngửa”, \\(A = \\{ SN, NS \\}\\).\n\\(A\\) là một tập con của \\(\\Omega\\) (\\(A \\subset \\Omega\\)).\nBiến cố \\(A\\) được gọi là xảy ra (occurs) nếu chúng ta quan sát được một kết quả là phần tử của tập hợp \\(A\\).\n\n\n1.4.5 Ví dụ\nPhép thử ngẫu nhiên: “Tung một đồng xu hai lần”\n\nviewof sample_space = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. DATA: Toss coin twice → 4 sample points\n  // ══════════════════════════════════════════════════════\n  const pts = [\n    { id: 0, c1: \"H\", c2: \"H\", label: \"HH\", heads: 2 },\n    { id: 1, c1: \"H\", c2: \"T\", label: \"HT\", heads: 1 },\n    { id: 2, c1: \"T\", c2: \"H\", label: \"TH\", heads: 1 },\n    { id: 3, c1: \"T\", c2: \"T\", label: \"TT\", heads: 0 },\n  ];\n\n  const events = [\n    { name: \"Exactly 1 Head\",  color: \"#7c3aed\", test: p =&gt; p.heads === 1 },\n    { name: \"At Least 1 Head\", color: \"#3b82f6\", test: p =&gt; p.heads &gt;= 1 },\n    { name: \"Both Same\",       color: \"#d97706\", test: p =&gt; p.c1 === p.c2 },\n    { name: \"No Heads\",        color: \"#dc2626\", test: p =&gt; p.heads === 0 },\n  ];\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:700px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    .ev-card{padding:10px 14px;border-radius:10px;border:2px solid #e2e8f0;\n      background:#fff;cursor:pointer;transition:all 0.15s;user-select:none;text-align:center;flex:1;min-width:100px;}\n    .ev-card:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.08);}\n    .ev-card.active{border-width:3px;}\n    .ev-card-name{font-size:13px;font-weight:700;margin-bottom:2px;}\n    .ev-card-prob{font-size:11px;color:#64748b;font-family:\"SF Mono\",monospace;}\n\n    @keyframes coinFlip {\n      0%   { transform: rotateX(0deg) translateY(0); }\n      25%  { transform: rotateX(360deg) translateY(-40px); }\n      50%  { transform: rotateX(720deg) translateY(-60px); }\n      75%  { transform: rotateX(1080deg) translateY(-30px); }\n      100% { transform: rotateX(1440deg) translateY(0); }\n    }\n    .coin-anim { animation: coinFlip 0.8s ease-out; }\n    .coin-container { perspective: 300px; display:inline-block; }\n  `;\n  wrapper.appendChild(style);\n\n  // ══════════════════════════════════════════════════════\n  // 3. SVG DIAGRAM\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const DW = 660, DH = 340;\n\n  function mkEl(tag, a) { const e = document.createElementNS(NS, tag); if (a) for (const [k,v] of Object.entries(a)) e.setAttribute(k,v); return e; }\n\n  const svg = document.createElementNS(NS, \"svg\");\n  svg.setAttribute(\"viewBox\", `0 0 ${DW} ${DH}`);\n  svg.style.cssText = `width:100%;max-width:${DW}px;border-radius:12px;border:1px solid #e2e8f0;margin-bottom:10px;cursor:default;overflow:visible;`;\n\n  // Background (whole SVG = omega hover zone)\n  const bg = mkEl(\"rect\", { x: \"0\", y: \"0\", width: String(DW), height: String(DH), fill: \"#fafbfc\", rx: \"12\" });\n  svg.appendChild(bg);\n\n  // Omega box\n  const omX = 30, omY = 30, omW = DW - 60, omH = DH - 60;\n  const omRect = mkEl(\"rect\", { x: String(omX), y: String(omY), width: String(omW), height: String(omH), rx: \"16\", fill: \"#f8fafc\", stroke: \"#1e293b\", \"stroke-width\": \"2.5\" });\n  svg.appendChild(omRect);\n\n  // Omega label (hoverable)\n  const omLabelG = mkEl(\"g\"); omLabelG.style.cursor = \"pointer\";\n  const omLabelBg = mkEl(\"rect\", { x: String(omX), y: String(omY), width: \"210\", height: \"32\", rx: \"8\", fill: \"transparent\" });\n  omLabelG.appendChild(omLabelBg);\n  const omLabel = mkEl(\"text\", { x: String(omX + 12), y: String(omY + 22), fill: \"#1e293b\", \"font-size\": \"16\", \"font-weight\": \"700\" });\n  omLabel.textContent = \"\\u03A9 = { HH, HT, TH, TT }\"; omLabelG.appendChild(omLabel);\n  svg.appendChild(omLabelG);\n\n  // Event region (dashed rect, behind dots)\n  const evRegionRect = mkEl(\"rect\", { rx: \"22\", fill: \"transparent\", stroke: \"transparent\", \"stroke-width\": \"3\", \"stroke-dasharray\": \"8,4\", opacity: \"0.9\" });\n  evRegionRect.style.display = \"none\"; svg.appendChild(evRegionRect);\n  const evRegionFill = mkEl(\"rect\", { rx: \"22\", fill: \"transparent\", opacity: \"0.08\" });\n  evRegionFill.style.display = \"none\"; svg.appendChild(evRegionFill);\n\n  // Dot positions: spread nicely\n  const dotPositions = [\n    { x: 170, y: 140 },  // HH\n    { x: 340, y: 110 },  // HT\n    { x: 340, y: 220 },  // TH\n    { x: 510, y: 175 },  // TT\n  ];\n\n  // Dots\n  const dotEls = [];\n  for (let i = 0; i &lt; 4; i++) {\n    const p = pts[i], pos = dotPositions[i];\n    const g = mkEl(\"g\"); g.style.cursor = \"pointer\";\n\n    // Outer ring (for highlight)\n    const ring = mkEl(\"circle\", { cx: String(pos.x), cy: String(pos.y), r: \"44\", fill: \"none\", stroke: \"transparent\", \"stroke-width\": \"3\" });\n    g.appendChild(ring);\n\n    // Main circle\n    const c = mkEl(\"circle\", { cx: String(pos.x), cy: String(pos.y), r: \"38\", fill: \"#fff\", stroke: \"#cbd5e1\", \"stroke-width\": \"2.5\" });\n    g.appendChild(c);\n\n    // Coin icons: two small circles\n    const coinY1 = pos.y - 10, coinY2 = pos.y + 10;\n    const coinR = 8;\n    for (let ci = 0; ci &lt; 2; ci++) {\n      const face = ci === 0 ? p.c1 : p.c2;\n      const cy = ci === 0 ? coinY1 : coinY2;\n      const coinBg = mkEl(\"circle\", { cx: String(pos.x - 10), cy: String(cy), r: String(coinR), fill: face === \"H\" ? \"#fef3c7\" : \"#e0e7ff\", stroke: face === \"H\" ? \"#d97706\" : \"#6366f1\", \"stroke-width\": \"1.5\" });\n      g.appendChild(coinBg);\n      const coinTxt = mkEl(\"text\", { x: String(pos.x - 10), y: String(cy + 1), \"text-anchor\": \"middle\", \"dominant-baseline\": \"middle\", fill: face === \"H\" ? \"#92400e\" : \"#4338ca\", \"font-size\": \"9\", \"font-weight\": \"700\", \"font-family\": \"'SF Mono',monospace\" });\n      coinTxt.textContent = face; g.appendChild(coinTxt);\n    }\n\n    // Label\n    const t = mkEl(\"text\", { x: String(pos.x + 10), y: String(pos.y + 1), \"text-anchor\": \"start\", \"dominant-baseline\": \"middle\", fill: \"#334155\", \"font-size\": \"16\", \"font-weight\": \"700\", \"font-family\": \"'SF Mono',monospace\" });\n    t.textContent = p.label; g.appendChild(t);\n\n    svg.appendChild(g);\n    dotEls.push({ g, c, t, ring, pos });\n\n    // Hover on dot = highlight as sample point\n    g.addEventListener(\"mouseenter\", () =&gt; { highlightPoint(i); });\n    g.addEventListener(\"mouseleave\", () =&gt; { if (!outcomeIdx &gt;= 0 || activeEvent &lt; 0) clearHighlight(); });\n  }\n\n  // Outcome ring (on top)\n  const outRing = mkEl(\"circle\", { r: \"48\", fill: \"none\", stroke: \"#dc2626\", \"stroke-width\": \"4\", \"stroke-dasharray\": \"6,3\" });\n  outRing.style.display = \"none\"; svg.appendChild(outRing);\n  const outLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#dc2626\", \"font-size\": \"13\", \"font-weight\": \"700\" });\n  outLabel.style.display = \"none\"; svg.appendChild(outLabel);\n\n  wrapper.appendChild(svg);\n\n  // ══════════════════════════════════════════════════════\n  // 4. EXPLANATION BOX\n  // ══════════════════════════════════════════════════════\n  const explainBox = document.createElement(\"div\");\n  explainBox.style.cssText = `width:100%;padding:12px 18px;border-radius:10px;margin-bottom:14px;\n    background:#fff;border:2px solid #e2e8f0;font-size:14px;color:#334155;line-height:1.7;\n    text-align:center;min-height:24px;transition:all 0.2s;`;\n  explainBox.innerHTML = `Hover over the diagram to explore. &lt;b&gt;\\u03A9&lt;/b&gt; = sample space, each circle = sample point &lt;b&gt;\\u03C9&lt;/b&gt;.`;\n  wrapper.appendChild(explainBox);\n\n  // ══════════════════════════════════════════════════════\n  // 5. COIN TOSS ANIMATION + BUTTON\n  // ══════════════════════════════════════════════════════\n  const tossRow = document.createElement(\"div\");\n  tossRow.style.cssText = \"display:flex;align-items:center;gap:16px;margin-bottom:14px;justify-content:center;\";\n\n  const coinDisplay = document.createElement(\"div\");\n  coinDisplay.style.cssText = \"display:flex;gap:10px;min-width:100px;justify-content:center;\";\n  function makeCoinEl() {\n    const outer = document.createElement(\"div\"); outer.className = \"coin-container\";\n    const coin = document.createElement(\"div\");\n    coin.style.cssText = `width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;\n      font-size:20px;font-weight:800;font-family:\"SF Mono\",monospace;border:3px solid #d1d5db;background:#f8fafc;color:#94a3b8;`;\n    coin.textContent = \"?\";\n    outer.appendChild(coin);\n    return { outer, coin };\n  }\n  const coin1 = makeCoinEl(), coin2 = makeCoinEl();\n  coinDisplay.appendChild(coin1.outer); coinDisplay.appendChild(coin2.outer);\n\n  const tossBtn = document.createElement(\"button\");\n  tossBtn.style.cssText = `padding:12px 28px;border-radius:12px;border:2px solid #dc2626;\n    background:#fef2f2;color:#dc2626;font-size:16px;font-weight:700;\n    cursor:pointer;font-family:inherit;transition:all 0.15s;`;\n  tossBtn.textContent = \"\\uD83E\\uDE99  Toss Twice!\";\n  tossBtn.addEventListener(\"mouseenter\", () =&gt; tossBtn.style.background = \"#fee2e2\");\n  tossBtn.addEventListener(\"mouseleave\", () =&gt; tossBtn.style.background = \"#fef2f2\");\n\n  tossRow.appendChild(coinDisplay); tossRow.appendChild(tossBtn);\n  wrapper.appendChild(tossRow);\n\n  // ══════════════════════════════════════════════════════\n  // 6. EVENT CARDS\n  // ══════════════════════════════════════════════════════\n  const evTitle = document.createElement(\"div\");\n  evTitle.style.cssText = \"font-size:12px;font-weight:700;color:#64748b;text-transform:uppercase;letter-spacing:0.3px;margin-bottom:8px;width:100%;text-align:left;\";\n  evTitle.textContent = \"Events (subsets of \\u03A9) — click to highlight\";\n  wrapper.appendChild(evTitle);\n\n  const evRow = document.createElement(\"div\"); evRow.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:10px;flex-wrap:wrap;\";\n\n  let activeEvent = -1, outcomeIdx = -1;\n\n  for (let ei = 0; ei &lt; events.length; ei++) {\n    const ev = events[ei];\n    const count = pts.filter(ev.test).length;\n    const card = document.createElement(\"div\"); card.className = \"ev-card\";\n    const nm = document.createElement(\"div\"); nm.className = \"ev-card-name\"; nm.style.color = ev.color; nm.textContent = ev.name;\n    const pr = document.createElement(\"div\"); pr.className = \"ev-card-prob\"; pr.textContent = `${count}/4 = ${(count/4*100).toFixed(0)}%`;\n    card.appendChild(nm); card.appendChild(pr);\n    card.addEventListener(\"click\", () =&gt; {\n      activeEvent = activeEvent === ei ? -1 : ei;\n      highlightEvent();\n    });\n    evRow.appendChild(card);\n    ev._card = card;\n  }\n  wrapper.appendChild(evRow);\n\n  // ══════════════════════════════════════════════════════\n  // 7. INTERACTION LOGIC\n  // ══════════════════════════════════════════════════════\n  function resetDots() {\n    for (let i = 0; i &lt; 4; i++) {\n      dotEls[i].c.setAttribute(\"fill\", \"#fff\"); dotEls[i].c.setAttribute(\"stroke\", \"#cbd5e1\");\n      dotEls[i].c.setAttribute(\"stroke-width\", \"2.5\"); dotEls[i].c.setAttribute(\"r\", \"38\");\n      dotEls[i].t.setAttribute(\"fill\", \"#334155\");\n      dotEls[i].ring.setAttribute(\"stroke\", \"transparent\");\n    }\n    evRegionRect.style.display = \"none\"; evRegionFill.style.display = \"none\";\n    outRing.style.display = \"none\"; outLabel.style.display = \"none\";\n    omRect.setAttribute(\"stroke-width\", \"2.5\"); omRect.setAttribute(\"fill\", \"#f8fafc\");\n  }\n\n  function highlightOmega() {\n    resetDots();\n    omRect.setAttribute(\"stroke-width\", \"4\"); omRect.setAttribute(\"fill\", \"#eef2ff\");\n    for (let i = 0; i &lt; 4; i++) {\n      dotEls[i].c.setAttribute(\"fill\", \"#eef2ff\"); dotEls[i].c.setAttribute(\"stroke\", \"#1e293b\");\n    }\n    explainBox.style.borderColor = \"#1e293b\";\n    explainBox.innerHTML = `&lt;b style=\"color:#1e293b\"&gt;\\u03A9 (Sample Space)&lt;/b&gt; = {HH, HT, TH, TT} — the set of &lt;b&gt;all 4 possible outcomes&lt;/b&gt; when tossing a coin twice.`;\n  }\n\n  function highlightPoint(i) {\n    resetDots();\n    showOutcome(); // keep outcome visible if present\n    const p = pts[i], pos = dotPositions[i];\n    dotEls[i].c.setAttribute(\"fill\", \"#dcfce7\"); dotEls[i].c.setAttribute(\"stroke\", \"#16a34a\");\n    dotEls[i].c.setAttribute(\"stroke-width\", \"3\"); dotEls[i].ring.setAttribute(\"stroke\", \"#16a34a\");\n    dotEls[i].t.setAttribute(\"fill\", \"#16a34a\");\n    explainBox.style.borderColor = \"#16a34a\";\n    explainBox.innerHTML = `&lt;b style=\"color:#16a34a\"&gt;\\u03C9 = ${p.label}&lt;/b&gt; is a &lt;b&gt;sample point&lt;/b&gt; — one element of \\u03A9. Toss 1 = ${p.c1}, Toss 2 = ${p.c2} (${p.heads} head${p.heads !== 1 ? \"s\" : \"\"}).`;\n  }\n\n  function highlightEvent() {\n    resetDots();\n    // Card states\n    for (let ei = 0; ei &lt; events.length; ei++) {\n      const ev = events[ei];\n      ev._card.style.borderColor = activeEvent === ei ? ev.color : \"#e2e8f0\";\n      ev._card.style.background = activeEvent === ei ? ev.color + \"0a\" : \"#fff\";\n    }\n\n    if (activeEvent &lt; 0) {\n      explainBox.style.borderColor = \"#e2e8f0\";\n      explainBox.innerHTML = `Click an event card to highlight its members on the diagram.`;\n      showOutcome();\n      return;\n    }\n\n    const ev = events[activeEvent];\n    const members = [], nonMembers = [];\n    for (let i = 0; i &lt; 4; i++) {\n      if (ev.test(pts[i])) members.push(i); else nonMembers.push(i);\n    }\n\n    // Fade non-members\n    for (const i of nonMembers) {\n      dotEls[i].c.setAttribute(\"fill\", \"#f1f5f9\"); dotEls[i].c.setAttribute(\"stroke\", \"#e2e8f0\");\n      dotEls[i].t.setAttribute(\"fill\", \"#cbd5e1\");\n    }\n    // Highlight members\n    for (const i of members) {\n      dotEls[i].c.setAttribute(\"fill\", ev.color + \"18\"); dotEls[i].c.setAttribute(\"stroke\", ev.color);\n      dotEls[i].c.setAttribute(\"stroke-width\", \"3\"); dotEls[i].t.setAttribute(\"fill\", ev.color);\n    }\n\n    // Enclosing region\n    if (members.length &gt; 0) {\n      let x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;\n      for (const i of members) { const pos = dotPositions[i]; x0 = Math.min(x0, pos.x); y0 = Math.min(y0, pos.y); x1 = Math.max(x1, pos.x); y1 = Math.max(y1, pos.y); }\n      const pad = 52;\n      evRegionRect.setAttribute(\"x\", x0 - pad); evRegionRect.setAttribute(\"y\", y0 - pad);\n      evRegionRect.setAttribute(\"width\", x1 - x0 + 2 * pad); evRegionRect.setAttribute(\"height\", y1 - y0 + 2 * pad);\n      evRegionRect.setAttribute(\"stroke\", ev.color); evRegionRect.style.display = \"\";\n      evRegionFill.setAttribute(\"x\", x0 - pad); evRegionFill.setAttribute(\"y\", y0 - pad);\n      evRegionFill.setAttribute(\"width\", x1 - x0 + 2 * pad); evRegionFill.setAttribute(\"height\", y1 - y0 + 2 * pad);\n      evRegionFill.setAttribute(\"rx\", \"22\"); evRegionFill.setAttribute(\"fill\", ev.color);\n      evRegionFill.style.display = \"\";\n    }\n\n    // Check if outcome is in this event\n    let outcomeNote = \"\";\n    if (outcomeIdx &gt;= 0) {\n      showOutcome();\n      const inEv = ev.test(pts[outcomeIdx]);\n      outcomeNote = ` Your outcome &lt;b&gt;${pts[outcomeIdx].label}&lt;/b&gt; is ${inEv ? `&lt;b style=\"color:${ev.color}\"&gt;\\u2208 in this event&lt;/b&gt;` : `&lt;b&gt;\\u2209 not in this event&lt;/b&gt;`}.`;\n    }\n\n    explainBox.style.borderColor = ev.color;\n    explainBox.innerHTML = `&lt;b style=\"color:${ev.color}\"&gt;Event: \"${ev.name}\"&lt;/b&gt; = {${members.map(i =&gt; pts[i].label).join(\", \")}} — ` +\n      `&lt;b&gt;${members.length}&lt;/b&gt; out of 4 sample points. P = ${members.length}/4 = &lt;b&gt;${(members.length/4).toFixed(2)}&lt;/b&gt;.${outcomeNote}`;\n  }\n\n  function clearHighlight() {\n    resetDots();\n    showOutcome();\n    if (activeEvent &gt;= 0) { highlightEvent(); return; }\n    explainBox.style.borderColor = \"#e2e8f0\";\n    explainBox.innerHTML = `Hover over the diagram to explore. &lt;b&gt;\\u03A9&lt;/b&gt; = sample space, each circle = sample point &lt;b&gt;\\u03C9&lt;/b&gt;.`;\n  }\n\n  function showOutcome() {\n    if (outcomeIdx &lt; 0) return;\n    const pos = dotPositions[outcomeIdx];\n    outRing.setAttribute(\"cx\", pos.x); outRing.setAttribute(\"cy\", pos.y); outRing.style.display = \"\";\n    outLabel.setAttribute(\"x\", pos.x); outLabel.setAttribute(\"y\", pos.y - 56);\n    outLabel.textContent = `Outcome: ${pts[outcomeIdx].label}`; outLabel.style.display = \"\";\n  }\n\n  // Omega hover (on the label or the background margins)\n  omLabelG.addEventListener(\"mouseenter\", highlightOmega);\n  omLabelG.addEventListener(\"mouseleave\", clearHighlight);\n  // Also hovering the border area of omega rect\n  omRect.addEventListener(\"mouseenter\", highlightOmega);\n  omRect.addEventListener(\"mouseleave\", clearHighlight);\n\n  // ══════════════════════════════════════════════════════\n  // 8. COIN TOSS\n  // ══════════════════════════════════════════════════════\n  function setCoin(coinEl, face) {\n    coinEl.coin.textContent = face;\n    if (face === \"H\") {\n      coinEl.coin.style.background = \"#fef3c7\"; coinEl.coin.style.borderColor = \"#d97706\"; coinEl.coin.style.color = \"#92400e\";\n    } else {\n      coinEl.coin.style.background = \"#e0e7ff\"; coinEl.coin.style.borderColor = \"#6366f1\"; coinEl.coin.style.color = \"#4338ca\";\n    }\n  }\n\n  function animateCoin(coinEl, face, delay) {\n    return new Promise(resolve =&gt; {\n      setTimeout(() =&gt; {\n        coinEl.coin.textContent = \"?\"; coinEl.coin.style.background = \"#f8fafc\";\n        coinEl.coin.style.borderColor = \"#d1d5db\"; coinEl.coin.style.color = \"#94a3b8\";\n        coinEl.coin.classList.remove(\"coin-anim\");\n        void coinEl.coin.offsetWidth; // reflow\n        coinEl.coin.classList.add(\"coin-anim\");\n        setTimeout(() =&gt; {\n          setCoin(coinEl, face);\n          coinEl.coin.classList.remove(\"coin-anim\");\n          resolve();\n        }, 800);\n      }, delay);\n    });\n  }\n\n  let tossing = false;\n  tossBtn.addEventListener(\"click\", async () =&gt; {\n    if (tossing) return;\n    tossing = true;\n    tossBtn.style.opacity = \"0.5\"; tossBtn.style.pointerEvents = \"none\";\n\n    const r = Math.floor(Math.random() * 4);\n    const p = pts[r];\n\n    // Animate both coins\n    await Promise.all([\n      animateCoin(coin1, p.c1, 0),\n      animateCoin(coin2, p.c2, 200),\n    ]);\n\n    outcomeIdx = r;\n    activeEvent = -1;\n    resetDots();\n\n    // Highlight outcome\n    const pos = dotPositions[r];\n    dotEls[r].c.setAttribute(\"fill\", \"#fef2f2\"); dotEls[r].c.setAttribute(\"stroke\", \"#dc2626\");\n    dotEls[r].c.setAttribute(\"stroke-width\", \"3\");\n    dotEls[r].t.setAttribute(\"fill\", \"#dc2626\");\n    showOutcome();\n\n    // Which events contain this outcome\n    const inEvents = events.filter(ev =&gt; ev.test(p)).map(ev =&gt; ev.name);\n    const evStr = inEvents.length &gt; 0 ? ` Belongs to: &lt;b&gt;${inEvents.join(\", \")}&lt;/b&gt;.` : \" Doesn't belong to any defined event.\";\n\n    explainBox.style.borderColor = \"#dc2626\";\n    explainBox.innerHTML = `&lt;b style=\"color:#dc2626\"&gt;Outcome: ${p.label}&lt;/b&gt; — Toss 1 = ${p.c1}, Toss 2 = ${p.c2} (${p.heads} head${p.heads !== 1 ? \"s\" : \"\"}). ` +\n      `This is the sample point that &lt;b&gt;actually occurred&lt;/b&gt;.${evStr}`;\n\n    // Update event card highlights\n    for (let ei = 0; ei &lt; events.length; ei++) {\n      events[ei]._card.style.borderColor = \"#e2e8f0\"; events[ei]._card.style.background = \"#fff\";\n    }\n\n    tossing = false;\n    tossBtn.style.opacity = \"1\"; tossBtn.style.pointerEvents = \"auto\";\n  });\n\n  // ══════════════════════════════════════════════════════\n  // 9. INIT\n  // ══════════════════════════════════════════════════════\n  clearHighlight();\n  invalidation.then(() =&gt; {});\n  wrapper.value = {};\n  return wrapper;\n})()\n\n\n\n\n\n\nXác suất là con số thể hiện khả năng xảy ra của từng điểm mẫu hay biến cố trong \\(\\Omega\\). Lưu ý: Xác suất luôn gắn liền với không gian mẫu. Xác suất sẽ thay đổi trong các không gian mẫu khác nhau.\n\n\n\n\n\n\nNoteBài tập\n\n\n\nTìm một ví dụ phép thử ngẫu nhiên khác và mô tả lại các định nghĩa này.\n\n\n\n\n1.4.6 Rời rạc (discrete)\nLà khi có “khoảng trống” giữa các giá trị.\nVí dụ: 1, 2, 3…\n\n\n1.4.7 Liên tục (continuous)\nLà khi không có khoảng trống giữa các giá trị.\nVí dụ: \\([0,1]\\)\n\nviewof prob_radial_flood = Inputs.range([0, 1], {\n  label: \"Xác suất\", \n  step: 0.01, \n  value: 0.3\n})\n\n// 1. CONFIGURATION\nradial_config_flood = ({\n  center: {x: 0.5, y: 0.2}, \n  n: 100\n})\n\n// 2. GENERATE STATIC PEOPLE\npeople_radial_flood = {\n  const rng = d3.randomLcg(42); \n  return Array.from({length: radial_config_flood.n}, (_, i) =&gt; ({\n    id: i,\n    x: rng(), \n    y: rng() * 0.4 \n  }));\n}\n\n// 3. REACTIVE SELECTION\ncurrentData_radial_flood = {\n  const cutoff = Math.round(prob_radial_flood * 100);\n  \n  const cx = radial_config_flood.center.x;\n  const cy = radial_config_flood.center.y;\n  \n  const withDist = people_radial_flood.map(p =&gt; {\n    const dx = p.x - cx;\n    const dy = p.y - cy;\n    return { ...p, dist: dx*dx + dy*dy }; \n  });\n  \n  const sorted = withDist.slice().sort((a, b) =&gt; a.dist - b.dist);\n  const selectedSet = new Set(sorted.slice(0, cutoff).map(d =&gt; d.id));\n\n  return people_radial_flood.map(p =&gt; ({\n    ...p,\n    status: selectedSet.has(p.id) ? \"Selected\" : \"Not selected\"\n  }));\n}\n\n// 4. PLOT\nPlot.plot({\n  width: 800,\n  height: 320,\n  x: { axis: null },\n  y: { axis: null },\n  \n  marks: [\n    Plot.frame({stroke: \"#ccc\"}),\n\n    // --- DENSITY (The Flood) ---\n    Plot.density(currentData_radial_flood, {\n      filter: d =&gt; d.status === \"Selected\",\n      x: \"x\",\n      y: \"y\",\n      fill: \"#4e79a7\",\n      fillOpacity: 0.3,\n      \n      // KEY CHANGES HERE:\n      bandwidth: 50,    // High bandwidth = Very smooth, merging clusters\n      thresholds: [0.005] // Low threshold = Draws even faint outer edges\n    }),\n\n    // --- DOTS ---\n    Plot.dot(currentData_radial_flood, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.status === \"Selected\" ? \"#4e79a7\" : \"#e0e0e0\",\n      r: 4,\n      fillOpacity: 0.9\n    }),\n    \n    // --- LABELS ---\n    Plot.text([prob_radial_flood], {\n      frameAnchor: \"bottom-left\",\n      dx: 10, dy: -10,\n      text: d =&gt; `Số người: ${Math.round(d * 100)}/100`, \n      fill: \"black\", stroke: \"white\", strokeWidth: 3,\n      fontSize: 16, fontWeight: \"bold\"\n    }),\n\n    Plot.text([\"Ω\"], {\n      frameAnchor: \"top-right\", dx: -15, dy: 15, \n      fontSize: 30, fontWeight: \"bold\", fill: \"#999\"\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.4.8 Quan hệ giữa hai biến cố\n\n1.4.8.1 Xung khắc (mutually exclusive)\nHai biến cố \\(A\\) và \\(B\\) được gọi là xung khắc (mutually exclusive) khi không có điểm chung nào (\\(A \\cap B = \\emptyset\\)). Chúng không thể cùng xảy ra tại một thời điểm.\n\\[\\mathbb{P}(A \\cap B) = 0\\]\nNếu \\(A\\) xảy ra thì chắc chắn \\(B\\) không xảy ra (và ngược lại).\n\\[\\mathbb{P}(A \\mid B) = 0\\]\n\\[\\mathbb{P}(B \\mid A) = 0\\]\n\n\n1.4.8.2 Phụ thuộc (dependent)\nHai biến cố \\(A\\) và \\(B\\) phụ thuộc nhau khi chúng có mối liên hệ với nhau (\\(A \\cap B \\neq \\emptyset\\)). Việc biết biến cố này xảy ra sẽ làm thay đổi xác suất của biến cố kia.\n\\[\\mathbb{P}(A \\mid B) \\neq \\mathbb{P}(A)\\]\n\\[\\mathbb{P}(B \\mid A) \\neq \\mathbb{P}(B)\\]\nĐây là trường hợp phổ biến nhất trong thực tế.\n\n\n1.4.8.3 Độc lập (independent)\nHai biến cố \\(A\\) và \\(B\\) độc lập nghĩa là việc biết \\(B\\) xảy ra không cung cấp thêm thông tin gì về khả năng xảy ra của \\(A\\) và ngược lại.\n\\[\\mathbb{P}(A \\mid B) = \\mathbb{P}(A)\\]\n\\[\\mathbb{P}(B \\mid A) = \\mathbb{P}(B)\\]\nKhi hai biến cố là độc lập, ta có thể nhân xác suất:\n\\[\\mathbb{P}(A \\cap B) = \\mathbb{P}(A) \\times \\mathbb{P}(B)\\]\nQuan hệ giữa hai biến cố có thể được minh họa bằng biểu đồ Venn như sau:\n\nviewof venn = (() =&gt; {\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:700px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  // ══════════════════════════════════════════════════════\n  // CONTROLS\n  // ══════════════════════════════════════════════════════\n  const SL = {};\n  SL.pA = createSlider(\"P(A)\", 0.01, 0.99, 0.01, 0.05, \"#5b9bd5\", \"blue\");\n  SL.pB = createSlider(\"P(B)\", 0.01, 0.99, 0.01, 0.05, \"#e8915a\", \"amber\");\n\n  const r1 = document.createElement(\"div\"); r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:16px;\";\n  r1.appendChild(SL.pA.el); r1.appendChild(SL.pB.el);\n  wrapper.appendChild(r1);\n\n  // ══════════════════════════════════════════════════════\n  // SVG\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const W = 660, H = 460;\n  // Ω box inset\n  const OX = 20, OY = 50, OW = W - 40, OH = H - 70;\n  const OMEGA_AREA = OW * OH;\n\n  function mkEl(tag, a) {\n    const e = document.createElementNS(NS, tag);\n    if (a) for (const [k,v] of Object.entries(a)) e.setAttribute(k,v);\n    return e;\n  }\n\n  const svg = document.createElementNS(NS, \"svg\");\n  svg.setAttribute(\"viewBox\", `0 0 ${W} ${H}`);\n  svg.style.cssText = `width:100%;max-width:${W}px;border-radius:12px;border:1px solid #e2e8f0;margin-bottom:12px;`;\n\n  // Outer background\n  svg.appendChild(mkEl(\"rect\", { x: \"0\", y: \"0\", width: String(W), height: String(H), fill: \"#f1f5f9\", rx: \"12\" }));\n\n  // Ω box\n  svg.appendChild(mkEl(\"rect\", { x: String(OX), y: String(OY), width: String(OW), height: String(OH), rx: \"12\", fill: \"#fafbfc\", stroke: \"#1e293b\", \"stroke-width\": \"2.5\" }));\n\n  // Title\n  const titleText = mkEl(\"text\", { x: String(W / 2), y: \"34\", \"text-anchor\": \"middle\", fill: \"#dc2626\", \"font-size\": \"22\", \"font-weight\": \"700\" });\n  svg.appendChild(titleText);\n\n  // Ω label\n  const omLabel = mkEl(\"text\", { x: String(OX + OW - 10), y: String(OY + 22), \"text-anchor\": \"end\", fill: \"#1e293b\", \"font-size\": \"22\", \"font-weight\": \"700\" });\n  omLabel.textContent = \"\\u03A9\"; svg.appendChild(omLabel);\n\n  // Clip to Ω box so circles don't overflow\n  const defs = mkEl(\"defs\");\n  const clipOmega = mkEl(\"clipPath\", { id: \"clipOmega\" });\n  clipOmega.appendChild(mkEl(\"rect\", { x: String(OX), y: String(OY), width: String(OW), height: String(OH), rx: \"12\" }));\n  defs.appendChild(clipOmega);\n\n  // Clip for intersection (circle A shape)\n  const clipA = mkEl(\"clipPath\", { id: \"clipA\" });\n  const clipACirc = mkEl(\"circle\"); clipA.appendChild(clipACirc);\n  defs.appendChild(clipA);\n  svg.appendChild(defs);\n\n  // Group clipped to Ω\n  const gClipped = mkEl(\"g\", { \"clip-path\": \"url(#clipOmega)\" });\n  svg.appendChild(gClipped);\n\n  // Circle A\n  const circA = mkEl(\"circle\", { fill: \"#5b9bd5\", opacity: \"0.25\", stroke: \"#5b9bd5\", \"stroke-width\": \"2.5\" });\n  gClipped.appendChild(circA);\n  // Circle B\n  const circB = mkEl(\"circle\", { fill: \"#f4b183\", opacity: \"0.25\", stroke: \"#e8915a\", \"stroke-width\": \"2.5\" });\n  gClipped.appendChild(circB);\n  // Intersection: B clipped to A\n  const interCirc = mkEl(\"circle\", { fill: \"#16a34a\", opacity: \"0.28\", \"clip-path\": \"url(#clipA)\" });\n  gClipped.appendChild(interCirc);\n\n  // Labels (outside clip so always visible)\n  const lblA = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#1e5a9e\", \"font-size\": \"17\", \"font-weight\": \"700\" });\n  svg.appendChild(lblA);\n  const lblB = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#b35a1f\", \"font-size\": \"17\", \"font-weight\": \"700\" });\n  svg.appendChild(lblB);\n\n  wrapper.appendChild(svg);\n\n  // ══════════════════════════════════════════════════════\n  // STATS\n  // ══════════════════════════════════════════════════════\n  const statsRow = document.createElement(\"div\");\n  statsRow.style.cssText = \"display:flex;gap:16px;width:100%;flex-wrap:wrap;margin-bottom:12px;\";\n\n  function makeStatBox(borderColor, bgColor) {\n    const box = document.createElement(\"div\");\n    box.style.cssText = `flex:1;min-width:200px;padding:12px 16px;border-radius:10px;\n      background:${bgColor};border:2px solid ${borderColor};\n      font-size:15px;line-height:2.0;\n      font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;`;\n    return box;\n  }\n\n  const statLeft = makeStatBox(\"#bfdbfe\", \"#eff6ff\");\n  const statRight = makeStatBox(\"#fed7aa\", \"#fff7ed\");\n  statsRow.appendChild(statLeft); statsRow.appendChild(statRight);\n  wrapper.appendChild(statsRow);\n\n  // ══════════════════════════════════════════════════════\n  // GEOMETRY\n  // ══════════════════════════════════════════════════════\n  // Fixed centers: A at 1/3, B at 2/3 of the Ω box\n  const AX = OX + OW * 0.37;\n  const BX = OX + OW * 0.63;\n  const CY = OY + OH * 0.5;\n  const DIST = BX - AX;\n\n  function radiusFromP(p) {\n    // Circle area = p × OMEGA_AREA  →  visually proportional to probability\n    return Math.sqrt(p * OMEGA_AREA / Math.PI);\n  }\n\n  function circleOverlapArea(r1, r2, d) {\n    if (d &gt;= r1 + r2) return 0;\n    if (d &lt;= Math.abs(r1 - r2)) return Math.PI * Math.min(r1, r2) ** 2;\n    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n    const b = d - a;\n    return r1 * r1 * Math.acos(Math.max(-1, Math.min(1, a / r1)))\n         - a * Math.sqrt(Math.max(0, r1 * r1 - a * a))\n         + r2 * r2 * Math.acos(Math.max(-1, Math.min(1, b / r2)))\n         - b * Math.sqrt(Math.max(0, r2 * r2 - b * b));\n  }\n\n  // ══════════════════════════════════════════════════════\n  // UPDATE\n  // ══════════════════════════════════════════════════════\n  function update() {\n    const pA = SL.pA.val();\n    const pB = SL.pB.val();\n\n    const rA = radiusFromP(pA);\n    const rB = radiusFromP(pB);\n\n    // Set circles\n    circA.setAttribute(\"cx\", AX); circA.setAttribute(\"cy\", CY); circA.setAttribute(\"r\", rA);\n    circB.setAttribute(\"cx\", BX); circB.setAttribute(\"cy\", CY); circB.setAttribute(\"r\", rB);\n    clipACirc.setAttribute(\"cx\", AX); clipACirc.setAttribute(\"cy\", CY); clipACirc.setAttribute(\"r\", rA);\n    interCirc.setAttribute(\"cx\", BX); interCirc.setAttribute(\"cy\", CY); interCirc.setAttribute(\"r\", rB);\n\n    // Compute overlap\n    const overlapPx = circleOverlapArea(rA, rB, DIST);\n    const pAB = overlapPx / OMEGA_AREA;\n\n    interCirc.style.display = pAB &gt; 0.001 ? \"\" : \"none\";\n\n    // Label positions: shift outward if overlapping\n    const hasOverlap = pAB &gt; 0.01;\n    const aLblX = hasOverlap ? Math.max(OX + 40, AX - rA * 0.45) : AX;\n    const bLblX = hasOverlap ? Math.min(OX + OW - 40, BX + rB * 0.45) : BX;\n\n    lblA.setAttribute(\"x\", aLblX); lblA.setAttribute(\"y\", CY + 5);\n    lblA.textContent = `P(A) = ${pA.toFixed(2)}`;\n    lblB.setAttribute(\"x\", bLblX); lblB.setAttribute(\"y\", CY + 5);\n    lblB.textContent = `P(B) = ${pB.toFixed(2)}`;\n\n    // ── Stats ──\n    const pA_B = pB &gt; 0.001 ? pAB / pB : 0;\n    const pB_A = pA &gt; 0.001 ? pAB / pA : 0;\n    const pApB = pA * pB;\n    const fmt = v =&gt; v.toFixed(2);\n\n    statLeft.innerHTML =\n      `&lt;span style=\"color:#dc2626;font-weight:700\"&gt;P(A | B)&lt;/span&gt; = ${fmt(pA_B)}&lt;br&gt;` +\n      `&lt;span style=\"color:#d97706;font-weight:700\"&gt;P(B | A)&lt;/span&gt; = ${fmt(pB_A)}`;\n\n    statRight.innerHTML =\n      `&lt;span style=\"color:#16a34a;font-weight:700\"&gt;P(A \\u2229 B)&lt;/span&gt; = ${fmt(pAB)}&lt;br&gt;` +\n      `&lt;span style=\"color:#64748b;font-weight:700\"&gt;P(A)\\u00D7P(B)&lt;/span&gt; = ${fmt(pApB)}`;\n\n    // ── Relationship ──\n    const eps = 0.002;\n    const isMutEx = pAB &lt; eps;\n    const isIndep = Math.abs(pAB - pApB) &lt; eps && !isMutEx;\n\n    if (isMutEx) {\n      titleText.textContent = \"Xung khắc\";\n      titleText.setAttribute(\"fill\", \"#dc2626\");\n    } else if (isIndep) {\n      titleText.textContent = \"Độc lập\";\n      titleText.setAttribute(\"fill\", \"#16a34a\");\n    } else {\n      titleText.textContent = \"Phụ thuộc\";\n      titleText.setAttribute(\"fill\", \"#d97706\");\n    }\n  }\n\n  // ══════════════════════════════════════════════════════\n  // EVENTS  –  enforce P(A) + P(B) ≤ 1\n  // ══════════════════════════════════════════════════════\n  function onInputA() {\n    SL.pA.sync();\n    const pA = SL.pA.val();\n    const maxB = Math.max(0.01, +(1 - pA).toFixed(2));\n    const curB = SL.pB.val();\n    // Clamp P(B) if the sum exceeds 1\n    if (curB &gt; maxB) {\n      SL.pB.update(maxB, null, maxB);\n    } else {\n      // Just update the max so the slider range shrinks\n      SL.pB.update(curB, null, maxB);\n    }\n    update();\n  }\n\n  function onInputB() {\n    SL.pB.sync();\n    const pB = SL.pB.val();\n    const maxA = Math.max(0.01, +(1 - pB).toFixed(2));\n    const curA = SL.pA.val();\n    // Clamp P(A) if the sum exceeds 1\n    if (curA &gt; maxA) {\n      SL.pA.update(maxA, null, maxA);\n    } else {\n      SL.pA.update(curA, null, maxA);\n    }\n    update();\n  }\n\n  SL.pA.input.addEventListener(\"input\", onInputA);\n  SL.pB.input.addEventListener(\"input\", onInputB);\n\n  // Initial constraint setup\n  onInputA();\n\n  invalidation.then(() =&gt; {\n    SL.pA.input.removeEventListener(\"input\", onInputA);\n    SL.pB.input.removeEventListener(\"input\", onInputB);\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#biến-ngẫu-nhiên-random-variable",
    "href": "prob.html#biến-ngẫu-nhiên-random-variable",
    "title": "1  Xác suất",
    "section": "1.5 Biến ngẫu nhiên (random variable)",
    "text": "1.5 Biến ngẫu nhiên (random variable)\nmột biến thực có thể nhận các giá trị khác nhau với các xác suất khác nhau\nLà một hàm số (function) gán một số thực cho mỗi điểm mẫu trong không gian mẫu của một phép thử ngẫu nhiên.\n\\[X: \\Omega \\rightarrow \\mathbb{R}\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#đo-lường-biến-ngẫu-nhiên",
    "href": "prob.html#đo-lường-biến-ngẫu-nhiên",
    "title": "1  Xác suất",
    "section": "1.6 Đo lường biến ngẫu nhiên",
    "text": "1.6 Đo lường biến ngẫu nhiên\nBiến ngẫu nhiên được chia thành 4 loại dựa theo loại phép tính được thực hiện mà không làm sai lệch ý nghĩa của dữ liệu (Stevens 1946; Daniel and Cross 2018).\n\n\n\n\n\n\n\n\n\nBiến\nPhép toán cơ bản\nÝ nghĩa thống kê\nVí dụ\n\n\n\n\nDanh định (nominal)\nXác định sự bằng nhau \\(=, \\ne\\)\nPhân loại\nGiới tính, nhóm máu\n\n\nThứ bậc (ordinal)\nXác định lớn hơn, nhỏ hơn \\(&gt;, &lt;\\)\nXếp hạng\nMức độ đau, thang Likert\n\n\nKhoảng (interval)\nXác định khoảng cách chênh lệch \\(+, -\\)\nChênh lệch\nNhiệt độ, điểm IQ\n\n\nTỉ số (ratio)\nXác định gấp bao nhiêu lần \\(\\times, \\div\\)\nGấp lần\nSố lượng bạch cầu, cân nặng, chiều cao\n\n\n\nThang đo cao hơn sẽ giữ lại tất cả đặc tính của thang đo thấp hơn và thêm vào đặc tính mới. Ví dụ: Khoảng thời gian là biến tỉ số, người A chạy mất 30 phút, người B chạy mất 10 phút:\n\n30 phút \\(\\neq\\) 10 phút (danh định)\n30 phút \\(&gt;\\) 10 phút (thứ bậc)\nA chạy chậm hơn B 20 phút (khoảng)\nA chạy chậm gấp 3 lần B (tỉ số)\n\nVì biến cấp cao hơn chứa mọi đặc tính của biến cấp thấp hơn, nên luôn có thể hạ cấp dữ liệu (biến đổi từ cao xuống thấp), nhưng không thể làm ngược lại.\n\n\n\n\n\n\nImportant\n\n\n\nLuôn thu thập dữ liệu ở thang đo cao nhất có thể (tỉ số hoặc khoảng), vì từ thang cao có thể quy đổi xuống thấp tùy thích, nhưng không làm ngược lại được.\n\n\nVí dụ: Thu thập tuổi thay vì chia thành nhóm tuổi (0-5, 5-10, &gt;10), hay danh định (trẻ em, người lớn).\n\n\n\n\nDaniel, Wayne W., and Chad L. Cross. 2018. Biostatistics: A Foundation for Analysis in the Health Sciences. John Wiley & Sons.\n\n\nStevens, S. S. 1946. “On the Theory of Scales of Measurement.” Science 103 (2684): 677–80. https://doi.org/10.1126/science.103.2684.677.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "distr.html",
    "href": "distr.html",
    "title": "2  Phân phối xác suất",
    "section": "",
    "text": "2.1 Định nghĩa\nPhân phối xác suất (probability distribution) là một hàm số (function) thể hiện xác suất của mọi biến cố (tập hợp con) của không gian mẫu \\(\\Omega\\).\nPhân phối xác suất bắt buộc phải thỏa 3 điều kiện sau:\n\\[\\mathbb{P}(A_1 \\cup A_2 \\cup \\cdots \\cup A_n) = \\mathbb{P}(A_1) + \\mathbb{P}(A_2) + \\cdots + \\mathbb{P}(A_n)\\]\nMỗi biến ngẫu nhiên có 1 phân phối xác suất. Do có 2 loại biến rời rạc và liên tục, nên phân phối xác suất cũng được phân loại thành phân phối rời rạc và liên tục tương ứng.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Phân phối xác suất</span>"
    ]
  },
  {
    "objectID": "distr.html#định-nghĩa",
    "href": "distr.html#định-nghĩa",
    "title": "2  Phân phối xác suất",
    "section": "",
    "text": "\\(\\mathbb{P}(\\Omega) = 1\\)\n\\(0 \\leq \\mathbb{P}(A) \\leq 1\\) với mọi biến cố \\(A\\)\nNếu các biến số \\(A_1\\), \\(A_2\\), …, \\(A_n\\) xung khắc, thì:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Phân phối xác suất</span>"
    ]
  },
  {
    "objectID": "distr.html#các-hàm-phân-phối-xác-suất",
    "href": "distr.html#các-hàm-phân-phối-xác-suất",
    "title": "2  Phân phối xác suất",
    "section": "2.2 Các hàm phân phối xác suất",
    "text": "2.2 Các hàm phân phối xác suất\n\n2.2.1 Hàm khối/mật độ xác suất\n\n\n2.2.2 \n\n\n2.2.3 Joint distribution",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Phân phối xác suất</span>"
    ]
  },
  {
    "objectID": "distr.html#moment",
    "href": "distr.html#moment",
    "title": "2  Phân phối xác suất",
    "section": "2.3 Moment",
    "text": "2.3 Moment\nHình dạng của một phân phối được xác định bởi các giá trị gọi là moment. Thuật ngữ này được mượn từ vật lý: mô-men (hay mô-men lực) là đại lượng đo khả năng làm quay của một lực quanh một điểm tựa.\nTrong vật lý, moment (\\(M\\)) được tính bằng:\n\\[M = \\underbrace{d}_{\\text{Khoảng cách đến điểm tựa}} \\times \\underbrace{F}_{\\text{Lực tác dụng}}\\]\nTrong thống kê, hãy tưởng tượng trục số như một cái bập bênh. Mỗi giá trị \\(x\\) là một vị trí trên thanh đòn, và “sức nặng” tại điểm đó chính là xác suất xảy ra của nó. Khi đó, ta thấy sự tương đồng với moment trong vật lý:\n\nLực (\\(F\\)): Tương ứng với Xác suất \\(f(x)\\) (hoặc \\(\\mathbb{P}(X=x)\\)). Giá trị nào có xác suất càng cao thì “lực” đè xuống càng nặng.\nKhoảng cách đến điểm tựa (\\(d\\)): Tương ứng với \\((x - a)\\) là khoảng cách từ giá trị dữ liệu \\(x\\) tới một điểm mốc \\(a\\) (ví dụ: gốc 0 hoặc giá trị trung bình).\n\nTổng hợp lại, moment chính là tổng (hoặc tích phân) của các tích số giữa khoảng cách và xác suất. Trong ngôn ngữ thống kê, phép tổng có trọng số này chính là Kỳ vọng (\\(E\\)).\nCông thức moment bậc \\(n\\) quanh điểm \\(a\\) được viết là:\n\\[E[(X - a)^n] = \\begin{cases} \\sum (x_i - a)^n \\mathbb{P}(x_i) & \\text{(Rời rạc)} \\\\ \\int_{-\\infty}^{\\infty} (x - a)^n f(x) dx & \\text{(Liên tục)} \\end{cases}\\]\n\n\n\n\n\n\nImportant\n\n\n\nKý hiệu \\(E[g(X)]\\) chính là định nghĩa toán học của việc lấy giá trị \\(g(X)\\) nhân với xác suất rồi cộng lại. Bất cứ khi nào thấy “Lấy một giá trị, nhân với xác suất của nó, rồi cộng hết lại”, thì đó chính là Kỳ vọng (\\(E\\)).\n\n\nMột cách tổng quát, với một biến ngẫu nhiên \\(X\\), moment bậc \\(n\\) quanh điểm \\(a\\) (the \\(n\\)-th moment about \\(a\\)) là:\n\\[E[(X - a)^n]\\]\nCó 2 loại moment:\n\nMoment gốc (raw moment, lấy mốc là điểm 0): khi \\(a = 0\\), moment là \\(E[X^n]\\).\nMoment tập trung (central moment, lấy mốc là giá trị trung bình): khi \\(a = E[X]\\), moment là \\(E[(X - E[X])^n]\\).\n\nBậc của moment có thể từ 0 đến \\(\\infty\\). Chúng ta thường quan tâm tới 4 loại moment sau:\n\n\n\n\n\n\n\n\n\nLoại moment\nKí hiệu\nTên thường gọi\nÝ nghĩa\n\n\n\n\nGốc bậc 1\n\\(E[X]\\)\nKỳ vọng (Mean)\nVị trí (tâm của phân phối)\n\n\nTập trung bậc 2\n\\(E[(X - E[X])^2]\\)\nPhương sai (Variance)\nĐộ phân tán (dữ liệu biến động thế nào)\n\n\nTập trung bậc 3\n\\(E[(X - E[X])^3]\\)\nĐộ lệch (Skewness)*\nTính bất đối xứng (bên nào có đuôi dài hơn)\n\n\nTập trung bậc 4\n\\(E[(X - E[X])^4]\\)\nĐộ nhọn (Kurtosis)*\nĐộ dày của đuôi\n\n\n\n*Độ lệch và Độ nhọn thường được chuẩn hóa (standardised) bằng cách chia cho độ lệch chuẩn \\(\\sigma\\), ý nghĩa là gấp bao nhiêu lần độ lệch chuẩn.\n\nviewof moment_seesaw = {\n\n  // ═══════════════════════════════════════════════════\n  // CONFIG\n  // ═══════════════════════════════════════════════════\n  const W = 780, H = 470;\n  const COL = {\n    beam: \"#FFB300\", beamStroke: \"#F9A825\",\n    pivot: \"#F4511E\", pivotStroke: \"#D84315\",\n    block: \"#EF5350\", blockStroke: \"#C62828\",\n    blockAlt: \"#FF7043\", blockAltStroke: \"#E64A19\",\n    dist: \"#1565C0\",\n    force: \"#00897B\",\n    moment: \"#7B1FA2\",\n    ref: \"#E91E63\",\n    bg: \"#fff\", sub: \"#78909C\", txt: \"#263238\",\n    snap: \"#43A047\",\n  };\n\n  // Distribution presets\n  const distributions = {\n    \"Đối xứng (Symmetric)\": [\n      { x: 1, freq: 1 }, { x: 2, freq: 3 }, { x: 3, freq: 5 },\n      { x: 4, freq: 7 }, { x: 5, freq: 5 }, { x: 6, freq: 3 }, { x: 7, freq: 1 },\n    ],\n    \"Lệch phải (Right-skewed)\": [\n      { x: 1, freq: 7 }, { x: 2, freq: 5 }, { x: 3, freq: 4 },\n      { x: 4, freq: 3 }, { x: 5, freq: 2 }, { x: 7, freq: 1 },\n    ],\n    \"Lệch trái (Left-skewed)\": [\n      { x: 1, freq: 1 }, { x: 3, freq: 2 }, { x: 4, freq: 3 },\n      { x: 5, freq: 4 }, { x: 6, freq: 5 }, { x: 7, freq: 7 },\n    ],\n    \"Đều (Uniform)\": [\n      { x: 1, freq: 4 }, { x: 2, freq: 4 }, { x: 3, freq: 4 },\n      { x: 4, freq: 4 }, { x: 5, freq: 4 }, { x: 6, freq: 4 },\n    ],\n    \"Hai đỉnh (Bimodal)\": [\n      { x: 1, freq: 6 }, { x: 2, freq: 4 }, { x: 3, freq: 1 },\n      { x: 5, freq: 1 }, { x: 6, freq: 4 }, { x: 7, freq: 6 },\n    ],\n    \"Đuôi nặng (Heavy-tailed)\": [\n      { x: 0, freq: 2 }, { x: 2, freq: 1 }, { x: 3, freq: 3 },\n      { x: 4, freq: 6 }, { x: 5, freq: 3 }, { x: 6, freq: 1 }, { x: 8, freq: 2 },\n    ],\n  };\n\n  let dataPoints = distributions[\"Lệch phải (Right-skewed)\"].map(d =&gt; ({ ...d }));\n\n  const outer = document.createElement(\"div\");\n  outer.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:820px;margin:0 auto;`;\n  outer.appendChild(injectStyle());\n\n  // ═══════════════════════════════════════════════════\n  // STATE\n  // ═══════════════════════════════════════════════════\n  let useCenter = false;\n  let momentOrder = 1;\n  let pivotValue = 0;\n  let isDragging = false;\n  let activeDist = \"Lệch phải (Right-skewed)\";\n\n  // ═══════════════════════════════════════════════════\n  // CONTROLS\n  // ═══════════════════════════════════════════════════\n\n  // Distribution selector\n  const distRow = document.createElement(\"div\");\n  distRow.style.cssText = \"display:flex;gap:6px;width:100%;margin-bottom:10px;flex-wrap:wrap;align-items:center;\";\n  const distLabel = document.createElement(\"span\");\n  distLabel.style.cssText = `font-size:13px;font-weight:700;color:${COL.sub};margin-right:4px;`;\n  distLabel.textContent = \"Dữ liệu:\";\n  distRow.appendChild(distLabel);\n\n  const distBtns = {};\n  Object.keys(distributions).forEach(name =&gt; {\n    const b = document.createElement(\"button\");\n    b.style.cssText = `padding:6px 12px;border-radius:8px;font-size:12px;font-weight:600;\n      font-family:inherit;cursor:pointer;transition:all 0.15s;border:1.5px solid #B0BEC5;\n      background:#fff;color:${COL.txt};`;\n    b.textContent = name;\n    b.addEventListener(\"click\", () =&gt; {\n      activeDist = name;\n      dataPoints = distributions[name].map(d =&gt; ({ ...d }));\n      if (useCenter) pivotValue = computeMean();\n      else pivotValue = 0;\n      update();\n    });\n    distBtns[name] = b;\n    distRow.appendChild(b);\n  });\n  outer.appendChild(distRow);\n\n  function styleDistBtn(btn, active) {\n    btn.style.background = active ? COL.txt : \"#fff\";\n    btn.style.color = active ? \"#fff\" : COL.txt;\n    btn.style.borderColor = active ? COL.txt : \"#B0BEC5\";\n  }\n\n  // Mode row\n  const modeRow = document.createElement(\"div\");\n  modeRow.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:8px;\";\n\n  function mkModeBtn(text) {\n    const b = document.createElement(\"button\");\n    b.style.cssText = `flex:1;padding:10px 14px;border-radius:8px;font-size:12px;font-weight:700;\n      font-family:inherit;cursor:pointer;transition:all 0.15s;border:2px solid ${COL.ref};\n      background:#fff;color:${COL.ref};`;\n    b.textContent = text;\n    return b;\n  }\n  const btnRaw = mkModeBtn(\"a = 0  (Moment gốc)\");\n  const btnCentral = mkModeBtn(\"a = μ  (Moment tập trung)\");\n  modeRow.appendChild(btnRaw);\n  modeRow.appendChild(btnCentral);\n  outer.appendChild(modeRow);\n\n  function styleModeBtn(btn, active) {\n    btn.style.background = active ? COL.ref : \"#fff\";\n    btn.style.color = active ? \"#fff\" : COL.ref;\n    btn.style.borderColor = COL.ref;\n  }\n\n  // Order tabs (always shown)\n  const orderRow = document.createElement(\"div\");\n  orderRow.style.cssText = \"display:flex;gap:8px;width:100%;margin-bottom:8px;align-items:center;\";\n  const orderLabel = document.createElement(\"span\");\n  orderLabel.style.cssText = `font-size:13px;font-weight:700;color:${COL.sub};margin-right:4px;`;\n  orderLabel.textContent = \"Bậc (Order):\";\n  orderRow.appendChild(orderLabel);\n\n  const orderBtns = [];\n  const orderDefs = [\n    { n: 1, label: \"n = 1\" },\n    { n: 2, label: \"n = 2\" },\n    { n: 3, label: \"n = 3\" },\n    { n: 4, label: \"n = 4\" },\n  ];\n  orderDefs.forEach(od =&gt; {\n    const b = document.createElement(\"button\");\n    b.style.cssText = `padding:8px 14px;border-radius:8px;font-size:12px;font-weight:700;\n      font-family:inherit;cursor:pointer;transition:all 0.15s;border:2px solid ${COL.moment};\n      background:#fff;color:${COL.moment};`;\n    b.textContent = od.label;\n    b.addEventListener(\"click\", () =&gt; {\n      if (!useCenter && od.n &gt; 1) return; // raw mode: only n=1\n      if (useCenter && od.n &lt; 2) return;  // central mode: only n&gt;=2\n      momentOrder = od.n;\n      update();\n    });\n    orderBtns.push({ el: b, n: od.n });\n    orderRow.appendChild(b);\n  });\n  outer.appendChild(orderRow);\n\n  function styleOrderBtn(btn, n, active, enabled) {\n    if (!enabled) {\n      btn.style.background = \"#f5f5f5\";\n      btn.style.color = \"#ccc\";\n      btn.style.borderColor = \"#e0e0e0\";\n      btn.style.cursor = \"not-allowed\";\n    } else if (active) {\n      btn.style.background = COL.moment;\n      btn.style.color = \"#fff\";\n      btn.style.borderColor = COL.moment;\n      btn.style.cursor = \"pointer\";\n    } else {\n      btn.style.background = \"#fff\";\n      btn.style.color = COL.moment;\n      btn.style.borderColor = COL.moment;\n      btn.style.cursor = \"pointer\";\n    }\n  }\n\n  // Mode events\n  btnRaw.addEventListener(\"click\", () =&gt; {\n    useCenter = false; pivotValue = 0; momentOrder = 1;\n    update();\n  });\n  btnCentral.addEventListener(\"click\", () =&gt; {\n    useCenter = true; pivotValue = computeMean();\n    if (momentOrder &lt; 2) momentOrder = 2;\n    update();\n  });\n\n  // Drag hint\n  const hintRow = document.createElement(\"div\");\n  hintRow.style.cssText = `font-size:12px;color:${COL.sub};margin-bottom:6px;width:100%;text-align:center;font-style:italic;`;\n  hintRow.textContent = \"💡 Kéo chân đế của bập bênh để thay đổi điểm mốc\";\n  outer.appendChild(hintRow);\n\n  // ═══════════════════════════════════════════════════\n  // SVG\n  // ═══════════════════════════════════════════════════\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", [0, 0, W, H])\n    .style(\"width\", \"100%\").style(\"max-width\", W + \"px\")\n    .style(\"background\", COL.bg);\n\n  const defs = svg.append(\"defs\");\n\n  // Arrow markers\n  function addArrow(id, color) {\n    defs.append(\"marker\").attr(\"id\", id)\n      .attr(\"viewBox\", \"0 0 10 7\").attr(\"refX\", 9).attr(\"refY\", 3.5)\n      .attr(\"markerWidth\", 10).attr(\"markerHeight\", 7).attr(\"orient\", \"auto\")\n      .append(\"polygon\").attr(\"points\", \"0 0.5, 9 3.5, 0 6.5\").attr(\"fill\", color);\n  }\n  addArrow(\"arrDistR\", COL.dist);\n  addArrow(\"arrForce\", COL.force);\n  defs.append(\"marker\").attr(\"id\", \"arrDistL\")\n    .attr(\"viewBox\", \"0 0 10 7\").attr(\"refX\", 1).attr(\"refY\", 3.5)\n    .attr(\"markerWidth\", 10).attr(\"markerHeight\", 7).attr(\"orient\", \"auto\")\n    .append(\"polygon\").attr(\"points\", \"10 0.5, 1 3.5, 10 6.5\").attr(\"fill\", COL.dist);\n\n  // ── LAYOUT ──\n  const beamCX = W / 2, beamCY = 290;\n  const beamHalfW = 330, beamH = 16;\n  const blockSize = 22;\n  const pivotH = 70, pivotW = 60;\n\n  // ── FORMULA (top) ──\n  const formulaText = svg.append(\"text\")\n    .attr(\"x\", W / 2).attr(\"y\", 26)\n    .attr(\"text-anchor\", \"middle\").attr(\"font-size\", 18).attr(\"font-weight\", 700)\n    .attr(\"font-family\", \"'SF Mono',SFMono-Regular,Menlo,monospace\");\n  const formulaSub = svg.append(\"text\")\n    .attr(\"x\", W / 2).attr(\"y\", 50)\n    .attr(\"text-anchor\", \"middle\").attr(\"font-size\", 14).attr(\"fill\", COL.sub);\n\n  // ── BALANCE BADGE (top right) ──\n  const balanceG = svg.append(\"g\").style(\"display\", \"none\");\n  const balanceBg = balanceG.append(\"rect\").attr(\"rx\", 10).attr(\"fill\", COL.snap);\n  const balanceTxt = balanceG.append(\"text\").attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\")\n    .attr(\"fill\", \"#fff\").attr(\"font-size\", 14).attr(\"font-weight\", 700).text(\"Cân bằng!\");\n\n  // ── SCENE GROUP (rotates) ──\n  const sceneG = svg.append(\"g\");\n\n  // Beam\n  sceneG.append(\"rect\")\n    .attr(\"x\", beamCX - beamHalfW).attr(\"y\", beamCY - beamH / 2)\n    .attr(\"width\", beamHalfW * 2).attr(\"height\", beamH)\n    .attr(\"rx\", 5).attr(\"fill\", COL.beam).attr(\"stroke\", COL.beamStroke).attr(\"stroke-width\", 1.5);\n\n  const tickG = sceneG.append(\"g\");\n  const blocksG = sceneG.append(\"g\");\n\n  // ── PIVOT ──\n  const pivotTriG = svg.append(\"g\").style(\"cursor\", \"ew-resize\");\n  pivotTriG.append(\"polygon\")\n    .attr(\"points\", `0,0 ${-pivotW / 2 - 12},${pivotH + 12} ${pivotW / 2 + 12},${pivotH + 12}`)\n    .attr(\"fill\", \"transparent\");\n  pivotTriG.append(\"polygon\")\n    .attr(\"class\", \"pivot-tri\")\n    .attr(\"points\", `0,4 ${-pivotW / 2},${pivotH} ${pivotW / 2},${pivotH}`)\n    .attr(\"fill\", COL.pivot).attr(\"stroke\", COL.pivotStroke).attr(\"stroke-width\", 1.5).attr(\"stroke-linejoin\", \"round\");\n  pivotTriG.append(\"circle\").attr(\"cx\", 0).attr(\"cy\", 8).attr(\"r\", 8)\n    .attr(\"fill\", \"#fff\").attr(\"stroke\", COL.pivotStroke).attr(\"stroke-width\", 1.5);\n  pivotTriG.append(\"circle\").attr(\"cx\", 0).attr(\"cy\", 8).attr(\"r\", 3.5).attr(\"fill\", COL.pivot);\n\n  // ── ANNOTATIONS ──\n  const annoG = svg.append(\"g\");\n\n  // Ref line & pill\n  const refLine = annoG.append(\"line\").attr(\"stroke\", COL.ref).attr(\"stroke-width\", 1.5).attr(\"stroke-dasharray\", \"5,3\");\n  const refPill = annoG.append(\"g\");\n  const refPillBg = refPill.append(\"rect\").attr(\"rx\", 10).attr(\"fill\", COL.ref);\n  const refPillTxt = refPill.append(\"text\").attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\")\n    .attr(\"fill\", \"#fff\").attr(\"font-size\", 14).attr(\"font-weight\", 700);\n\n  // Hover annotations\n  const distAnnoG = annoG.append(\"g\").style(\"display\", \"none\");\n  const distLine1 = distAnnoG.append(\"line\").attr(\"stroke\", COL.dist).attr(\"stroke-width\", 2)\n    .attr(\"marker-start\", \"url(#arrDistL)\").attr(\"marker-end\", \"url(#arrDistR)\");\n  const distPill = distAnnoG.append(\"g\");\n  const distPillBg = distPill.append(\"rect\").attr(\"rx\", 8).attr(\"fill\", COL.dist);\n  const distPillTxt = distPill.append(\"text\").attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\")\n    .attr(\"fill\", \"#fff\").attr(\"font-size\", 12).attr(\"font-weight\", 700)\n    .attr(\"font-family\", \"'SF Mono',monospace\");\n  const forceArrow = distAnnoG.append(\"line\").attr(\"stroke\", COL.force).attr(\"stroke-width\", 2.5)\n    .attr(\"marker-end\", \"url(#arrForce)\");\n  const forcePill = distAnnoG.append(\"g\");\n  const forcePillBg = forcePill.append(\"rect\").attr(\"rx\", 8).attr(\"fill\", COL.force);\n  const forcePillTxt = forcePill.append(\"text\").attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\")\n    .attr(\"fill\", \"#fff\").attr(\"font-size\", 12).attr(\"font-weight\", 700);\n\n  // ── CONTRIBUTION BARS ──\n  const contribG = svg.append(\"g\");\n\n  outer.appendChild(svg.node());\n\n  // ═══════════════════════════════════════════════════\n  // X-SCALE\n  // ═══════════════════════════════════════════════════\n  let xScale;\n  function buildXScale() {\n    const allX = dataPoints.map(d =&gt; d.x);\n    const xMin = Math.min(0, ...allX) - 1;\n    const xMax = Math.max(...allX) + 1;\n    xScale = d3.scaleLinear()\n      .domain([xMin, xMax])\n      .range([beamCX - beamHalfW + 24, beamCX + beamHalfW - 24]);\n  }\n\n  // ═══════════════════════════════════════════════════\n  // COMPUTE\n  // ═══════════════════════════════════════════════════\n  function computeMean() {\n    let sumF = 0, sumFX = 0;\n    for (const d of dataPoints) { sumF += d.freq; sumFX += d.freq * d.x; }\n    return sumF &gt; 0 ? sumFX / sumF : 0;\n  }\n  function computeMoment(n, center) {\n    let sumF = 0, sumM = 0;\n    for (const d of dataPoints) { sumF += d.freq; sumM += d.freq * Math.pow(d.x - center, n); }\n    return sumF &gt; 0 ? sumM / sumF : 0;\n  }\n\n  // ═══════════════════════════════════════════════════\n  // HOVER\n  // ═══════════════════════════════════════════════════\n  function showAnnotation(d) {\n    const n = momentOrder;\n    const center = pivotValue;\n    const refPx = xScale(center);\n    const hlPx = xScale(d.x);\n    const topOfStack = beamCY - beamH / 2 - d.freq * (blockSize + 2) - 2;\n    const distY = topOfStack - 14;\n\n    if (Math.abs(hlPx - refPx) &gt; 20) {\n      distLine1.attr(\"x1\", refPx).attr(\"y1\", distY).attr(\"x2\", hlPx).attr(\"y2\", distY).style(\"display\", \"\");\n      const distMidX = (refPx + hlPx) / 2;\n      const distVal = (d.x - center);\n      const distTxt = n &gt; 1\n        ? `(${distVal.toFixed(1)})${[\"\", \"\", \"\\u00B2\", \"\\u00B3\", \"\\u2074\"][n]}`\n        : `${distVal.toFixed(1)}`;\n      distPillTxt.text(`d = ${distTxt}`);\n      const dtw = distTxt.length * 7 + 50;\n      distPillBg.attr(\"x\", distMidX - dtw / 2).attr(\"y\", distY - 22).attr(\"width\", dtw).attr(\"height\", 20);\n      distPillTxt.attr(\"x\", distMidX).attr(\"y\", distY - 12);\n      distPill.style(\"display\", \"\");\n    } else {\n      distLine1.style(\"display\", \"none\");\n      distPill.style(\"display\", \"none\");\n    }\n\n    const forceArrowX = hlPx + blockSize / 2 + 10;\n    const forceY1 = topOfStack + 4;\n    const forceLen = 16 + d.freq * 10;\n    forceArrow.attr(\"x1\", forceArrowX).attr(\"y1\", forceY1)\n      .attr(\"x2\", forceArrowX).attr(\"y2\", forceY1 + forceLen).style(\"display\", \"\");\n    forcePillTxt.text(`f = ${d.freq}`);\n    const ftw = 58;\n    forcePillBg.attr(\"x\", forceArrowX - ftw / 2).attr(\"y\", forceY1 + forceLen + 3).attr(\"width\", ftw).attr(\"height\", 20);\n    forcePillTxt.attr(\"x\", forceArrowX).attr(\"y\", forceY1 + forceLen + 13);\n    forcePill.style(\"display\", \"\");\n    distAnnoG.style(\"display\", \"\");\n  }\n\n  function hideAnnotation() {\n    distAnnoG.style(\"display\", \"none\");\n  }\n\n  // ═══════════════════════════════════════════════════\n  // DRAG\n  // ═══════════════════════════════════════════════════\n  const pivotDrag = d3.drag()\n    .on(\"start\", function () {\n      isDragging = true;\n      pivotTriG.select(\".pivot-tri\").attr(\"fill\", \"#FF8A65\");\n    })\n    .on(\"drag\", function (event) {\n      const px = Math.max(beamCX - beamHalfW + 24, Math.min(beamCX + beamHalfW - 24, event.x));\n      pivotValue = Math.round(xScale.invert(px) * 10) / 10;\n      update(true);\n    })\n    .on(\"end\", function () {\n      isDragging = false;\n      pivotTriG.select(\".pivot-tri\").attr(\"fill\", COL.pivot);\n      const mean = computeMean();\n      if (Math.abs(pivotValue - mean) &lt; 0.2) {\n        pivotValue = mean; useCenter = true;\n        if (momentOrder &lt; 2) momentOrder = 2;\n      } else if (Math.abs(pivotValue) &lt; 0.2) {\n        pivotValue = 0; useCenter = false; momentOrder = 1;\n      }\n      update();\n    });\n  pivotTriG.call(pivotDrag);\n\n  // ═══════════════════════════════════════════════════\n  // UPDATE\n  // ═══════════════════════════════════════════════════\n  function update(noTransition) {\n    const n = momentOrder;\n    const mean = computeMean();\n    const center = pivotValue;\n    const momentVal = computeMoment(n, center);\n\n    const isExactlyRaw = Math.abs(center) &lt; 0.001;\n    const isExactlyCentral = Math.abs(center - mean) &lt; 0.001;\n\n    // Controls\n    styleModeBtn(btnRaw, !useCenter);\n    styleModeBtn(btnCentral, useCenter);\n    Object.entries(distBtns).forEach(([name, btn]) =&gt; styleDistBtn(btn, name === activeDist));\n\n    // Order buttons: enable/disable based on mode\n    orderBtns.forEach(ob =&gt; {\n      const enabled = useCenter ? ob.n &gt;= 2 : ob.n === 1;\n      styleOrderBtn(ob.el, ob.n, ob.n === n, enabled);\n    });\n\n    buildXScale();\n    const allX = dataPoints.map(d =&gt; d.x);\n    const xMin = Math.min(0, ...allX) - 1;\n    const xMax = Math.max(...allX) + 1;\n\n    // Pivot\n    const pivotPx = xScale(center);\n    if (noTransition) {\n      pivotTriG.attr(\"transform\", `translate(${pivotPx}, ${beamCY})`);\n    } else {\n      pivotTriG.transition().duration(500).ease(d3.easeCubicOut)\n        .attr(\"transform\", `translate(${pivotPx}, ${beamCY})`);\n    }\n\n    // Tilt\n    const m1 = computeMoment(1, center);\n    const tiltDeg = Math.max(-12, Math.min(12, m1 * 4));\n    if (noTransition) {\n      sceneG.attr(\"transform\", `rotate(${tiltDeg}, ${pivotPx}, ${beamCY})`);\n    } else {\n      sceneG.transition().duration(500).ease(d3.easeCubicOut)\n        .attr(\"transform\", `rotate(${tiltDeg}, ${pivotPx}, ${beamCY})`);\n    }\n\n    // Balance badge — top right\n    const isBalanced = Math.abs(m1) &lt; 0.05;\n    if (isBalanced) {\n      const bw = 110, bh = 26;\n      balanceBg.attr(\"x\", W - bw - 14).attr(\"y\", 12).attr(\"width\", bw).attr(\"height\", bh);\n      balanceTxt.attr(\"x\", W - bw / 2 - 14).attr(\"y\", 25);\n      balanceG.style(\"display\", \"\");\n    } else {\n      balanceG.style(\"display\", \"none\");\n    }\n\n    // Ticks\n    tickG.selectAll(\"*\").remove();\n    for (let x = Math.ceil(xMin); x &lt;= Math.floor(xMax); x++) {\n      const tx = xScale(x);\n      tickG.append(\"line\").attr(\"x1\", tx).attr(\"x2\", tx)\n        .attr(\"y1\", beamCY - beamH / 2 - 4).attr(\"y2\", beamCY - beamH / 2)\n        .attr(\"stroke\", COL.beamStroke).attr(\"stroke-width\", 1.2);\n      tickG.append(\"text\").attr(\"x\", tx).attr(\"y\", beamCY + beamH / 2 + 14)\n        .attr(\"text-anchor\", \"middle\").attr(\"font-size\", 12).attr(\"fill\", COL.sub)\n        .attr(\"font-family\", \"'SF Mono',monospace\").text(x);\n    }\n\n    // Blocks\n    blocksG.selectAll(\"*\").remove();\n    dataPoints.forEach((d) =&gt; {\n      const bx = xScale(d.x);\n      for (let f = 0; f &lt; d.freq; f++) {\n        const by = beamCY - beamH / 2 - (f + 1) * (blockSize + 2) - 2;\n        const g = blocksG.append(\"g\").style(\"cursor\", \"pointer\");\n        g.append(\"rect\")\n          .attr(\"x\", bx - blockSize / 2).attr(\"y\", by)\n          .attr(\"width\", blockSize).attr(\"height\", blockSize)\n          .attr(\"rx\", 4)\n          .attr(\"fill\", COL.blockAlt).attr(\"stroke\", COL.blockAltStroke).attr(\"stroke-width\", 1.2);\n        g.on(\"mouseenter\", () =&gt; {\n          blocksG.selectAll(\"g\").each(function () {\n            const rect = d3.select(this).select(\"rect\");\n            const rx = +rect.attr(\"x\") + blockSize / 2;\n            if (Math.abs(rx - bx) &lt; 1) {\n              rect.attr(\"fill\", COL.block).attr(\"stroke\", COL.blockStroke);\n            }\n          });\n          showAnnotation(d);\n        });\n        g.on(\"mouseleave\", () =&gt; {\n          blocksG.selectAll(\"g\").each(function () {\n            const rect = d3.select(this).select(\"rect\");\n            rect.attr(\"fill\", COL.blockAlt).attr(\"stroke\", COL.blockAltStroke);\n          });\n          hideAnnotation();\n        });\n      }\n    });\n\n    // Ref line & pill\n    const refPx = xScale(center);\n    const refTopY = 78;\n    refLine.attr(\"x1\", refPx).attr(\"x2\", refPx).attr(\"y1\", refTopY).attr(\"y2\", beamCY + 6);\n    let refTxt = isExactlyCentral ? `a = μ = ${mean.toFixed(2)}`\n      : isExactlyRaw ? \"c = 0\"\n      : `a = ${center.toFixed(2)}`;\n    refPillTxt.text(refTxt);\n    const refTW = refTxt.length * 8 + 20;\n    refPillBg.attr(\"x\", refPx - refTW / 2).attr(\"y\", refTopY - 14).attr(\"width\", refTW).attr(\"height\", 26);\n    refPillTxt.attr(\"x\", refPx).attr(\"y\", refTopY - 1);\n\n    hideAnnotation();\n\n    // Contribution bars (n &gt;= 2)\n    contribG.selectAll(\"*\").remove();\n    if (n &gt;= 2) {\n      const contributions = dataPoints.filter(d =&gt; d.freq &gt; 0).map(d =&gt; {\n        const dist = d.x - center;\n        return { x: d.x, val: d.freq * Math.pow(dist, n) };\n      });\n      const maxAbs = Math.max(1e-9, ...contributions.map(c =&gt; Math.abs(c.val)));\n      const barMaxH = 45;\n      const barW = 18;\n      const barBaseY = beamCY + pivotH + 42;\n      const supN = [\"\", \"\\u00B9\", \"\\u00B2\", \"\\u00B3\", \"\\u2074\"][n];\n\n      contribG.append(\"line\")\n        .attr(\"x1\", xScale(xMin + 0.3)).attr(\"x2\", xScale(xMax - 0.3))\n        .attr(\"y1\", barBaseY).attr(\"y2\", barBaseY)\n        .attr(\"stroke\", \"#CFD8DC\").attr(\"stroke-width\", 1);\n\n\n      contributions.forEach(c =&gt; {\n        const bx = xScale(c.x);\n        const h = (Math.abs(c.val) / maxAbs) * barMaxH;\n        const isPos = c.val &gt;= 0;\n        const barColor = n === 3 ? (isPos ? \"#42A5F5\" : \"#EF5350\") : COL.moment;\n\n        contribG.append(\"rect\")\n          .attr(\"x\", bx - barW / 2)\n          .attr(\"y\", isPos ? barBaseY - h : barBaseY)\n          .attr(\"width\", barW).attr(\"height\", Math.max(1, h))\n          .attr(\"rx\", 3).attr(\"fill\", barColor).attr(\"opacity\", 0.75);\n\n        contribG.append(\"text\")\n          .attr(\"x\", bx).attr(\"y\", isPos ? barBaseY - h - 4 : barBaseY + h + 11)\n          .attr(\"text-anchor\", \"middle\").attr(\"font-size\", 9).attr(\"fill\", COL.sub)\n          .attr(\"font-family\", \"'SF Mono',monospace\")\n          .text(c.val.toFixed(1));\n      });\n    }\n\n    // Formula\n    const supN = [\"\", \"\\u00B9\", \"\\u00B2\", \"\\u00B3\", \"\\u2074\"][n];\n    const typeName = isExactlyCentral ? \"Moment tập trung\" : isExactlyRaw ? \"Moment gốc\" : \"Moment\";\n    const momentNames = {\n      1: { c: \"Trung bình (Mean)\", r: \"Trung bình (Mean)\" },\n      2: { c: \"Phương sai (Variance)\", r: \"\" },\n      3: { c: \"Độ lệch (Skewness)\", r: \"\" },\n      4: { c: \"Độ nhọn (Kurtosis)\", r: \"\" }\n    };\n    const mName = isExactlyCentral ? (momentNames[n]?.c || \"\") : (momentNames[n]?.r || \"\");\n\n    formulaText.html(\"\");\n    formulaText.append(\"tspan\").attr(\"fill\", COL.moment).text(`${typeName} (n=${n})`);\n    if (mName) formulaText.append(\"tspan\").attr(\"fill\", COL.sub).attr(\"font-size\", 15).text(`  —  ${mName}`);\n\n    formulaSub.html(\"\");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.moment).text(\"μ\");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.moment).attr(\"font-size\", 10).attr(\"dy\", 3).text(n);\n    formulaSub.append(\"tspan\").attr(\"dy\", -3).attr(\"fill\", COL.txt).text(\" = Σ \");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.force).text(\"fᵢ\");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.txt).text(\"·\");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.dist).text(\"(xᵢ−c)\");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.moment).attr(\"font-size\", 10).attr(\"dy\", -4).text(n);\n    formulaSub.append(\"tspan\").attr(\"dy\", 4).attr(\"fill\", COL.txt).text(\" / N\");\n    formulaSub.append(\"tspan\").attr(\"fill\", COL.moment).attr(\"font-weight\", 700).text(` = ${momentVal.toFixed(4)}`);\n  }\n\n  // ═══════════════════════════════════════════════════\n  // INIT\n  // ═══════════════════════════════════════════════════\n  update();\n  invalidation.then(() =&gt; {});\n  outer.value = {};\n  return outer;\n}\n\n\n\n\n\n\n\n2.3.1 Moment gốc bậc 1\nCho biết vị trí trọng tâm của phân phối nằm ở đâu so với điểm 0.\n\\[E[X] = \\frac{\\sum^N_{i = 1}x_i}{N} = \\sum^N_{i = 1}x_i \\mathbb{P}(x_i)\\]\n\n\n2.3.2 Moment tập trung bậc 2\nCho biết khoảng cách của từng giá trị trong phân phối so với giá trị trung bình. Phép bình phương giúp ngăn chặn các độ lệch âm và dương triệt tiêu lẫn nhau.\n\\[E[(X - E[X])^2] = E[X^2] - (E[X])^2\\]\n\n\n2.3.3 Moment tập trung bậc 3\nThường được gọi là Độ lệch (Skewness). Nó phản ánh sự không đối xứng.\n\\[E\\left[\\left(\\frac{X - E[X]}{\\sigma}\\right)^3\\right]\\]\nLũy thừa bậc 3 giữ nguyên dấu (số âm mũ 3 vẫn là âm)\n\n\n2.3.4 Moment tập trung bậc 4\nThường được gọi là Độ nhọn (Kurtosis). Tên gọi này bắt nguồn từ tiếng Hy Lạp: κυρτός - kyrtos, nghĩa là “cong, vòm”.\n\\[E\\left[\\left(\\frac{X - E[X]}{\\sigma}\\right)^4\\right]\\]\nLũy thừa bậc 4 làm cho những giá trị nhỏ (gần trung bình) trở nên siêu nhỏ, và những giá trị lớn (xa trung bình - outliers) trở nên lớn hơn nhiều lần. Moment này càng lớn thì đuôi của phân phối càng dày, nghĩa là xác suất xảy ra các sự kiện cực đoan càng lớn.\nLeptokurtic (tiền tố lepto- nghĩa là nhỏ, mảnh khảnh): độ nhọn &gt; 3.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Phân phối xác suất</span>"
    ]
  },
  {
    "objectID": "distr.html#tại-sao-lại-học-moment",
    "href": "distr.html#tại-sao-lại-học-moment",
    "title": "2  Phân phối xác suất",
    "section": "2.4 Tại sao lại học moment?",
    "text": "2.4 Tại sao lại học moment?\nDùng method of moments để xác định điểm bắt đầu của tham số ước lượng bằng MLE (Bolker 2008). Sẽ áp dụng ở bài likelihood.\nEstimate\nEstimand\nEstimator\n\n\n\n\nBolker, Benjamin M. 2008. Ecological Models and Data in R. Princeton University Press. https://doi.org/10.1515/9781400840908.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Phân phối xác suất</span>"
    ]
  },
  {
    "objectID": "distr-d.html",
    "href": "distr-d.html",
    "title": "Phân phối rời rạc",
    "section": "",
    "text": "Phép thử Bernoulli (Bernoulli trial, hay binomial trial)\nLà một lần thử nghiệm duy nhất, không gian mẫu chỉ có đúng 2 kết quả: Thành công (Success) hoặc Thất bại (Failure)\nVí dụ: tung đồng xu (mặt sấp, mặt ngửa), xét nghiệm một ca nghi ngờ (dương tính, âm tính)\nKhi ta thực hiện phép thử Bernoulli nhiều lần liên tiếp (ví dụ: tung một đồng xu nhiều lần, dùng một loại xét nghiệm để test nhiều người), ta đang thực hiện 1 chuỗi Bernoulli (Bernoulli process). Chuỗi Bernoulli chuẩn cần thỏa 2 điều kiện:\nHầu hết các phân phối rời rạc đều xuất phát từ chuỗi Bernoulli với các mục tiêu khác nhau.",
    "crumbs": [
      "Phân phối rời rạc"
    ]
  },
  {
    "objectID": "distr-d.html#phép-thử-bernoulli-bernoulli-trial-hay-binomial-trial",
    "href": "distr-d.html#phép-thử-bernoulli-bernoulli-trial-hay-binomial-trial",
    "title": "Phân phối rời rạc",
    "section": "",
    "text": "Độc lập (Independent): Kết quả của lần thử này không ảnh hưởng đến lần thử khác.\nXác suất không đổi: Xác suất thành công (\\(p\\)) phải giống hệt nhau ở mọi lần thử.",
    "crumbs": [
      "Phân phối rời rạc"
    ]
  },
  {
    "objectID": "distr-d.html#đếm-số-lần-thành-công",
    "href": "distr-d.html#đếm-số-lần-thành-công",
    "title": "Phân phối rời rạc",
    "section": "Đếm số lần thành công",
    "text": "Đếm số lần thành công\nChúng ta quyết định trước sẽ bỏ ra bao nhiêu công sức (\\(n\\) lần thử), và đếm xem thu được bao nhiêu phần thưởng (\\(k\\) thành công).\n\nPhân phối Nhị thức (Binomial distribution)\nĐếm số lần thành công (\\(k\\)) trong một số lượng cố định các phép thử Bernoulli độc lập (\\(n\\)).\nXác suất để đạt được đúng \\(k\\) lần thành công là:\n\\[\\mathbb{P}(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}\\]\nVới:\n\n\\(n\\): Tổng số lần thực hiện phép thử\n\\(p\\): Xác suất thành công của mỗi lần thử (không đổi)\n\n\n\n\n\n\n\nNoteGiải thích\n\n\n\n\\[\\underbrace{\\binom{n}{k}}_{\\text{Số cách chọn}} \\cdot \\underbrace{p^k}_{k \\text{ lần thành công}} \\cdot \\underbrace{(1-p)^{n-k}}_{n-k \\text{ lần thất bại}}\\]\n\n\n\nVí dụ\nTung 1 đồng xu 10 lần, khả năng đếm được 1, 2, 3… mặt ngửa là bao nhiêu?\n\nTổng số lần thực hiện phép thử: \\(n = 10\\)\nXác suất ra mặt ngửa mỗi lần: \\(p = 0.5\\)\n\n\nviewof coin_sim_manual = (() =&gt; {\n  // --- 1. SETUP DOM & STYLES ---\n  const container = document.createElement(\"div\");\n  // Rigid container size: 400px width, 340px height (40px controls + 300px canvas)\n  container.style.cssText = `\n    width: 400px;\n    height: 340px; \n    margin: 0 auto;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    border: 1px solid transparent;\n  `;\n\n  // Inject UI HTML directly (Total Control, Zero Shift)\n  container.innerHTML = `\n    &lt;style&gt;\n      .coin-controls-row {\n        width: 100%;\n        height: 40px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 0px;\n      }\n      .coin-btn {\n        padding: 6px 14px;\n        border-radius: 6px;\n        border: 1px solid #d1d5db;\n        background-color: white;\n        color: #374151;\n        font-size: 14px;\n        font-weight: 600;\n        cursor: pointer;\n        line-height: 1.2;\n      }\n      .coin-btn:hover { background-color: #f3f4f6; }\n      \n      .coin-btn-primary {\n        background-color: #3b82f6; \n        color: white; \n        border-color: #2563eb;\n      }\n      .coin-btn-primary:hover { background-color: #2563eb; color: white; }\n      \n      .coin-toggle {\n        display: flex; align-items: center; gap: 6px;\n        font-size: 14px; font-weight: 500; color: #4b5563;\n        cursor: pointer; user-select: none;\n      }\n      .coin-toggle input { width: 16px; height: 16px; accent-color: #10b981; cursor: pointer; }\n      \n      canvas { display: block; } /* Removes ghost margin */\n    &lt;/style&gt;\n\n    &lt;div class=\"coin-controls-row\"&gt;\n      &lt;button id=\"btn-flip\" class=\"coin-btn coin-btn-primary\"&gt;Tung đồng xu&lt;/button&gt;\n      &lt;label class=\"coin-toggle\"&gt;\n        &lt;input type=\"checkbox\" id=\"chk-auto\"&gt;\n        Tự động chạy\n      &lt;/label&gt;\n      &lt;button id=\"btn-reset\" class=\"coin-btn\"&gt;Làm lại&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n\n  // --- 2. CANVAS SETUP ---\n  const width = 400;\n  const height = 300;\n  const canvas = document.createElement(\"canvas\");\n  const dpr = window.devicePixelRatio || 1;\n  \n  canvas.width = width * dpr;\n  canvas.height = height * dpr;\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  \n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n  ctx.scale(dpr, dpr);\n  container.appendChild(canvas);\n\n  // --- 3. STATE & CONSTANTS ---\n  const N = 10;\n  const P = 0.5;\n  \n  // Colors\n  const BG_COLOR=\"#fff\", TEXT_COLOR=\"#2c3e50\";\n  const HEAD_COLOR=\"#f1c40f\", HEAD_BORDER=\"#d4ac0d\";\n  const TAIL_COLOR=\"#bdc3c7\", TAIL_BORDER=\"#95a5a6\";\n  const CHART_BAR=\"#3498db\", CHART_ACTIVE=\"#2980b9\", CHART_THEO=\"rgba(44, 62, 80, 0.1)\";\n\n  // Math Helper\n  function binomial(k, n, p) {\n    function nCr(n, r) {\n        if (r &lt; 0 || r &gt; n) return 0;\n        let res = 1;\n        for(let i=0; i&lt;r; i++) res = res * (n - i) / (i + 1);\n        return res;\n    }\n    return nCr(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  }\n\n  // Simulation State\n  const S = {\n     history: [], \n     counts: {},  \n     totalFlips: 0,\n     currentResult: [], \n     animation: 0, \n     cooldown: 0,\n     isAuto: false\n  };\n  for(let i=0; i&lt;=N; i++) S.counts[i] = 0;\n\n  // --- 4. LOGIC ---\n  function runFlip() {\n     let heads = 0;\n     const res = [];\n     for(let i=0; i&lt;N; i++) {\n        const isHead = Math.random() &lt; P;\n        res.push(isHead ? 1 : 0);\n        if (isHead) heads++;\n     }\n     \n     const coinSize = 28;\n     const gap = 6;\n     const totalW = N * coinSize + (N-1)*gap;\n     const startX = (width - totalW) / 2 + coinSize/2;\n\n     S.currentResult = res.map((val, i) =&gt; ({\n        val: val,\n        x: width/2, \n        y: 50,\n        targetX: startX + i * (coinSize + gap), \n        targetY: 85,\n        r: coinSize / 2,\n        t: 0\n     }));\n\n     S.history.push(heads);\n     S.counts[heads] = (S.counts[heads] || 0) + 1;\n     S.totalFlips++;\n     S.animation = 1;\n     S.cooldown = 0;\n  }\n\n  function reset() {\n     S.history = [];\n     for(let i=0; i&lt;=N; i++) S.counts[i] = 0;\n     S.totalFlips = 0;\n     S.currentResult = [];\n     S.animation = 0;\n  }\n\n  // --- 5. LOOP ---\n  function update() {\n     // Auto Run Logic\n     if (S.isAuto && S.animation === 0) {\n        S.cooldown++;\n        if (S.cooldown &gt; 20) runFlip(); // Speed: ~0.3s\n     }\n\n     // Animation Logic\n     if (S.animation === 1) {\n       let done = true;\n       for (let c of S.currentResult) {\n          if (c.t &lt; 1) {\n             c.t += 0.2; \n             if (c.t &gt; 1) c.t = 1;\n             const ease = 1 - Math.pow(1 - c.t, 3);\n             c.x = width/2 + (c.targetX - width/2) * ease;\n             c.y = c.targetY - Math.sin(c.t * Math.PI) * 20;\n             done = false;\n          }\n       }\n       if (done) S.animation = 0;\n    }\n  }\n\n  function draw() {\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, width, height);\n\n    ctx.save();\n    ctx.font = \"bold 14px -apple-system, BlinkMacSystemFont, sans-serif\";\n    ctx.fontVariantNumeric = \"tabular-nums\";\n    \n    // 1. Text Info\n    // Left: Count\n    ctx.textAlign = \"left\"; ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(`Lần chạy: ${S.totalFlips}`, 20, 30);\n    \n    // Center: Status\n    if (S.isAuto) {\n       ctx.textAlign = \"center\"; ctx.fillStyle = \"#27ae60\";\n       ctx.fillText(\"● Đang chạy...\", 170, 30); // Adjusted center for visual balance\n    }\n    \n    // Right: Result\n    if (S.currentResult.length &gt; 0) {\n       const hCount = S.currentResult.filter(c =&gt; c.val===1).length;\n       ctx.textAlign = \"right\"; ctx.fillStyle = \"#d35400\";\n       ctx.fillText(`Mặt Ngửa: ${hCount} / ${N}`, width - 20, 30);\n    }\n    ctx.restore();\n\n    // 2. Coins\n    for (let c of S.currentResult) {\n       ctx.beginPath();\n       ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);\n       ctx.fillStyle = c.val === 1 ? HEAD_COLOR : TAIL_COLOR;\n       ctx.fill();\n       ctx.lineWidth = 2;\n       ctx.strokeStyle = c.val === 1 ? HEAD_BORDER : TAIL_BORDER;\n       ctx.stroke();\n       ctx.fillStyle = \"white\";\n       ctx.textAlign = \"center\"; ctx.textBaseline = \"middle\";\n       ctx.font = `bold ${c.r}px sans-serif`;\n       ctx.fillText(c.val === 1 ? \"N\" : \"S\", c.x, c.y + 1);\n    }\n\n    // 3. Chart\n    const chartY = 280; \n    const chartH = 140; \n    const chartX = 40;\n    const chartW = width - 60;\n    \n    ctx.beginPath();\n    ctx.strokeStyle = \"#bdc3c7\"; ctx.lineWidth = 1;\n    ctx.moveTo(chartX, chartY); ctx.lineTo(chartX + chartW, chartY); ctx.stroke();\n\n    const barW = chartW / (N + 1);\n    const MAX_PROB = 0.246; \n    const Y_SCALE_MAX = MAX_PROB * 1.2; \n    const activeHeads = S.currentResult.filter(c =&gt; c.val===1).length;\n\n    for (let k = 0; k &lt;= N; k++) {\n       const cx = chartX + k * barW + barW/2;\n       \n       // Theoretical\n       const prob = binomial(k, N, P);\n       const theoH = (prob / Y_SCALE_MAX) * chartH;\n       ctx.fillStyle = CHART_THEO;\n       ctx.fillRect(cx - barW*0.3, chartY - theoH, barW*0.6, theoH);\n       \n       // Actual\n       let observedProb = 0;\n       if (S.totalFlips &gt; 0) observedProb = S.counts[k] / S.totalFlips;\n       let barH = (observedProb / Y_SCALE_MAX) * chartH;\n       if (barH &gt; chartH + 10) barH = chartH + 10;\n\n       const isActive = (S.animation === 0 && k === activeHeads && S.totalFlips &gt; 0);\n       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_BAR;\n       ctx.fillRect(cx - barW*0.3, chartY - barH, barW*0.6, barH);\n       \n       // Labels\n       ctx.save();\n       ctx.fontVariantNumeric = \"tabular-nums\";\n       ctx.fillStyle = TEXT_COLOR;\n       ctx.font = \"10px sans-serif\";\n       ctx.textAlign = \"center\";\n       ctx.fillText(k, cx, chartY + 15);\n       ctx.restore();\n    }\n    \n    // Y-Axis Label\n    ctx.save();\n    ctx.translate(12, chartY - chartH/2);\n    ctx.rotate(-Math.PI/2);\n    ctx.textAlign = \"center\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"#7f8c8d\";\n    ctx.fillText(\"Tần suất\", 0, 0);\n    ctx.restore();\n  }\n\n  // --- 6. BINDINGS ---\n  const btnFlip = container.querySelector(\"#btn-flip\");\n  const btnReset = container.querySelector(\"#btn-reset\");\n  const chkAuto = container.querySelector(\"#chk-auto\");\n\n  btnFlip.onclick = () =&gt; runFlip();\n  btnReset.onclick = () =&gt; reset();\n  chkAuto.onchange = (e) =&gt; { S.isAuto = e.target.checked; };\n\n  let frameId;\n  function tick() {\n    update();\n    draw();\n    frameId = requestAnimationFrame(tick);\n  }\n  tick();\n\n  if (this && this.invalidation) this.invalidation.then(() =&gt; cancelAnimationFrame(frameId));\n\n  return container;\n})();\n\n\n\n\n\n\n\n\nBảng Galton\nBảng Galton (Galton board) là một tấm bảng dựng đứng, được đóng các hàng đinh so le nhau theo hình tam giác. Ta thả những viên bi nhỏ từ đỉnh tháp. Khi một viên bi chạm vào một chiếc đinh, nó sẽ nảy sang trái hoặc sang phải. Sau khi đi hết các hàng đinh, viên bi sẽ rơi vào các ô chứa để hứng bi. Số lượng bi trong các ô chứa này tuân theo phân phối Nhị thức.\n\nviewof galton_sharp = Inputs.form({\n  rows: Inputs.range([8, 20], {value: 10, step: 1, label: \"Số hàng đinh\"}),\n  speed: Inputs.range([0.5, 3], {value: 2, step: 0.1, label: \"Tốc độ\"}),\n  total: Inputs.range([50, 800], {value: 200, step: 10, label: \"Số viên bi\"})\n})\n\nviewof galton_sim_dense = (() =&gt; {\n  // --- 1. CONFIGURATION ---\n  const config = {\n      rows: galton_sharp.rows,\n      speed: galton_sharp.speed,\n      maxBalls: galton_sharp.total\n  };\n\n  // --- 2. SETUP CONTAINER (Centered) ---\n  const outerWrapper = document.createElement(\"div\");\n  outerWrapper.style.cssText = `\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    margin-top: 20px;\n  `;\n\n  const container = document.createElement(\"div\");\n  container.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    width: 380px; \n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n  `;\n  outerWrapper.appendChild(container);\n\n  // --- 3. INJECT UI ---\n  container.innerHTML = `\n    &lt;style&gt;\n      .galton-ctrl-row {\n        width: 100%;\n        display: flex;\n        justify-content: center;\n        gap: 12px;\n        margin-bottom: 10px;\n      }\n      .galton-btn {\n        padding: 6px 16px;\n        border-radius: 6px;\n        border: 1px solid #d1d5db;\n        background-color: white;\n        color: #374151;\n        font-size: 14px;\n        font-weight: 600;\n        cursor: pointer;\n        transition: all 0.1s ease;\n      }\n      .galton-btn:hover { background-color: #f3f4f6; }\n      \n      .galton-btn-primary {\n        background-color: #3b82f6; \n        color: white; \n        border-color: #2563eb;\n      }\n      .galton-btn-primary:hover { background-color: #2563eb; color: white; }\n\n      canvas {\n        border-radius: 4px;\n      }\n    &lt;/style&gt;\n\n    &lt;div class=\"galton-ctrl-row\"&gt;\n      &lt;button id=\"btn-start\" class=\"galton-btn galton-btn-primary\"&gt;Bắt đầu&lt;/button&gt;\n      &lt;button id=\"btn-stop\" class=\"galton-btn\"&gt;Dừng&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n\n  // --- 4. CANVAS SETUP ---\n  // INCREASED HEIGHT from 500 -&gt; 600\n  const logicalWidth = 380;\n  const logicalHeight = 600; \n  const dpr = window.devicePixelRatio || 1;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = logicalWidth * dpr;\n  canvas.height = logicalHeight * dpr;\n  canvas.style.width = `${logicalWidth}px`;\n  canvas.style.height = `${logicalHeight}px`;\n  \n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n  ctx.scale(dpr, dpr);\n  container.appendChild(canvas);\n\n  // --- 5. GEOMETRY & STATE ---\n  const pegSpacing = logicalWidth / (config.rows + 3);\n  const startY = 60;\n  const pegRadius = pegSpacing * 0.12; \n  const ballRadius = pegSpacing * 0.23; \n  const rowHeight = pegSpacing * 0.85;\n\n  // Bin Geometry\n  const floorY = logicalHeight - 10;\n  const binWidth = pegSpacing;\n  const totalBinWidth = (config.rows + 1) * binWidth;\n  const binsStartX = (logicalWidth - totalBinWidth) / 2;\n  const wallsTopY = startY + (config.rows) * rowHeight + 15;\n\n  // DENSE PACKING FACTOR\n  // 70% Overlap means the vertical step is small.\n  // Normal Diameter = 2*r.\n  // We use step = 0.6 * r. This is very dense.\n  const stackStep = ballRadius * 0.6; \n\n  // Pre-calculate Peg Positions\n  const pegGrid = []; \n  for (let r = 0; r &lt; config.rows; r++) {\n    const rowPegs = [];\n    const pegsInThisRow = r + 1;\n    const rowWidth = (pegsInThisRow - 1) * pegSpacing;\n    const rowStartX = (logicalWidth - rowWidth) / 2;\n    for (let p = 0; p &lt; pegsInThisRow; p++) {\n      rowPegs.push({\n        x: rowStartX + p * pegSpacing,\n        y: startY + r * rowHeight\n      });\n    }\n    pegGrid.push(rowPegs);\n  }\n\n  // Simulation State\n  const S = {\n    balls: [],\n    bins: new Array(config.rows + 1).fill(0),\n    spawned: 0,\n    running: false\n  };\n\n  // --- 6. LOGIC ---\n  function createBall() {\n    let currentInd = 0; \n    let path = [];\n    path.push({ x: logicalWidth / 2, y: startY - 20 }); \n\n    for (let r = 0; r &lt; config.rows; r++) {\n       const peg = pegGrid[r][currentInd];\n       path.push({ x: peg.x, y: peg.y - pegRadius - ballRadius });\n       if (Math.random() &gt; 0.5) currentInd++; \n    }\n\n    const binX = binsStartX + currentInd * binWidth + binWidth/2;\n    path.push({ x: binX, y: wallsTopY });\n    path.push({ x: binX, y: floorY, isFloor: true, binIndex: currentInd });\n\n    return {\n      path: path,\n      segment: 0, t: 0, active: true,\n      x: path[0].x, y: path[0].y\n    };\n  }\n\n  function spawn() {\n     if (S.spawned &gt;= config.maxBalls) return;\n     \n     // Check capacity using new DENSE packing logic\n     // Available height = floorY - wallsTopY\n     // Height consumed = count * stackStep\n     const centerBin = Math.floor(config.rows/2);\n     const currentHeight = S.bins[centerBin] * stackStep;\n     \n     if (currentHeight &gt; (floorY - wallsTopY - 20)) return; // -20 buffer\n     \n     S.balls.push(createBall());\n     S.spawned++;\n  }\n\n  function update(dt) {\n    if (S.running) {\n        const spawnChance = 0.25 * config.speed; \n        if (Math.random() &lt; spawnChance) spawn();\n    }\n\n    for (let i = 0; i &lt; S.balls.length; i++) {\n        const b = S.balls[i];\n        if (!b.active) continue;\n        if (!S.running) continue;\n\n        const moveSpeed = 3.0 * config.speed * dt;\n        b.t += moveSpeed;\n\n        if (b.t &gt;= 1) {\n            b.t = 0;\n            b.segment++;\n            if (b.segment &gt;= b.path.length - 1) {\n                b.active = false;\n                const finalPt = b.path[b.path.length - 1];\n                S.bins[finalPt.binIndex]++;\n                continue;\n            }\n        }\n\n        const p0 = b.path[b.segment];\n        const p1 = b.path[b.segment + 1];\n        const t = b.t;\n        const ease = t * t; \n        \n        b.x = p0.x + (p1.x - p0.x) * t;\n        b.y = p0.y + (p1.y - p0.y) * (p1.isFloor ? ease : ease);\n    }\n    \n    if (S.balls.length &gt; config.maxBalls + 50) {\n        S.balls = S.balls.filter(b =&gt; b.active);\n    }\n  }\n\n  // --- 7. DRAW LOOP ---\n  function draw() {\n    // Clear\n    ctx.fillStyle = \"#f8f9fa\";\n    ctx.fillRect(0, 0, logicalWidth, logicalHeight);\n\n    // Pegs\n    ctx.fillStyle = \"#9ca3af\";\n    ctx.beginPath();\n    for (let r = 0; r &lt; pegGrid.length; r++) {\n      for (let p = 0; p &lt; pegGrid[r].length; p++) {\n         const peg = pegGrid[r][p];\n         ctx.moveTo(peg.x + pegRadius, peg.y);\n         ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI*2);\n      }\n    }\n    ctx.fill(); \n\n    // Active Balls\n    ctx.fillStyle = \"#3b82f6\";\n    ctx.beginPath();\n    for (let i = 0; i &lt; S.balls.length; i++) {\n       const b = S.balls[i];\n       if (b.active) {\n         ctx.moveTo(b.x + ballRadius, b.y);\n         ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2);\n       }\n    }\n    ctx.fill(); \n\n    // BINS (Dense Stacking)\n    ctx.fillStyle = \"#3b82f6\";\n    ctx.strokeStyle = \"#1d4ed8\"; // Darker border for definition\n    ctx.lineWidth = 1;\n    \n    for (let i = 0; i &lt; S.bins.length; i++) {\n       const count = S.bins[i];\n       if (count === 0) continue;\n       \n       const cx = binsStartX + i * binWidth + binWidth/2;\n       \n       ctx.beginPath();\n       for (let j = 0; j &lt; count; j++) {\n          // DENSE LOGIC: stackStep = 0.6 * r\n          const cy = floorY - ballRadius - (j * stackStep);\n          \n          if (cy &lt; wallsTopY) break; \n          ctx.moveTo(cx + ballRadius, cy);\n          ctx.arc(cx, cy, ballRadius, 0, Math.PI*2);\n       }\n       ctx.fill();\n       ctx.stroke();\n    }\n\n    // Walls/Floor\n    ctx.strokeStyle = \"#d1d5db\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(binsStartX, floorY);\n    ctx.lineTo(binsStartX + totalBinWidth, floorY);\n    for (let i = 0; i &lt;= config.rows + 1; i++) {\n       const x = binsStartX + i * binWidth;\n       ctx.moveTo(x, wallsTopY);\n       ctx.lineTo(x, floorY);\n    }\n    ctx.stroke();\n\n    // Text\n    ctx.fillStyle = \"#374151\";\n    ctx.font = \"bold 14px sans-serif\";\n    ctx.fillText(`Số bi: ${S.spawned} / ${config.maxBalls}`, 10, 25);\n  }\n\n  // --- 8. RUNTIME ---\n  let lastTime = performance.now();\n  let frameId;\n  \n  function tick(now) {\n    const dt = Math.min((now - lastTime) / 1000, 0.1); \n    lastTime = now;\n    \n    update(dt);\n    draw();\n    frameId = requestAnimationFrame(tick);\n  }\n\n  // Bind Buttons\n  const btnStart = container.querySelector(\"#btn-start\");\n  const btnStop = container.querySelector(\"#btn-stop\");\n\n  btnStart.onclick = () =&gt; {\n     if (!S.running && S.spawned === 0) {\n         S.running = true;\n     } else {\n         S.running = true;\n         if (S.spawned &gt;= config.maxBalls) {\n             S.balls = [];\n             S.bins.fill(0);\n             S.spawned = 0;\n         }\n     }\n  };\n  \n  btnStop.onclick = () =&gt; {\n      S.running = false;\n  };\n\n  tick(performance.now());\n  invalidation.then(() =&gt; cancelAnimationFrame(frameId));\n\n  return outerWrapper;\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTại sao lại là phân phối Nhị thức?\n\nMỗi lần viên bi chạm vào chiếc đinh, có hai trường hợp xảy ra: viên bi sẽ nảy sang trái hoặc sang phải, xác suất nảy sang mỗi bên là \\(p = 0.5\\), giống như tung đồng xu. Đây là một phép thử Bernoulli.\nNếu bảng có 10 hàng đinh, viên bi sẽ thực hiện chuỗi Bernoulli có 10 phép thử liên tiếp.\nCác ô chứa tương ứng với số lần viên bi nảy về bên phải. Để vào ô giữa, viên bi phải nảy sang bên phải 5 lần (và bên trái 5 lần), để vào ô cuối cùng, viên bi phải nảy sang bên phải 10 lần (và bên trái 0 lần).\n\n\n\nHồi quy logistic\n\nglm(formula, data, family = binomial(link = \"logit\"))\nglm(formula, data, family = \"binomial\")\n\nTại sao trong hồi quy logistic lại ghi family = \"binomial\"?\nVí dụ: Hút thuốc lá có làm tăng nguy cơ ung thư phổi không?\n\nBiến độc lập: Số điếu thuốc hút mỗi ngày\nBiến phụ thuộc: Tình trạng ung thư phổi (1 = Có bệnh, 0 = Không bệnh)\n\nKhi xây dựng mô hình, chúng ta xem xét từng cá nhân trong dữ liệu như một phép thử ngẫu nhiên:\n\nVới một người cụ thể (ví dụ: anh A, hút 1 gói/ngày), việc anh ta có bị ung thư hay không giống như việc tung một đồng xu: mặt ngửa (1) là bị ung thư, mặt sấp (0) là không bị ung thư. Nhưng xác suất tung ra mặt ngửa của đồng xu này không phải là 0.5, mà phụ thuộc vào việc anh ta hút bao nhiêu thuốc.\nKhi chúng ta tiến hành nghiên cứu trên \\(n\\) người, đây là 1 chuỗi Bernoulli, vì vậy có thể chọn phân phối Binomial để mô hình nó.\n\nKhai báo family = \"binomial\" nghĩa là: “Biến kết quả (\\(Y\\)) là đếm số lần thành công (hoặc thất bại) từ các phép thử nhị phân, hãy dùng công thức xác suất của phân phối Nhị thức để ước lượng.”\n\n\nXấp xỉ phân phối Chuẩn\nĐịnh lý Moivre-Laplace (một dạng đặc biệt của Định lý Giới hạn Trung tâm): Khi số lượng phép thử \\(n\\) đủ lớn, hình dáng của phân phối Nhị thức sẽ tiệm cận về phân phối Chuẩn.\n\nviewof normal_approx_fixed_axis = (() =&gt; {\n  // --- 1. SETUP CONTAINER ---\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    margin-top: 20px;\n    width: 100%;\n    min-height: 500px;\n  `;\n\n  // --- 2. INPUT CREATION ---\n  function createInput(id, label, min, max, step, val) {\n    const container = document.createElement(\"div\");\n    container.style.cssText = \"display: flex; flex-direction: column; width: 220px;\";\n    \n    const labelEl = document.createElement(\"label\");\n    labelEl.htmlFor = id;\n    labelEl.style.cssText = \"font-size: 14px; font-weight: 600; color: #374151; margin-bottom: 6px;\";\n    labelEl.innerHTML = `${label} &lt;span style=\"color: #be185d;\"&gt;${val}&lt;/span&gt;`;\n    \n    const input = document.createElement(\"input\");\n    input.type = \"range\";\n    input.id = id;\n    input.min = min;\n    input.max = max;\n    input.step = step;\n    input.value = val;\n    input.style.width = \"100%\";\n    input.style.accentColor = \"#be185d\"; \n    \n    container.appendChild(labelEl);\n    container.appendChild(input);\n    return { container, input, labelEl };\n  }\n\n  const nCtrl = createInput(\"n_val_fx\", \"Số phép thử (n):\", 10, 500, 10, 50);\n  const pCtrl = createInput(\"p_val_fx\", \"Xác suất (p):\", 0.05, 0.95, 0.05, 0.5);\n\n  const controlsDiv = document.createElement(\"div\");\n  controlsDiv.style.cssText = \"display: flex; flex-wrap: wrap; gap: 30px; justify-content: center; margin-bottom: 20px; width: 100%;\";\n  controlsDiv.appendChild(nCtrl.container);\n  controlsDiv.appendChild(pCtrl.container);\n  wrapper.appendChild(controlsDiv);\n\n  // Stats Display\n  const statsDiv = document.createElement(\"div\");\n  statsDiv.style.cssText = \"font-size: 16px; color: #374151; margin-bottom: 10px; font-weight: 500; font-family: monospace;\";\n  wrapper.appendChild(statsDiv);\n  \n  // Plot Container\n  const plotContainer = document.createElement(\"div\");\n  wrapper.appendChild(plotContainer);\n\n  // --- 3. MATH KERNEL ---\n  function logFact(n) {\n    if (n &lt;= 1) return 0;\n    return n * Math.log(n) - n + 0.5 * Math.log(2 * Math.PI * n);\n  }\n\n  function getBinomialProb(k, n, p) {\n    if (k &lt; 0 || k &gt; n) return 0;\n    if (p &lt;= 0) return k === 0 ? 1 : 0;\n    if (p &gt;= 1) return k === n ? 1 : 0;\n    \n    const logP = logFact(n) - logFact(k) - logFact(n - k) + k * Math.log(p) + (n - k) * Math.log(1 - p);\n    return Math.exp(logP);\n  }\n\n  function normalPDF(x, mu, sigma) {\n    if (sigma &lt;= 0) return 0;\n    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));\n  }\n\n  // --- 4. RENDER LOGIC ---\n  function update() {\n    const n = parseFloat(nCtrl.input.value);\n    const p = parseFloat(pCtrl.input.value);\n\n    // Update Text\n    nCtrl.labelEl.querySelector(\"span\").textContent = n;\n    pCtrl.labelEl.querySelector(\"span\").textContent = p.toFixed(2);\n\n    const mu = n * p;\n    const sigma = Math.sqrt(n * p * (1 - p));\n\n    // Stats\n    statsDiv.innerHTML = `&mu; = &lt;b&gt;${mu.toFixed(2)}&lt;/b&gt; &nbsp;|&nbsp; &sigma; = &lt;b&gt;${sigma.toFixed(2)}&lt;/b&gt;`;\n\n    // CALCULATION WINDOW: We still optimize calculation to +/- 4 sigma\n    // to keep performance high, even though visual axis is 0-n.\n    let startK = Math.floor(mu - 4 * sigma);\n    let endK = Math.ceil(mu + 4 * sigma);\n    if (startK &lt; 0) startK = 0;\n    if (endK &gt; n) endK = n;\n\n    // 1. Generate Binomial Data\n    const binomData = [];\n    for (let k = startK; k &lt;= endK; k++) {\n      binomData.push({ \n          k: k, \n          x1: k - 0.5, \n          x2: k + 0.5,\n          prob: getBinomialProb(k, n, p) \n      });\n    }\n\n    // 2. Generate Normal Data\n    const normalData = [];\n    const step = (endK - startK) / 100;\n    const safeStep = step &gt; 0.1 ? step : 0.1;\n    \n    for (let x = startK; x &lt;= endK; x += safeStep) {\n      normalData.push({ x: x, y: normalPDF(x, mu, sigma) });\n    }\n\n    // 3. Plot\n    const chart = Plot.plot({\n      width: 600,\n      height: 380,\n      marginTop: 30,\n      marginLeft: 40,\n      marginBottom: 30,\n      x: { \n        label: \"Số lần thành công (k)\",\n        // FIX: Hard-code domain to full range [0, n] to prevent jumping\n        domain: [0, n]\n      },\n      y: { \n        label: \"Xác suất\", \n        grid: true \n      },\n      marks: [\n        // Binomial\n        Plot.rectY(binomData, {\n          x1: \"x1\", \n          x2: \"x2\", \n          y: \"prob\", \n          fill: \"#3b82f6\", \n          fillOpacity: 0.5,\n          title: d =&gt; `k: ${d.k}\\nP: ${d.prob.toFixed(4)}`\n        }),\n        \n        // Normal Curve\n        Plot.line(normalData, {\n          x: \"x\", \n          y: \"y\", \n          stroke: \"#be185d\", \n          strokeWidth: 3\n        }),\n        \n        // Mean Line\n        Plot.ruleX([mu], {\n          stroke: \"#374151\", \n          strokeDasharray: \"4,4\", \n          strokeOpacity: 0.6\n        })\n      ]\n    });\n\n    plotContainer.innerHTML = \"\";\n    plotContainer.appendChild(chart);\n  }\n\n  nCtrl.input.addEventListener(\"input\", update);\n  pCtrl.input.addEventListener(\"input\", update);\n  \n  update();\n\n  return wrapper;\n})();\n\n\n\n\n\n\n\n\n\nPhân phối Siêu bội (Hypergeometric distribution)\nNếu phân phối Nhị thức là việc tung đồng xu, thì Phân phối Siêu bội giống như việc chia bài.\nTình huống: Bạn có bộ bài 52 lá, trong đó có 4 lá Át. Bạn rút 10 lá và hỏi “Tôi rút được bao nhiêu lá Át?”.\nLuật chơi:\n\nSố lần thử cố định (\\(n\\))\nCác lần thử phụ thuộc nhau\nLấy mẫu không hoàn lại từ một quần thể hữu hạn (\\(N\\))\n\nKhi bạn rút được một lá Át ra khỏi bộ bài và giữ nó lại, xác suất rút được lá Át tiếp theo sẽ thay đổi (vì trong bộ bài giờ đây thiếu mất 1 lá Át và tổng số lá cũng giảm đi 1). Đây là đặc trưng của việc lấy mẫu không hoàn lại.\nPhân phối Siêu bội mô tả xác suất lấy được đúng \\(k\\) phần tử thành công trong \\(n\\) lần lấy mẫu từ một quần thể hữu hạn gồm \\(N\\) phần tử, mà không có sự thay thế (không hoàn lại).\n\\[\\mathbb{P}(X=k) = \\frac{\\binom{K}{k} \\binom{N-K}{n-k}}{\\binom{N}{n}}\\]\n\n\\(N\\): Tổng kích thước quần thể (Ví dụ: 52 lá bài)\n\\(n\\): Kích thước mẫu lấy ra (Ví dụ: Rút 5 lá trên tay)\n\\(K\\): Tổng số phần tử thành công có trong quần thể (Ví dụ: 4 lá Át)\n\\(k\\): Số lượng thành công mong muốn trong mẫu (Ví dụ: Muốn có đúng 2 lá Át)\n\\(N-K\\): Số lượng phần tử thất bại trong quần thể (Ví dụ: 48 lá bài còn lại)\n\\(n-k\\): Số lượng thất bại phải lấy trong mẫu (Ví dụ: 3 lá còn lại trong tay phải là lá thường).\n\n\n\n\n\n\n\nNoteGiải thích\n\n\n\n\\[\\frac{ \\overbrace{\\binom{K}{k}}^{\\text{Chọn } k \\text{ thành công}} \\cdot \\overbrace{\\binom{N-K}{n-k}}^{\\text{Chọn } n-k \\text{ thất bại}} }{ \\underbrace{\\binom{N}{n}}_{\\text{Tổng số cách chọn ra } n \\text{ mẫu}} }\\]\n\n\n\nviewof ace_sim_manual = (() =&gt; {\n  // --- 1. SETUP DOM & STYLES ---\n  const container = document.createElement(\"div\");\n  container.style.cssText = `\n    width: 400px;\n    height: 440px; \n    margin: 0 auto;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    border: 1px solid transparent; /* Prevents margin collapse */\n  `;\n\n  // Inject UI HTML directly (Total Control)\n  container.innerHTML = `\n    &lt;style&gt;\n      .ace-controls-row {\n        width: 100%;\n        height: 40px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 5px;\n      }\n      .ace-btn {\n        padding: 6px 14px;\n        border-radius: 6px;\n        border: 1px solid #d1d5db;\n        background-color: white;\n        color: #374151;\n        font-size: 14px;\n        font-weight: 600;\n        cursor: pointer;\n        line-height: 1.2;\n      }\n      .ace-btn:hover { background-color: #f3f4f6; }\n      .ace-btn-primary {\n        background-color: #3b82f6; \n        color: white; \n        border-color: #2563eb;\n      }\n      .ace-btn-primary:hover { background-color: #2563eb; color: white; }\n      \n      .ace-toggle {\n        display: flex; align-items: center; gap: 6px;\n        font-size: 14px; font-weight: 500; color: #4b5563;\n        cursor: pointer; user-select: none;\n      }\n      .ace-toggle input { width: 16px; height: 16px; accent-color: #10b981; cursor: pointer; }\n      \n      canvas { display: block; } /* Removes ghost margin */\n    &lt;/style&gt;\n\n    &lt;div class=\"ace-controls-row\"&gt;\n      &lt;button id=\"btn-draw\" class=\"ace-btn ace-btn-primary\"&gt;Rút 10 lá&lt;/button&gt;\n      &lt;label class=\"ace-toggle\"&gt;\n        &lt;input type=\"checkbox\" id=\"chk-auto\"&gt;\n        Tự động chạy\n      &lt;/label&gt;\n      &lt;button id=\"btn-reset\" class=\"ace-btn\"&gt;Làm lại&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n\n  // --- 2. CANVAS SETUP ---\n  const width = 400;\n  const height = 380;\n  const canvas = document.createElement(\"canvas\");\n  const dpr = window.devicePixelRatio || 1;\n  \n  canvas.width = width * dpr;\n  canvas.height = height * dpr;\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  \n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n  ctx.scale(dpr, dpr);\n  container.appendChild(canvas);\n\n  // --- 3. STATE & CONSTANTS ---\n  const SUITS = [\"♠\", \"♥\", \"♣\", \"♦\"];\n  const RANKS = [\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"];\n  const CARD_W = 30, CARD_H = 45;\n  \n  // Layout Constants\n  const Y_HEADER = 45;\n  const Y_CARDS = 85;\n  const Y_CHART_BASE = 320;\n  const CHART_H = 60;\n  \n  // Colors\n  const BG_COLOR=\"#fff\", TEXT_COLOR=\"#333333\", ACE_COLOR=\"#d35400\", ACE_BG=\"#fffbe6\";\n  const CARD_BG=\"#ffffff\", CARD_BORDER=\"#cccccc\", RED=\"#e74c3c\", BLACK=\"#2c3e50\";\n  const CHART_THEO=\"rgba(44, 62, 80, 0.1)\", CHART_ACT=\"#009688\", CHART_ACTIVE=\"#00796b\";\n  const DECK_BACK=\"#c0392b\";\n\n  function hypergeom(k, N, K, n) {\n     function nCr(n, r) {\n        if (r &lt; 0 || r &gt; n) return 0;\n        let res = 1;\n        for(let i=0; i&lt;r; i++) res = res * (n - i) / (i + 1);\n        return res;\n     }\n     return (nCr(K, k) * nCr(N - K, n - k)) / nCr(N, n);\n  }\n  const THEORETICAL = [];\n  for(let k=0; k&lt;=4; k++) THEORETICAL[k] = hypergeom(k, 52, 4, 10);\n\n  const S = {\n     counts: [0, 0, 0, 0, 0], \n     totalDeals: 0,\n     lastHand: [],\n     animation: 0, \n     cooldown: 0,\n     isAuto: false\n  };\n\n  // --- 4. LOGIC ---\n  function runDeal() {\n    let deck = [];\n    for(let s of SUITS) {\n      for(let r of RANKS) deck.push({ rank: r, suit: s, isAce: r === \"A\" });\n    }\n    for(let i=deck.length-1; i&gt;0; i--) {\n       const j = Math.floor(Math.random() * (i+1));\n       [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n    \n    const hand = deck.slice(0, 10);\n    const aceCount = hand.filter(c =&gt; c.isAce).length;\n    S.counts[aceCount]++;\n    S.totalDeals++;\n    \n    // Animation targets\n    const startX = (width - (5 * (CARD_W + 8))) / 2 + 4;\n    S.lastHand = hand.map((c, i) =&gt; {\n       const row = Math.floor(i / 5);\n       const col = i % 5;\n       return {\n         ...c,\n         x: 30, y: 30,\n         targetX: startX + col * (CARD_W + 8),\n         targetY: Y_CARDS + row * (CARD_H + 12),\n         t: 0\n       };\n    });\n    S.animation = 1;\n    S.cooldown = 0; \n  }\n\n  function reset() {\n     S.counts = [0,0,0,0,0];\n     S.totalDeals = 0;\n     S.lastHand = [];\n     S.animation = 0;\n  }\n\n  // --- 5. LOOP ---\n  function update() {\n     if (S.isAuto && S.animation === 0) {\n        S.cooldown++;\n        if (S.cooldown &gt; 40) runDeal();\n     }\n\n     if (S.animation === 1) {\n       let done = true;\n       for (let c of S.lastHand) {\n          if (c.t &lt; 1) {\n             c.t += 0.1; \n             if (c.t &gt; 1) c.t = 1;\n             const ease = 1 - Math.pow(1 - c.t, 3);\n             c.x = 30 + (c.targetX - 30) * ease;\n             c.y = 30 + (c.targetY - 30) * ease;\n             done = false;\n          }\n       }\n       if (done) S.animation = 0;\n    }\n  }\n\n  function draw() {\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, width, height);\n    \n    ctx.save();\n    ctx.font = \"bold 14px -apple-system, BlinkMacSystemFont, sans-serif\";\n    ctx.fontVariantNumeric = \"tabular-nums\";\n\n    // Header\n    ctx.textAlign = \"left\"; ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(`Lần rút: ${S.totalDeals}`, 75, Y_HEADER); \n    \n    if (S.isAuto) {\n        ctx.textAlign = \"center\"; ctx.fillStyle = CHART_ACT;\n        ctx.fillText(\"● Đang chạy...\", width/2, Y_HEADER);\n    }\n\n    if (S.lastHand.length &gt; 0) {\n       const aces = S.lastHand.filter(c=&gt;c.isAce).length;\n       ctx.textAlign = \"right\"; ctx.fillStyle = ACE_COLOR;\n       ctx.fillText(`Kết quả: ${aces} lá Át`, width - 30, Y_HEADER); \n    }\n    ctx.restore();\n\n    // Deck\n    for(let i=0; i&lt;3; i++) {\n      ctx.fillStyle = \"white\"; ctx.strokeStyle = \"#ccc\";\n      ctx.fillRect(30-i*2, 30-i*2, CARD_W, CARD_H);\n      ctx.strokeRect(30-i*2, 30-i*2, CARD_W, CARD_H);\n    }\n    ctx.fillStyle = DECK_BACK; ctx.fillRect(30, 30, CARD_W, CARD_H);\n    ctx.strokeStyle = \"white\"; ctx.lineWidth = 2; ctx.strokeRect(34, 34, CARD_W-8, CARD_H-8);\n    ctx.lineWidth = 1;\n\n    // Hand\n    for (let c of S.lastHand) {\n        ctx.fillStyle = c.isAce ? ACE_BG : CARD_BG;\n        ctx.fillRect(c.x, c.y, CARD_W, CARD_H);\n        \n        ctx.strokeStyle = c.isAce ? ACE_COLOR : CARD_BORDER;\n        ctx.strokeRect(c.x, c.y, CARD_W, CARD_H);\n\n        const isRed = (c.suit === \"♥\" || c.suit === \"♦\");\n        ctx.fillStyle = c.isAce ? ACE_COLOR : (isRed ? RED : BLACK);\n        ctx.textAlign = \"left\"; ctx.textBaseline = \"top\";\n        ctx.font = \"bold 14px sans-serif\";\n        ctx.fillText(c.rank, c.x + 3, c.y + 4);\n        ctx.font = \"16px sans-serif\";\n        ctx.fillText(c.suit, c.x + 3, c.y + 20);\n    }\n\n    // Chart\n    const chartX = 50, barW = 40, gap = 25;\n    \n    ctx.beginPath(); ctx.strokeStyle = \"#bdc3c7\"; ctx.lineWidth = 1;\n    ctx.moveTo(chartX - 10, Y_CHART_BASE); ctx.lineTo(width - 20, Y_CHART_BASE); ctx.stroke();\n    \n    ctx.save();\n    ctx.fillStyle = TEXT_COLOR; ctx.font = \"12px sans-serif\"; ctx.textAlign = \"center\";\n    ctx.fillText(\"Số lá Át rút được (k)\", width/2 + 15, Y_CHART_BASE + 35);\n    \n    ctx.translate(20, Y_CHART_BASE - CHART_H/2);\n    ctx.rotate(-Math.PI/2);\n    ctx.fillStyle = \"#7f8c8d\";\n    ctx.fillText(\"Tần suất\", 0, 0);\n    ctx.restore();\n\n    const activeAces = S.lastHand.filter(c=&gt;c.isAce).length;\n\n    for (let k = 0; k &lt;= 4; k++) {\n       const x = chartX + k * (barW + gap);\n       const Y_SCALE = 0.5;\n       \n       const theoH = (THEORETICAL[k] / Y_SCALE) * CHART_H;\n       ctx.fillStyle = CHART_THEO;\n       ctx.fillRect(x, Y_CHART_BASE - theoH, barW, theoH);\n       \n       let count = S.counts[k];\n       let pct = S.totalDeals &gt; 0 ? count / S.totalDeals : 0;\n       let barH = (pct / Y_SCALE) * CHART_H;\n       if (barH &gt; CHART_H + 10) barH = CHART_H + 10;\n       \n       const isActive = (S.animation === 0 && S.totalDeals &gt; 0 && k === activeAces);\n       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_ACT;\n       ctx.fillRect(x, Y_CHART_BASE - barH, barW, barH);\n       \n       ctx.save();\n       ctx.fontVariantNumeric = \"tabular-nums\";\n       ctx.fillStyle = TEXT_COLOR; ctx.font = \"12px sans-serif\"; ctx.textAlign = \"center\";\n       ctx.fillText(k, x + barW/2, Y_CHART_BASE + 15);\n       ctx.restore();\n    }\n  }\n\n  // --- 6. BINDINGS ---\n  const btnDraw = container.querySelector(\"#btn-draw\");\n  const btnReset = container.querySelector(\"#btn-reset\");\n  const chkAuto = container.querySelector(\"#chk-auto\");\n\n  btnDraw.onclick = () =&gt; runDeal();\n  btnReset.onclick = () =&gt; reset();\n  chkAuto.onchange = (e) =&gt; { S.isAuto = e.target.checked; };\n\n  let frameId;\n  function tick() {\n    update();\n    draw();\n    frameId = requestAnimationFrame(tick);\n  }\n  tick();\n\n  // Clean up\n  if (this && this.invalidation) this.invalidation.then(() =&gt; cancelAnimationFrame(frameId));\n\n  return container;\n})();",
    "crumbs": [
      "Phân phối rời rạc"
    ]
  },
  {
    "objectID": "distr-d.html#đếm-số-lần-thử",
    "href": "distr-d.html#đếm-số-lần-thử",
    "title": "Phân phối rời rạc",
    "section": "Đếm số lần thử",
    "text": "Đếm số lần thử\nChúng ta quyết định trước phần thưởng mình muốn đạt được (\\(k\\) thành công), và đếm xem phải tốn bao nhiêu công sức (\\(n\\) lần thử) để đạt được nó. Nhánh này mô hình hóa sự “kiên trì” hoặc “sức chịu đựng”.\n\nPhân phối hình học (geometric distribution)\nTình huống: Một gia đình phong kiến trọng nam khinh nữ muốn có một đứa con trai, họ cứ sinh con cho đến khi có con trai thì thôi\nCâu hỏi: Họ phải sinh bao nhiêu con cho đến khi có con trai?\nĐặc tính: Không có bộ nhớ (Memoryless). Dù đã sinh 10 con gái liên tiếp, xác suất đứa tiếp theo là trai vẫn y như lúc bắt đầu.\n\n\nPhân phối Nhị thức âm (negative binomial distribution)\nTình huống: Gia đình phong kiến đã sinh được con trai nhưng vẫn muốn có con trai nữa, thầy bói nói nhà phải có 3 đứa con trai mới giàu được\nCâu hỏi: Họ sẽ sinh bao nhiêu con trước khi có được đứa con trai thứ 3?\nVề lý thuyết, đây là tổng của \\(k\\) biến thuộc phân phối hình học.\nTrong sinh học thực tế (ví dụ: đếm số ký sinh trùng, ấu trùng muỗi), phương sai thường lớn hơn trung bình rất nhiều (do hiện tượng tụ đám/clumping). Phân phối Nhị thức Âm khớp với kiểu dữ liệu này tốt hơn nhiều so với Poisson hay Nhị thức.",
    "crumbs": [
      "Phân phối rời rạc"
    ]
  },
  {
    "objectID": "distr-d.html#đếm-sự-kiện-khi-biết-tốc-độ-trung-bình",
    "href": "distr-d.html#đếm-sự-kiện-khi-biết-tốc-độ-trung-bình",
    "title": "Phân phối rời rạc",
    "section": "Đếm sự kiện khi biết tốc độ trung bình",
    "text": "Đếm sự kiện khi biết tốc độ trung bình\n\nPhân phối Poisson\nKhác với những phân phối kể trên, phân phối Poisson không dựa trên chuỗi Bernoulli, mà dựa trên quá trình Poisson (Poisson process).\nQuá trình Poisson là 1 cơ chế xảy ra biến cố với các điều kiện:\n\nCác biến cố xảy ra độc lập nhau (independent): biến cố này xảy ra không ảnh hưởng đến xác suất xảy ra của biến cố tiếp theo\nCác biến cố xảy ra với 1 tốc độ trung bình không đổi: Số lượng sự kiện trung bình trên một đơn vị thời gian là hằng số (ví dụ: trung bình có 5 chiếc xe chạy trên con đường này mỗi giờ)\nCác biến cố không xảy ra cùng 1 lúc\n\nPhân phối Poisson dùng để đếm số lượng biến cố ngẫu nhiên xảy ra trong 1 khoảng thời gian cố định (với điều kiện \\(\\lambda\\) không thay đổi trong khoảng thời gian này) của quá trình Poisson.\n\\[P(X=k) = \\frac{e^{-\\lambda} \\lambda^k}{k!}\\]\nTrong đó:\n\n\\(\\lambda\\): Tốc độ trung bình (kỳ vọng) số sự kiện trong khoảng thời gian đó.\n\\(k\\): Số sự kiện muốn tính xác suất.\n\n\n\nVí dụ\nTại một phòng cấp cứu, trung bình cứ 1 giờ lại có 3 bệnh nhân đến khám (\\(\\lambda = 3\\)). Xác suất để trong 1 giờ tới có chính xác 5 ca đến khám là bao nhiêu?\nÁp dụng công thức với \\(\\lambda = 3\\) và \\(k = 5\\):\n\\[P(X=5) = \\frac{e^{-3} \\cdot 3^5}{5!} = \\frac{0.0498 \\times 243}{120} \\approx 0.1008 \\quad (\\approx 10\\%)\\]\nPoisson là giới hạn của Nhị thức khi \\(n \\to \\infty\\) và xác suất thành công \\(p \\to 0\\), sao cho \\(np = \\lambda\\)\nHãy tưởng tượng bạn đang ngồi đợi tin nhắn điện thoại trong 1 giờ. Dựa vào kinh nghiệm, trung bình bạn nhận được \\(\\lambda = 5\\) tin nhắn/giờ. Xác suất trong 1 giờ tới bạn chỉ nhận được 2 tin nhắn là bao nhiêu?\n\nBạn chia 1 giờ thành 60 phút. Mỗi phút là một phép thử Bernoulli (có tin nhắn/không tin nhắn). Bạn có \\(n = 60\\) phép thử liên tiếp.\nBạn chia nhỏ thời gian ra nữa. Lúc này số phép thử \\(n\\) trở nên vô cùng lớn, và xác suất có tin nhắn trong một khoảnh khắc siêu nhỏ (\\(p\\)) trở nên vô cùng nhỏ. Càng chia nhỏ, bạn sẽ thấy phân phối nhị thức càng gần với Poisson.\n\n\nviewof poisson_visual_final = (() =&gt; {\n  // --- 1. CONFIGURATION ---\n  const lambda = 5; \n  \n  // Input Slider (Width 400px to match binning bar)\n  const form = Inputs.range([10, 360], {\n    value: 10, \n    step: 5, \n    label: \"Chia 1 giờ thành n khoảng (n)\"\n  });\n  \n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    margin-top: 20px;\n  `;\n  \n  // --- 2. TIME BIN VISUALIZATION (Canvas) ---\n  const timeCanvas = document.createElement(\"canvas\");\n  const timeW = 400; // REDUCED WIDTH\n  const timeH = 50;\n  const dpr = window.devicePixelRatio || 1;\n  \n  timeCanvas.width = timeW * dpr;\n  timeCanvas.height = timeH * dpr;\n  timeCanvas.style.width = `${timeW}px`;\n  timeCanvas.style.height = `${timeH}px`;\n  timeCanvas.style.marginTop = \"10px\"; \n  timeCanvas.style.marginBottom = \"5px\";\n  \n  const tCtx = timeCanvas.getContext(\"2d\");\n  tCtx.scale(dpr, dpr);\n\n  // --- 3. STATS DISPLAY ---\n  const statsDiv = document.createElement(\"div\");\n  statsDiv.style.cssText = `\n    margin-bottom: 5px; \n    font-size: 16px; \n    color: #333;\n    font-weight: 500;\n  `;\n  \n  // --- 4. APPEND ELEMENTS (Order: Input -&gt; Binning -&gt; Stats -&gt; Plot) ---\n  wrapper.appendChild(form);       \n  wrapper.appendChild(timeCanvas); \n  wrapper.appendChild(statsDiv);   \n  const plotContainer = document.createElement(\"div\");\n  wrapper.appendChild(plotContainer); \n\n  // --- 5. MATH HELPERS ---\n  function getBinomialData(n, p) {\n    const data = [];\n    let prob = Math.pow(1 - p, n); \n    for (let k = 0; k &lt;= 16; k++) {\n      data.push({k, type: \"Binomial\", prob});\n      if (k &lt; n) {\n        prob = prob * ((n - k) / (k + 1)) * (p / (1 - p));\n      } else {\n        prob = 0;\n      }\n    }\n    return data;\n  }\n\n  const poissonData = [];\n  {\n    let prob = Math.exp(-lambda); \n    for (let k = 0; k &lt;= 16; k++) {\n      poissonData.push({k, type: \"Poisson\", prob});\n      prob = prob * lambda / (k + 1);\n    }\n  }\n\n  // --- 6. RENDER LOOPS ---\n  function drawTimeBins(n) {\n    tCtx.clearRect(0, 0, timeW, timeH);\n    \n    const barX = 0; // Start at 0 since canvas is now exact width\n    const barY = 15;\n    const barW = timeW;\n    const barH = 20;\n    \n    // Background\n    tCtx.fillStyle = \"#f3f4f6\";\n    tCtx.fillRect(barX, barY, barW, barH);\n    tCtx.strokeStyle = \"#9ca3af\";\n    tCtx.lineWidth = 1;\n    tCtx.strokeRect(barX, barY, barW, barH);\n    \n    // Draw Dividers\n    tCtx.beginPath();\n    tCtx.strokeStyle = n &gt; 150 ? \"rgba(107, 114, 128, 0.5)\" : \"#6b7280\";\n    tCtx.lineWidth = n &gt; 200 ? 0.5 : 1; \n\n    const binSize = barW / n;\n    \n    // Draw internal lines\n    for (let i = 1; i &lt; n; i++) {\n        const x = Math.floor(barX + i * binSize) + 0.5;\n        tCtx.moveTo(x, barY);\n        tCtx.lineTo(x, barY + barH);\n    }\n    tCtx.stroke();\n    \n    // Labels\n    tCtx.fillStyle = \"#374151\";\n    tCtx.font = \"bold 12px sans-serif\";\n    \n    tCtx.textAlign = \"left\"; \n    tCtx.fillText(\"0\", barX, barY + barH + 14);\n    \n    tCtx.textAlign = \"right\"; \n    tCtx.fillText(\"1h\", barX + barW, barY + barH + 14);\n    \n    // Center Label (Changed Text)\n    tCtx.textAlign = \"center\"; \n    tCtx.fillStyle = \"#3b82f6\";\n    tCtx.fillText(`${n} phép thử liên tiếp`, timeW / 2, barY - 5);\n  }\n\n  function update() {\n    const n = form.value;\n    const p = lambda / n; \n    \n    // Update Stats\n    statsDiv.innerHTML = `n = ${n} &nbsp;|&nbsp; p = ${p.toFixed(4)} &nbsp;|&nbsp; np = ${(n*p).toFixed(1)}`;\n\n    // Update Top Canvas\n    drawTimeBins(n);\n\n    // Update Plot\n    const binomData = getBinomialData(n, p);\n    const combinedData = poissonData.concat(binomData);\n    const xDomain = Array.from({length: 17}, (_, i) =&gt; i);\n\n    const chart = Plot.plot({\n      width: 600,\n      height: 320,\n      marginTop: 20,\n      x: { \n        type: \"band\", \n        domain: xDomain, \n        label: \"Số tin nhắn (k)\",\n        padding: 0.1\n      },\n      y: { label: \"Xác suất\", domain: [0, 0.2] },\n      marks: [\n        // Binomial Bars\n        Plot.barY(combinedData.filter(d =&gt; d.type === \"Binomial\"), {\n          x: \"k\", \n          y: \"prob\", \n          fill: \"#3b82f6\", \n          fillOpacity: 0.6,\n          title: d =&gt; `Binomial: ${d.prob.toFixed(4)}`\n        }),\n        // Poisson Line\n        Plot.line(combinedData.filter(d =&gt; d.type === \"Poisson\"), {\n          x: \"k\", \n          y: \"prob\", \n          stroke: \"#be185d\", \n          strokeWidth: 3,\n          curve: \"monotone-x\"\n        }),\n        // Poisson Dots\n        Plot.dot(combinedData.filter(d =&gt; d.type === \"Poisson\"), {\n          x: \"k\", \n          y: \"prob\", \n          fill: \"#be185d\",\n          r: 4\n        }),\n        Plot.ruleY([0])\n      ]\n    });\n\n    plotContainer.innerHTML = \"\";\n    plotContainer.appendChild(chart);\n  }\n\n  form.addEventListener(\"input\", update);\n  update();\n\n  return wrapper;\n})();",
    "crumbs": [
      "Phân phối rời rạc"
    ]
  },
  {
    "objectID": "distr-d.html#ứng-dụng",
    "href": "distr-d.html#ứng-dụng",
    "title": "Phân phối rời rạc",
    "section": "Ứng dụng",
    "text": "Ứng dụng\nDữ liệu dạng đếm (ví dụ: số ca bệnh trong 1 tuần):\n\nPoisson\nNegative binomial\n\nDữ liệu là tỉ lệ:\nCác phân phối phức tạp có thể được tạo ra bằng cách cộng các phân phối đơn giản:\n\n\n\n\n\n\n\n\nNếu cộng\nSẽ có\nĐiều kiện\n\n\n\n\nNhiều Bernoulli\nNhị thức\nCùng \\(p\\).\n\n\nNhiều Nhị thức\nNhị thức\n\\(X+Y \\sim \\text{Bin}(n+m, p)\\)\n\n\nNhiều Hình học\nNhị thức âm\nChờ \\(k\\) thành công thực chất là chờ 1 thành công, lặp lại \\(k\\) lần\n\n\nNhiều Nhị thức âm\nNhị thức âm\n\\(X+Y \\sim \\text{NB}(r_1+r_2, p)\\)\n\n\nNhiều Poisson\nPoisson\n\\(X+Y \\sim \\text{Pois}(\\lambda_1 + \\lambda_2)\\)",
    "crumbs": [
      "Phân phối rời rạc"
    ]
  },
  {
    "objectID": "distr-bin.html",
    "href": "distr-bin.html",
    "title": "3  Phân phối nhị thức",
    "section": "",
    "text": "3.1 Ứng dụng",
    "crumbs": [
      "Phân phối rời rạc",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Phân phối nhị thức</span>"
    ]
  },
  {
    "objectID": "distr-bin.html#ứng-dụng",
    "href": "distr-bin.html#ứng-dụng",
    "title": "3  Phân phối nhị thức",
    "section": "",
    "text": "3.1.1 Khoảng tin cậy của tỉ lệ\n\nviewof binomial_ci = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. MATH\n  // ══════════════════════════════════════════════════════\n  const lcCache = new Map();\n  function lc(n,k){\n    if(k&lt;0||k&gt;n)return-Infinity;if(k&gt;n-k)k=n-k;\n    const key=(n&lt;&lt;12)|k;if(lcCache.has(key))return lcCache.get(key);\n    let r=0;for(let i=0;i&lt;k;i++)r+=Math.log(n-i)-Math.log(i+1);\n    lcCache.set(key,r);return r;\n  }\n  function pmf(x,n,p){\n    if(x&lt;0||x&gt;n)return 0;if(p&lt;=0)return x===0?1:0;if(p&gt;=1)return x===n?1:0;\n    return Math.exp(lc(n,x)+x*Math.log(p)+(n-x)*Math.log(1-p));\n  }\n  function rTail(k,n,p){let s=0;for(let x=k;x&lt;=n;x++)s+=pmf(x,n,p);return s;}\n  function lTail(k,n,p){let s=0;for(let x=0;x&lt;=k;x++)s+=pmf(x,n,p);return s;}\n\n  // ══════════════════════════════════════════════════════\n  // 2. DOM\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:900px;margin:0 auto;\n  `;\n\n  // ── Global thumb style ──\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    .ci-slider { position:relative; height:8px; border-radius:4px; background:#e2e8f0; }\n    .ci-slider-fill { position:absolute;left:0;top:0;height:100%;border-radius:4px;transition:width 0.04s; }\n    .ci-slider input[type=range] {\n      position:absolute;top:0;left:0;width:100%;height:100%;\n      -webkit-appearance:none;appearance:none;background:transparent;\n      cursor:pointer;margin:0;padding:0;\n    }\n    .ci-slider input[type=range]::-webkit-slider-thumb {\n      -webkit-appearance:none;appearance:none;\n      width:20px;height:20px;border-radius:50%;\n      border:3px solid #fff;box-shadow:0 1px 5px rgba(0,0,0,0.3);\n      cursor:pointer;margin-top:-6px;\n    }\n    .ci-slider input[type=range]::-moz-range-thumb {\n      width:14px;height:14px;border-radius:50%;\n      border:3px solid #fff;box-shadow:0 1px 5px rgba(0,0,0,0.3);\n      cursor:pointer;\n    }\n    .ci-slider input[type=range]::-webkit-slider-runnable-track{height:8px;background:transparent;}\n    .ci-slider input[type=range]::-moz-range-track{height:8px;background:transparent;}\n    .ci-slider-dark input[type=range]::-webkit-slider-thumb{background:#1e293b;}\n    .ci-slider-dark input[type=range]::-moz-range-thumb{background:#1e293b;}\n    .ci-slider-gray input[type=range]::-webkit-slider-thumb{background:#475569;}\n    .ci-slider-gray input[type=range]::-moz-range-thumb{background:#475569;}\n    .ci-slider-red input[type=range]::-webkit-slider-thumb{background:#dc2626;}\n    .ci-slider-red input[type=range]::-moz-range-thumb{background:#dc2626;}\n    .ci-slider-teal input[type=range]::-webkit-slider-thumb{background:#0891b2;}\n    .ci-slider-teal input[type=range]::-moz-range-thumb{background:#0891b2;}\n  `;\n  wrapper.appendChild(style);\n\n  // ── Slider factory ──\n  function createSlider(label, min, max, step, val, color, trackColor, cls) {\n    const row = document.createElement(\"div\");\n    row.style.cssText = \"display:flex;flex-direction:column;flex:1;min-width:180px;\";\n\n    const head = document.createElement(\"div\");\n    head.style.cssText = \"display:flex;justify-content:space-between;align-items:baseline;margin-bottom:5px;\";\n\n    const lbl = document.createElement(\"span\");\n    lbl.style.cssText = \"font-size:12px;font-weight:600;color:#64748b;letter-spacing:0.3px;text-transform:uppercase;\";\n    lbl.textContent = label;\n\n    const valSpan = document.createElement(\"span\");\n    valSpan.style.cssText = `font-size:18px;font-weight:800;color:${color};font-variant-numeric:tabular-nums;font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;`;\n    valSpan.textContent = step &lt; 1 ? Number(val).toFixed(3) : val;\n\n    head.appendChild(lbl); head.appendChild(valSpan);\n\n    const track = document.createElement(\"div\");\n    track.className = \"ci-slider ci-slider-\" + cls;\n\n    const fill = document.createElement(\"div\");\n    fill.className = \"ci-slider-fill\";\n    fill.style.background = trackColor;\n    fill.style.width = ((val - min) / (max - min)) * 100 + \"%\";\n    track.appendChild(fill);\n\n    const input = document.createElement(\"input\");\n    input.type = \"range\"; input.min = min; input.max = max;\n    input.step = step; input.value = val;\n    track.appendChild(input);\n\n    row.appendChild(head); row.appendChild(track);\n\n    return { el: row, input, valSpan, fill,\n      update(v, lo, hi) {\n        valSpan.textContent = step &lt; 1 ? Number(v).toFixed(3) : String(v);\n        if (lo != null) input.min = lo;\n        if (hi != null) input.max = hi;\n        const pct = ((v - Number(input.min)) / (Number(input.max) - Number(input.min))) * 100;\n        fill.style.width = Math.max(0, Math.min(100, pct)) + \"%\";\n      }\n    };\n  }\n\n  const S = {};\n  S.k  = createSlider(\"Số lần thành công (k)\", 0, 200, 1, 31, \"#1e293b\", \"#1e293b\", \"dark\");\n  S.n  = createSlider(\"Số phép thử (n)\", 10, 200, 1, 50, \"#475569\", \"#475569\", \"gray\");\n  S.pL = createSlider(\"Giới hạn dưới\", 0.001, 0.999, 0.001, 0.3, \"#dc2626\", \"#dc2626\", \"red\");\n  S.pH = createSlider(\"Giới hạn trên\", 0.001, 0.999, 0.001, 0.8, \"#0891b2\", \"#0891b2\", \"teal\");\n\n  const row1 = document.createElement(\"div\");\n  row1.style.cssText = \"display:flex;gap:32px;width:100%;padding:0 0 14px;margin-bottom:14px;border-bottom:1px solid #e2e8f0;\";\n  row1.appendChild(S.k.el); row1.appendChild(S.n.el);\n  wrapper.appendChild(row1);\n\n  const row2 = document.createElement(\"div\");\n  row2.style.cssText = \"display:flex;gap:32px;width:100%;margin-bottom:6px;\";\n  row2.appendChild(S.pL.el); row2.appendChild(S.pH.el);\n  wrapper.appendChild(row2);\n\n  // ── Tail readouts ──\n  const readout = document.createElement(\"div\");\n  readout.style.cssText = \"display:flex;gap:14px;width:100%;margin:10px 0 14px;flex-wrap:wrap;\";\n  function makeBox(bg, border) {\n    const b = document.createElement(\"div\");\n    b.style.cssText = `flex:1;min-width:260px;padding:10px 14px;border-radius:8px;background:${bg};border:1px solid ${border};font-size:13px;line-height:1.6;color:#334155;font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;`;\n    return b;\n  }\n  const boxL = makeBox(\"#fef2f2\",\"#fecaca\");\n  const boxR = makeBox(\"#ecfeff\",\"#a5f3fc\");\n  readout.appendChild(boxL); readout.appendChild(boxR);\n  wrapper.appendChild(readout);\n\n  // ══════════════════════════════════════════════════════\n  // 3. SVG (pre-allocated pools)\n  // ══════════════════════════════════════════════════════\n  const NS=\"http://www.w3.org/2000/svg\";\n  const W=760,H=400,mg={t:26,r:20,b:48,l:56},cw=W-mg.l-mg.r,ch=H-mg.t-mg.b;\n\n  const svg=document.createElementNS(NS,\"svg\");\n  svg.setAttribute(\"viewBox\",`0 0 ${W} ${H}`);\n  svg.style.cssText=`width:100%;max-width:${W}px;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;`;\n\n  function el(tag,a){const e=document.createElementNS(NS,tag);if(a)for(const[k,v]of Object.entries(a))e.setAttribute(k,v);return e;}\n\n  // Grid\n  const gridLines=[];\n  for(let i=0;i&lt;=4;i++){const l=el(\"line\",{stroke:\"#e2e8f0\",\"stroke-width\":\"0.7\"});svg.appendChild(l);gridLines.push(l);}\n\n  // Y labels\n  const yLabels=[];\n  for(let i=0;i&lt;=4;i++){const t=el(\"text\",{\"text-anchor\":\"end\",fill:\"#94a3b8\",\"font-size\":\"10\",\"font-family\":\"'SF Mono',monospace\"});svg.appendChild(t);yLabels.push(t);}\n\n  // Bar pools\n  const POOL=201;\n  const barsR=[],barsL=[];\n  for(let i=0;i&lt;POOL;i++){\n    const r=el(\"rect\",{rx:\"1\"});r.style.display=\"none\";svg.appendChild(r);barsR.push(r);\n    const l=el(\"rect\",{rx:\"1\"});l.style.display=\"none\";svg.appendChild(l);barsL.push(l);\n  }\n\n  // Paths\n  const path1=el(\"path\",{fill:\"none\",\"stroke-width\":\"2.2\",opacity:\"0.9\"});\n  const path2=el(\"path\",{fill:\"none\",\"stroke-width\":\"2\",\"stroke-dasharray\":\"4,3\",opacity:\"0.55\"});\n  const path3=el(\"path\",{fill:\"none\",\"stroke-width\":\"2.2\",opacity:\"0.9\"});\n  svg.appendChild(path1);svg.appendChild(path2);svg.appendChild(path3);\n\n  // k line\n  const kLine=el(\"line\",{stroke:\"#1e293b\",\"stroke-width\":\"1.3\",\"stroke-dasharray\":\"6,4\",opacity:\"0.5\"});\n  const kLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#1e293b\",\"font-size\":\"12\",\"font-weight\":\"700\",\"font-family\":\"'SF Mono',monospace\"});\n  svg.appendChild(kLine);svg.appendChild(kLbl);\n\n  // X axis\n  const xAx=el(\"line\",{stroke:\"#94a3b8\"});svg.appendChild(xAx);\n  const xTicks=[];\n  for(let i=0;i&lt;30;i++){\n    const ln=el(\"line\",{stroke:\"#94a3b8\",y2:\"5\"});ln.style.display=\"none\";svg.appendChild(ln);\n    const t=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#64748b\",\"font-size\":\"11\",\"font-family\":\"'SF Mono',monospace\",dy:\"16\"});t.style.display=\"none\";svg.appendChild(t);\n    xTicks.push({ln,t});\n  }\n  const xLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#64748b\",\"font-size\":\"12\",y:String(H-4)});\n  xLbl.textContent=\"Số lần thành công\";svg.appendChild(xLbl);\n\n  // Y axis\n  svg.appendChild(el(\"line\",{x1:String(mg.l),x2:String(mg.l),y1:String(mg.t),y2:String(mg.t+ch),stroke:\"#94a3b8\"}));\n  const yLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#64748b\",\"font-size\":\"12\",x:\"14\",y:String(mg.t+ch/2),transform:`rotate(-90,14,${mg.t+ch/2})`});\n  yLbl.textContent=\"P(X = x)\";svg.appendChild(yLbl);\n\n  // Annotations\n  const annR=el(\"text\",{fill:\"#dc2626\",\"font-size\":\"12\",\"font-weight\":\"700\",\"font-family\":\"'SF Mono',monospace\"});\n  const annRs=el(\"text\",{fill:\"#dc2626\",\"font-size\":\"10\",opacity:\"0.6\",\"font-family\":\"'SF Mono',monospace\"});\n  const annL=el(\"text\",{fill:\"#0891b2\",\"font-size\":\"12\",\"font-weight\":\"700\",\"font-family\":\"'SF Mono',monospace\"});\n  const annLs=el(\"text\",{fill:\"#0891b2\",\"font-size\":\"10\",opacity:\"0.6\",\"font-family\":\"'SF Mono',monospace\"});\n  svg.appendChild(annR);svg.appendChild(annRs);svg.appendChild(annL);svg.appendChild(annLs);\n\n  wrapper.appendChild(svg);\n\n  // ══════════════════════════════════════════════════════\n  // 4. RENDER\n  // ══════════════════════════════════════════════════════\n  let rafId=0;\n  const C1=\"#dc2626\",C2=\"#94a3b8\",C3=\"#0891b2\";\n\n  function render(){\n    const nV=+S.n.input.value;\n    const kV=Math.min(+S.k.input.value,nV);\n    const pLV=+S.pL.input.value;\n    const pHV=+S.pH.input.value;\n    const pH=nV&gt;0?kV/nV:0;\n\n    S.k.update(kV,0,nV);\n    S.n.update(nV);\n    S.pL.update(pLV,0.001,Math.min(pH,0.998));\n    S.pH.update(pHV,Math.max(pH,0.002),0.999);\n\n    const ps=[pLV,pH,pHV].filter(p=&gt;p&gt;0&&p&lt;1);\n    let loX=kV,hiX=kV;\n    for(const p of ps){const mu=nV*p,sd=Math.sqrt(nV*p*(1-p));loX=Math.min(loX,mu-3.8*sd);hiX=Math.max(hiX,mu+3.8*sd);}\n    loX=Math.max(0,Math.floor(loX));hiX=Math.min(nV,Math.ceil(hiX));\n    const cnt=hiX-loX+1;\n\n    let maxY=0;\n    const y1=new Float64Array(cnt),y2=new Float64Array(cnt),y3=new Float64Array(cnt);\n    for(let i=0;i&lt;cnt;i++){\n      const x=loX+i;\n      y1[i]=pmf(x,nV,pLV);y2[i]=pmf(x,nV,pH);y3[i]=pmf(x,nV,pHV);\n      const m=Math.max(y1[i],y2[i],y3[i]);if(m&gt;maxY)maxY=m;\n    }\n    maxY*=1.15;if(maxY&lt;1e-9)maxY=0.01;\n\n    const sx=x=&gt;mg.l+((x-loX)/(hiX-loX))*cw;\n    const sy=y=&gt;mg.t+ch-(y/maxY)*ch;\n    const bw=Math.max(1.5,cw/cnt*0.5);\n    const base=sy(0);\n\n    for(let i=0;i&lt;=4;i++){\n      const v=(maxY/4)*i,yy=sy(v);\n      gridLines[i].setAttribute(\"x1\",mg.l);gridLines[i].setAttribute(\"x2\",W-mg.r);\n      gridLines[i].setAttribute(\"y1\",yy);gridLines[i].setAttribute(\"y2\",yy);\n      yLabels[i].setAttribute(\"x\",mg.l-8);yLabels[i].setAttribute(\"y\",yy+4);\n      yLabels[i].textContent=v.toFixed(3);\n    }\n\n    let bi=0;\n    for(let i=0;i&lt;cnt;i++){const x=loX+i;if(x&gt;=kV&&bi&lt;POOL){\n      const b=barsR[bi++];const h=Math.max(0,base-sy(y1[i]));\n      b.setAttribute(\"x\",sx(x)-bw/2);b.setAttribute(\"y\",sy(y1[i]));\n      b.setAttribute(\"width\",bw);b.setAttribute(\"height\",h);\n      b.setAttribute(\"fill\",\"rgba(220,38,38,0.18)\");b.setAttribute(\"stroke\",C1);b.setAttribute(\"stroke-width\",\"0.6\");\n      b.style.display=\"\";\n    }}\n    for(;bi&lt;POOL;bi++)barsR[bi].style.display=\"none\";\n\n    bi=0;\n    for(let i=0;i&lt;cnt;i++){const x=loX+i;if(x&lt;=kV&&bi&lt;POOL){\n      const b=barsL[bi++];const h=Math.max(0,base-sy(y3[i]));\n      b.setAttribute(\"x\",sx(x)-bw/2);b.setAttribute(\"y\",sy(y3[i]));\n      b.setAttribute(\"width\",bw);b.setAttribute(\"height\",h);\n      b.setAttribute(\"fill\",\"rgba(8,145,178,0.15)\");b.setAttribute(\"stroke\",C3);b.setAttribute(\"stroke-width\",\"0.6\");\n      b.style.display=\"\";\n    }}\n    for(;bi&lt;POOL;bi++)barsL[bi].style.display=\"none\";\n\n    let d1=\"\",d2=\"\",d3=\"\";\n    for(let i=0;i&lt;cnt;i++){\n      const x=loX+i,cmd=i?\"L\":\"M\",px=sx(x).toFixed(1);\n      d1+=cmd+px+\",\"+sy(y1[i]).toFixed(1);\n      d2+=cmd+px+\",\"+sy(y2[i]).toFixed(1);\n      d3+=cmd+px+\",\"+sy(y3[i]).toFixed(1);\n    }\n    path1.setAttribute(\"d\",d1);path1.setAttribute(\"stroke\",C1);\n    path2.setAttribute(\"d\",d2);path2.setAttribute(\"stroke\",C2);\n    path3.setAttribute(\"d\",d3);path3.setAttribute(\"stroke\",C3);\n\n    const kx=sx(kV);\n    kLine.setAttribute(\"x1\",kx);kLine.setAttribute(\"x2\",kx);\n    kLine.setAttribute(\"y1\",mg.t);kLine.setAttribute(\"y2\",base);\n    kLbl.setAttribute(\"x\",kx);kLbl.setAttribute(\"y\",mg.t-8);kLbl.textContent=\"k = \"+kV;\n\n    xAx.setAttribute(\"x1\",mg.l);xAx.setAttribute(\"x2\",W-mg.r);\n    xAx.setAttribute(\"y1\",base);xAx.setAttribute(\"y2\",base);\n    xLbl.setAttribute(\"x\",mg.l+cw/2);\n\n    const span=hiX-loX;\n    const ts=span&gt;80?10:span&gt;40?5:span&gt;20?2:1;\n    let ti=0;\n    for(let x=Math.ceil(loX/ts)*ts;x&lt;=hiX&&ti&lt;30;x+=ts){\n      const xx=sx(x);\n      xTicks[ti].ln.setAttribute(\"x1\",xx);xTicks[ti].ln.setAttribute(\"x2\",xx);\n      xTicks[ti].ln.setAttribute(\"y1\",base);xTicks[ti].ln.setAttribute(\"y2\",base+5);\n      xTicks[ti].ln.style.display=\"\";\n      xTicks[ti].t.setAttribute(\"x\",xx);xTicks[ti].t.setAttribute(\"y\",base+5);\n      xTicks[ti].t.textContent=x;xTicks[ti].t.style.display=\"\";\n      ti++;\n    }\n    for(;ti&lt;30;ti++){xTicks[ti].ln.style.display=\"none\";xTicks[ti].t.style.display=\"none\";}\n\n    const rt=rTail(kV,nV,pLV);\n    const lt=lTail(kV,nV,pHV);\n    const rtOk=Math.abs(rt-0.025)&lt;0.003;\n    const ltOk=Math.abs(lt-0.025)&lt;0.003;\n\n    const ok=\"\\u2713 \\u2248 2.5%\",no=\"\\u2190 cần \\u2248 2.5%\";\n    boxL.innerHTML='&lt;b style=\"color:'+C1+'\"&gt;Giới hạn dưới&lt;/b&gt;&lt;br&gt;'+\n      \"P(X \\u2265 \"+kV+\" | p=\"+pLV.toFixed(3)+\") = \"+\n      '&lt;b style=\"color:'+(rtOk?\"#16a34a\":\"#d97706\")+'\"&gt;'+(rt*100).toFixed(2)+\"%&lt;/b&gt; \"+\n      '&lt;span style=\"color:'+(rtOk?\"#16a34a\":\"#d97706\")+'\"&gt;'+(rtOk?ok:no)+\"&lt;/span&gt;\";\n\n    boxR.innerHTML='&lt;b style=\"color:'+C3+'\"&gt;Giới hạn trên&lt;/b&gt;&lt;br&gt;'+\n      \"P(X \\u2264 \"+kV+\" | p=\"+pHV.toFixed(3)+\") = \"+\n      '&lt;b style=\"color:'+(ltOk?\"#16a34a\":\"#d97706\")+'\"&gt;'+(lt*100).toFixed(2)+\"%&lt;/b&gt; \"+\n      '&lt;span style=\"color:'+(ltOk?\"#16a34a\":\"#d97706\")+'\"&gt;'+(ltOk?ok:no)+\"&lt;/span&gt;\";\n\n    wrapper.value={n:nV,k:kV,pL:pLV,pH:pHV,pHat:pH,rt,lt};\n    wrapper.dispatchEvent(new Event(\"input\",{bubbles:true}));\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 5. EVENTS\n  // ══════════════════════════════════════════════════════\n  function schedule(){cancelAnimationFrame(rafId);rafId=requestAnimationFrame(render);}\n  for(const s of Object.values(S))s.input.addEventListener(\"input\",schedule);\n  render();\n\n  wrapper.dispose=()=&gt;{\n    cancelAnimationFrame(rafId);\n    for(const s of Object.values(S))s.input.removeEventListener(\"input\",schedule);\n    lcCache.clear();\n  };\n\n  return wrapper;\n})()\n\n\n\n\n\n\n\nbinom.test(31, 50)\n\n\n    Exact binomial test\n\ndata:  31 and 50\nnumber of successes = 31, number of trials = 50, p-value = 0.1189\nalternative hypothesis: true probability of success is not equal to 0.5\n95 percent confidence interval:\n 0.4717492 0.7534989\nsample estimates:\nprobability of success \n                  0.62 \n\n\n\\(\\mathbb{P}(X \\ge x | p_L) = 0.025\\)\n\\(\\mathbb{P}(X \\le x | p_U) = 0.025\\)",
    "crumbs": [
      "Phân phối rời rạc",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Phân phối nhị thức</span>"
    ]
  },
  {
    "objectID": "distr-pois.html",
    "href": "distr-pois.html",
    "title": "4  Phân phối Poisson",
    "section": "",
    "text": "import { createSlider, createButton, injectStyle } from \"./_slider.js\"\n\n\n\n\n\n\n\nviewof binom_poisson = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. MATH\n  // ══════════════════════════════════════════════════════\n  const lcCache=new Map();\n  function lc(n,k){\n    if(k&lt;0||k&gt;n)return -Infinity;if(k&gt;n-k)k=n-k;\n    const key=(n&lt;&lt;16)|k;if(lcCache.has(key))return lcCache.get(key);\n    let r=0;for(let i=0;i&lt;k;i++)r+=Math.log(n-i)-Math.log(i+1);\n    lcCache.set(key,r);return r;\n  }\n  function binPMF(x,n,p){\n    if(x&lt;0||x&gt;n)return 0;if(p&lt;=0)return x===0?1:0;if(p&gt;=1)return x===n?1:0;\n    return Math.exp(lc(n,x)+x*Math.log(p)+(n-x)*Math.log(1-p));\n  }\n  function poisPMF(k,lam){\n    if(k&lt;0||lam&lt;=0)return k===0?1:0;\n    let logP=-lam;for(let i=1;i&lt;=k;i++)logP+=Math.log(lam)-Math.log(i);\n    return Math.exp(logP);\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER + STYLE\n  // ══════════════════════════════════════════════════════\n  const wrapper=document.createElement(\"div\");\n  wrapper.style.cssText=`\n    display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:900px;margin:0 auto;\n  `;\n  \n  // Load slider\n  wrapper.appendChild(injectStyle());\n\n  const SL={};\n  SL.lam=createSlider(\"\\u03BB (messages/hour)\",0.5,8,0.5,3,\"#7c3aed\",\"purple\");\n  SL.n=createSlider(\"n (time slices)\",2,200,1,5,\"#3b82f6\",\"blue\");\n\n  const ctrlRow=document.createElement(\"div\");\n  ctrlRow.style.cssText=\"display:flex;gap:28px;width:100%;margin-bottom:14px;padding-bottom:14px;border-bottom:1px solid #e2e8f0;\";\n  ctrlRow.appendChild(SL.lam.el);ctrlRow.appendChild(SL.n.el);\n  wrapper.appendChild(ctrlRow);\n\n  // Info box\n  const infoBox=document.createElement(\"div\");\n  infoBox.style.cssText=`\n    width:100%;padding:10px 16px;border-radius:8px;margin-bottom:14px;\n    background:#faf5ff;border:1px solid #e9d5ff;\n    font-size:14px;color:#4c1d95;line-height:1.6;\n    font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;\n  `;\n  wrapper.appendChild(infoBox);\n\n  // ══════════════════════════════════════════════════════\n  // 4. TIMELINE SVG\n  // ══════════════════════════════════════════════════════\n  const NS=\"http://www.w3.org/2000/svg\";\n\n  const TW=760,TH=100;\n  const tmg={l:50,r:20,t:14,b:32};\n  const tcw=TW-tmg.l-tmg.r;\n\n  const tSvg=document.createElementNS(NS,\"svg\");\n  tSvg.setAttribute(\"viewBox\",`0 0 ${TW} ${TH}`);\n  tSvg.style.cssText=`width:100%;max-width:${TW}px;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;margin-bottom:14px;`;\n\n  function el(tag,a){const e=document.createElementNS(NS,tag);if(a)for(const[k,v]of Object.entries(a))e.setAttribute(k,v);return e;}\n\n  // Slot pool\n  const TPOOL=200;\n  const tSlots=[];\n  for(let i=0;i&lt;TPOOL;i++){\n    const r=el(\"rect\",{y:String(tmg.t),rx:\"1\"});\n    r.style.display=\"none\";tSvg.appendChild(r);tSlots.push(r);\n  }\n\n  // Axis\n  const tAxisLine=el(\"line\",{stroke:\"#94a3b8\",\"stroke-width\":\"1\"});\n  tSvg.appendChild(tAxisLine);\n  const tLabelStart=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#475569\",\"font-size\":\"13\",\"font-weight\":\"600\",\"font-family\":\"'SF Mono',monospace\"});\n  tLabelStart.textContent=\"0\";\n  const tLabelEnd=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#475569\",\"font-size\":\"13\",\"font-weight\":\"600\",\"font-family\":\"'SF Mono',monospace\"});\n  tLabelEnd.textContent=\"1 hour\";\n  tSvg.appendChild(tLabelStart);tSvg.appendChild(tLabelEnd);\n\n  // Tick labels\n  const tTickPool=[];\n  for(let i=0;i&lt;20;i++){\n    const t=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#94a3b8\",\"font-size\":\"11\",\"font-family\":\"'SF Mono',monospace\"});\n    t.style.display=\"none\";tSvg.appendChild(t);tTickPool.push(t);\n  }\n\n  // Message icons\n  const msgPool=[];\n  for(let i=0;i&lt;30;i++){\n    const t=el(\"text\",{\"text-anchor\":\"middle\",\"font-size\":\"16\",fill:\"#7c3aed\"});\n    t.textContent=\"\\uD83D\\uDCAC\";t.style.display=\"none\";tSvg.appendChild(t);msgPool.push(t);\n  }\n\n  wrapper.appendChild(tSvg);\n\n  // ══════════════════════════════════════════════════════\n  // 5. DISTRIBUTION CHART SVG\n  // ══════════════════════════════════════════════════════\n  const CW=760,CH=340;\n  const cmg={t:24,r:20,b:52,l:60};\n  const ccw=CW-cmg.l-cmg.r,cch=CH-cmg.t-cmg.b;\n\n  const cSvg=document.createElementNS(NS,\"svg\");\n  cSvg.setAttribute(\"viewBox\",`0 0 ${CW} ${CH}`);\n  cSvg.style.cssText=`width:100%;max-width:${CW}px;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;`;\n\n  // Grid\n  const gridLines=[];\n  for(let i=0;i&lt;=4;i++){const l=el(\"line\",{stroke:\"#e2e8f0\",\"stroke-width\":\"0.7\"});cSvg.appendChild(l);gridLines.push(l);}\n  const yLabels=[];\n  for(let i=0;i&lt;=4;i++){const t=el(\"text\",{\"text-anchor\":\"end\",fill:\"#94a3b8\",\"font-size\":\"12\",\"font-family\":\"'SF Mono',monospace\"});cSvg.appendChild(t);yLabels.push(t);}\n\n  // Binomial bars\n  const BPOOL=30;\n  const bBars=[];\n  for(let i=0;i&lt;BPOOL;i++){\n    const r=el(\"rect\",{rx:\"2\",fill:\"#3b82f6\",opacity:\"0.55\",stroke:\"#2563eb\",\"stroke-width\":\"0.5\"});\n    r.style.display=\"none\";cSvg.appendChild(r);bBars.push(r);\n  }\n\n  // Poisson line + dots\n  const pPath=el(\"path\",{fill:\"none\",stroke:\"#7c3aed\",\"stroke-width\":\"2.5\",opacity:\"0.9\"});\n  cSvg.appendChild(pPath);\n  const pDots=[];\n  for(let i=0;i&lt;BPOOL;i++){\n    const c=el(\"circle\",{r:\"5\",fill:\"#7c3aed\",stroke:\"#fff\",\"stroke-width\":\"1.5\"});\n    c.style.display=\"none\";cSvg.appendChild(c);pDots.push(c);\n  }\n\n  // Axes\n  const xAx=el(\"line\",{stroke:\"#94a3b8\"});cSvg.appendChild(xAx);\n  const xTickPool=[];\n  for(let i=0;i&lt;20;i++){\n    const ln=el(\"line\",{stroke:\"#94a3b8\",y2:\"5\"});ln.style.display=\"none\";cSvg.appendChild(ln);\n    const t=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#475569\",\"font-size\":\"13\",\"font-family\":\"'SF Mono',monospace\",dy:\"18\"});t.style.display=\"none\";cSvg.appendChild(t);\n    xTickPool.push({ln,t});\n  }\n  cSvg.appendChild(el(\"line\",{x1:String(cmg.l),x2:String(cmg.l),y1:String(cmg.t),y2:String(cmg.t+cch),stroke:\"#94a3b8\"}));\n  const xLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#475569\",\"font-size\":\"14\",y:String(CH-6)});\n  xLbl.textContent=\"Number of messages (k)\";cSvg.appendChild(xLbl);\n  const yLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#475569\",\"font-size\":\"14\",x:\"16\",y:String(cmg.t+cch/2),transform:`rotate(-90,16,${cmg.t+cch/2})`});\n  yLbl.textContent=\"P(X = k)\";cSvg.appendChild(yLbl);\n\n  // Legend\n  const legR=el(\"rect\",{x:String(CW-200),y:\"10\",width:\"16\",height:\"12\",rx:\"2\",fill:\"#3b82f6\",opacity:\"0.55\"});\n  const legT1=el(\"text\",{x:String(CW-178),y:\"21\",fill:\"#475569\",\"font-size\":\"13\",\"font-weight\":\"600\"});legT1.textContent=\"Binomial\";\n  const legC=el(\"circle\",{cx:String(CW-192),cy:\"36\",r:\"5\",fill:\"#7c3aed\"});\n  const legL=el(\"line\",{x1:String(CW-200),x2:String(CW-184),y1:\"36\",y2:\"36\",stroke:\"#7c3aed\",\"stroke-width\":\"2.5\"});\n  const legT2=el(\"text\",{x:String(CW-178),y:\"40\",fill:\"#475569\",\"font-size\":\"13\",\"font-weight\":\"600\"});legT2.textContent=\"Poisson\";\n  cSvg.appendChild(legR);cSvg.appendChild(legT1);cSvg.appendChild(legL);cSvg.appendChild(legC);cSvg.appendChild(legT2);\n\n  wrapper.appendChild(cSvg);\n\n  // ══════════════════════════════════════════════════════\n  // 6. SEEDED RNG\n  // ══════════════════════════════════════════════════════\n  let rngState=42;\n  function seedRng(s){rngState=s;}\n  function rng(){rngState=(rngState*16807)%2147483647;return(rngState-1)/2147483646;}\n\n  // ══════════════════════════════════════════════════════\n  // 7. RENDER\n  // ══════════════════════════════════════════════════════\n  function render(){\n    const lam=SL.lam.val();\n    const n=SL.n.val();\n    const p=Math.min(lam/n,1);\n\n    // Info\n    infoBox.innerHTML=\n      `Divide &lt;b&gt;1 hour&lt;/b&gt; into &lt;b style=\"color:#3b82f6\"&gt;n = ${n}&lt;/b&gt; intervals. `+\n      `Each has &lt;b&gt;p = \\u03BB/n = ${lam.toFixed(1)}/${n} = ${p.toFixed(4)}&lt;/b&gt; chance of a message.&lt;br&gt;`+\n      `&lt;b style=\"color:#3b82f6\"&gt;Binom(${n}, ${p.toFixed(4)})&lt;/b&gt; approximates `+\n      `&lt;b style=\"color:#7c3aed\"&gt;Poisson(\\u03BB = ${lam.toFixed(1)})&lt;/b&gt;.`;\n\n    // ── Timeline ──\n    seedRng(12345);\n    const slotW=tcw/n;\n    const barH=40;\n    const axisY=tmg.t+barH+8;\n    let mi=0;\n\n    for(let i=0;i&lt;TPOOL;i++){\n      if(i&lt;n){\n        const isMsg=rng()&lt;p;\n        const x=tmg.l+i*slotW;\n        tSlots[i].setAttribute(\"x\",x);\n        tSlots[i].setAttribute(\"y\",tmg.t);\n        tSlots[i].setAttribute(\"width\",Math.max(0.5,slotW-Math.min(1.5,slotW*0.1)));\n        tSlots[i].setAttribute(\"height\",barH);\n        tSlots[i].setAttribute(\"fill\",isMsg?\"#7c3aed\":\"#e2e8f0\");\n        tSlots[i].setAttribute(\"opacity\",isMsg?\"0.8\":\"0.5\");\n        tSlots[i].style.display=\"\";\n        if(isMsg&&mi&lt;30){\n          msgPool[mi].setAttribute(\"x\",x+slotW/2);\n          msgPool[mi].setAttribute(\"y\",tmg.t-1);\n          msgPool[mi].style.display=slotW&gt;8?\"\":\"none\";\n          mi++;\n        }\n      }else{tSlots[i].style.display=\"none\";}\n    }\n    for(;mi&lt;30;mi++)msgPool[mi].style.display=\"none\";\n\n    tAxisLine.setAttribute(\"x1\",tmg.l);tAxisLine.setAttribute(\"x2\",tmg.l+tcw);\n    tAxisLine.setAttribute(\"y1\",axisY);tAxisLine.setAttribute(\"y2\",axisY);\n    tLabelStart.setAttribute(\"x\",tmg.l);tLabelStart.setAttribute(\"y\",axisY+18);\n    tLabelEnd.setAttribute(\"x\",tmg.l+tcw);tLabelEnd.setAttribute(\"y\",axisY+18);\n\n    const tStep=n&lt;=10?1:n&lt;=30?5:n&lt;=60?10:20;\n    let tti=0;\n    for(let i=tStep;i&lt;n&&tti&lt;20;i+=tStep){\n      const x=tmg.l+i*slotW;\n      tTickPool[tti].setAttribute(\"x\",x);\n      tTickPool[tti].setAttribute(\"y\",axisY+16);\n      tTickPool[tti].textContent=i;\n      tTickPool[tti].style.display=\"\";\n      tti++;\n    }\n    for(;tti&lt;20;tti++)tTickPool[tti].style.display=\"none\";\n\n    // ── Distribution chart ──\n    const hiK=Math.max(Math.ceil(lam+4*Math.sqrt(lam)),8);\n    let maxY=0;\n    const bVals=[],pVals=[];\n    for(let k=0;k&lt;=hiK;k++){\n      const bv=binPMF(k,n,p),pv=poisPMF(k,lam);\n      bVals.push(bv);pVals.push(pv);\n      if(bv&gt;maxY)maxY=bv;if(pv&gt;maxY)maxY=pv;\n    }\n    maxY*=1.18;if(maxY&lt;0.01)maxY=0.1;\n\n    const sx=k=&gt;cmg.l+(k/hiK)*ccw;\n    const sy=y=&gt;cmg.t+cch-(y/maxY)*cch;\n    const barW=Math.max(2,Math.min(28,ccw/hiK*0.6));\n    const baseline=sy(0);\n\n    for(let i=0;i&lt;=4;i++){\n      const v=(maxY/4)*i,yy=sy(v);\n      gridLines[i].setAttribute(\"x1\",cmg.l);gridLines[i].setAttribute(\"x2\",CW-cmg.r);\n      gridLines[i].setAttribute(\"y1\",yy);gridLines[i].setAttribute(\"y2\",yy);\n      yLabels[i].setAttribute(\"x\",cmg.l-8);yLabels[i].setAttribute(\"y\",yy+4);\n      yLabels[i].textContent=v.toFixed(v&lt;0.01?3:2);\n    }\n\n    for(let i=0;i&lt;BPOOL;i++){\n      if(i&lt;=hiK){\n        const bx=sx(i)-barW/2,by=sy(bVals[i]);\n        bBars[i].setAttribute(\"x\",bx);bBars[i].setAttribute(\"y\",by);\n        bBars[i].setAttribute(\"width\",barW);\n        bBars[i].setAttribute(\"height\",Math.max(0,baseline-by));\n        bBars[i].style.display=\"\";\n      }else{bBars[i].style.display=\"none\";}\n    }\n\n    let d=\"\";\n    for(let k=0;k&lt;=hiK;k++){\n      const px=sx(k),py=sy(pVals[k]);\n      d+=(k===0?\"M\":\"L\")+px.toFixed(1)+\",\"+py.toFixed(1);\n      if(k&lt;BPOOL){pDots[k].setAttribute(\"cx\",px);pDots[k].setAttribute(\"cy\",py);pDots[k].style.display=\"\";}\n    }\n    for(let k=hiK+1;k&lt;BPOOL;k++)pDots[k].style.display=\"none\";\n    pPath.setAttribute(\"d\",d);\n\n    xAx.setAttribute(\"x1\",cmg.l);xAx.setAttribute(\"x2\",CW-cmg.r);\n    xAx.setAttribute(\"y1\",baseline);xAx.setAttribute(\"y2\",baseline);\n    xLbl.setAttribute(\"x\",cmg.l+ccw/2);\n\n    let ti=0;\n    for(let k=0;k&lt;=hiK&&ti&lt;20;k++){\n      const xx=sx(k);\n      xTickPool[ti].ln.setAttribute(\"x1\",xx);xTickPool[ti].ln.setAttribute(\"x2\",xx);\n      xTickPool[ti].ln.setAttribute(\"y1\",baseline);xTickPool[ti].ln.setAttribute(\"y2\",baseline+5);\n      xTickPool[ti].ln.style.display=\"\";\n      xTickPool[ti].t.setAttribute(\"x\",xx);xTickPool[ti].t.setAttribute(\"y\",baseline+5);\n      xTickPool[ti].t.textContent=k;xTickPool[ti].t.style.display=\"\";\n      ti++;\n    }\n    for(;ti&lt;20;ti++){xTickPool[ti].ln.style.display=\"none\";xTickPool[ti].t.style.display=\"none\";}\n\n    legT1.textContent=\"Binom(\"+n+\", \"+(p&lt;0.01?p.toExponential(1):p.toFixed(3))+\")\";\n    legT2.textContent=\"Poisson(\"+lam.toFixed(1)+\")\";\n\n    wrapper.value={lam,n,p};\n    wrapper.dispatchEvent(new Event(\"input\",{bubbles:true}));\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 8. EVENTS\n  // ══════════════════════════════════════════════════════\n  let rafId=0;\n  function schedule(){cancelAnimationFrame(rafId);rafId=requestAnimationFrame(render);}\n  function onLam(){SL.lam.sync();schedule();}\n  function onN(){SL.n.sync();schedule();}\n  SL.lam.input.addEventListener(\"input\",onLam);\n  SL.n.input.addEventListener(\"input\",onN);\n\n  render();\n\n  invalidation.then(()=&gt;{\n    cancelAnimationFrame(rafId);\n    SL.lam.input.removeEventListener(\"input\",onLam);\n    SL.n.input.removeEventListener(\"input\",onN);\n    lcCache.clear();\n  });\n\n  wrapper.value={};\n  return wrapper;\n})()",
    "crumbs": [
      "Phân phối rời rạc",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối Poisson</span>"
    ]
  },
  {
    "objectID": "distr-c.html",
    "href": "distr-c.html",
    "title": "Phân phối liên tục",
    "section": "",
    "text": "Phân loại\nDựa trên cơ chế tạo ra dữ liệu, phân phối liên tục có các nhóm chính sau:",
    "crumbs": [
      "Phân phối liên tục"
    ]
  },
  {
    "objectID": "distr-c.html#phân-phối-pareto",
    "href": "distr-c.html#phân-phối-pareto",
    "title": "Phân phối liên tục",
    "section": "Phân phối Pareto",
    "text": "Phân phối Pareto",
    "crumbs": [
      "Phân phối liên tục"
    ]
  },
  {
    "objectID": "distr-c.html#phân-phối-gamma",
    "href": "distr-c.html#phân-phối-gamma",
    "title": "Phân phối liên tục",
    "section": "Phân phối gamma",
    "text": "Phân phối gamma",
    "crumbs": [
      "Phân phối liên tục"
    ]
  },
  {
    "objectID": "distr-c.html#phân-phối-chuẩn",
    "href": "distr-c.html#phân-phối-chuẩn",
    "title": "Phân phối liên tục",
    "section": "Phân phối chuẩn",
    "text": "Phân phối chuẩn",
    "crumbs": [
      "Phân phối liên tục"
    ]
  },
  {
    "objectID": "distr-c.html#phân-phối-chi-bình-phương",
    "href": "distr-c.html#phân-phối-chi-bình-phương",
    "title": "Phân phối liên tục",
    "section": "Phân phối Chi-bình phương",
    "text": "Phân phối Chi-bình phương\nNếu \\(Z_1, \\dots, Z_k\\) là các biến ngẫu nhiên có phân phối chuẩn tắc (standard normal, là phân phối chuẩn có \\(\\mu = 0\\) và \\(\\sigma = 1\\)) độc lập, thì tổng bình phương của chúng:\n\\[X = \\sum_{i=1}^{k} Z_i^2\\]\nsẽ tuân theo phân phối Chi-bình phương (chi-squared distribution) với \\(k\\) bậc tự do. Kí hiệu:\n\\[X \\sim \\chi^2(k) \\quad \\text{hoặc} \\quad X \\sim \\chi_k^2\\]",
    "crumbs": [
      "Phân phối liên tục"
    ]
  },
  {
    "objectID": "distr-c.html#phân-phối-log-normal",
    "href": "distr-c.html#phân-phối-log-normal",
    "title": "Phân phối liên tục",
    "section": "Phân phối log-normal",
    "text": "Phân phối log-normal",
    "crumbs": [
      "Phân phối liên tục"
    ]
  },
  {
    "objectID": "distr-norm.html",
    "href": "distr-norm.html",
    "title": "5  Phân phối bình thường",
    "section": "",
    "text": "import { createSlider, createButton, injectStyle } from \"./_slider.js\"\nd3 = require(\"d3@7\")\njStat = require(\"jstat@1.9.6\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof clt = {\n\n  // ═══════════════════════════════════════════════════\n  // CONFIG\n  // ═══════════════════════════════════════════════════\n  const W_LEFT = 520, W_RIGHT = 520, H = 420;\n  const MARGIN = { top: 40, right: 20, bottom: 50, left: 55 };\n  const BLOCK_SIZE = 8;\n\n\n  const COL = {\n    pdf: \"#6366f1\", pdfFill: \"rgba(99,102,241,0.12)\",\n    sample: \"#f97316\", sampleStroke: \"#ea580c\",\n    mean: \"#dc2626\",\n    block: \"#6366f1\", blockNew: \"#f59e0b\", blockStroke: \"#4f46e5\",\n    axis: \"#64748b\", label: \"#334155\", bg: \"#fff\",\n    gridLine: \"#e2e8f0\",\n  };\n\n  // ═══════════════════════════════════════════════════\n  // DISTRIBUTIONS\n  // ═══════════════════════════════════════════════════\n  const DISTRIBUTIONS = {\n    \"Uniform\": {\n      params: [\n        { name: \"a (min)\", min: 0, max: 9, step: 0.1, val: 0, color: \"#0891b2\", cls: \"teal\" },\n        { name: \"b (max)\", min: 0.5, max: 10, step: 0.1, val: 5, color: \"#0891b2\", cls: \"teal\" },\n      ],\n      pdf: (x, p) =&gt; {\n        const [a, b] = p;\n        return (x &gt;= a && x &lt;= b) ? 1 / (b - a) : 0;\n      },\n      sample: (p) =&gt; {\n        const [a, b] = p;\n        return a + Math.random() * (b - a);\n      },\n      xRange: (p) =&gt; [p[0] - 0.5, p[1] + 0.5],\n    },\n    \"Exponential\": {\n      params: [\n        { name: \"λ\", min: 0.1, max: 5, step: 0.1, val: 1, color: \"#dc2626\", cls: \"red\" },\n      ],\n      pdf: (x, p) =&gt; {\n        const lam = p[0];\n        return x &gt;= 0 ? lam * Math.exp(-lam * x) : 0;\n      },\n      sample: (p) =&gt; {\n        return -Math.log(Math.random()) / p[0];\n      },\n      xRange: (p) =&gt; [0, Math.max(6, 5 / p[0])],\n    },\n    \"Beta\": {\n      params: [\n        { name: \"α\", min: 0.2, max: 10, step: 0.1, val: 2, color: \"#16a34a\", cls: \"green\" },\n        { name: \"β\", min: 0.2, max: 10, step: 0.1, val: 5, color: \"#16a34a\", cls: \"green\" },\n      ],\n      pdf: (x, p) =&gt; {\n        if (x &lt;= 0 || x &gt;= 1) return 0;\n        return jStat.beta.pdf(x, p[0], p[1]);\n      },\n      sample: (p) =&gt; {\n        return jStat.beta.sample(p[0], p[1]);\n      },\n      xRange: () =&gt; [-0.05, 1.05],\n    },\n  };\n\n  // ═══════════════════════════════════════════════════\n  // STATE\n  // ═══════════════════════════════════════════════════\n  let currentDist = \"Uniform\";\n  let allMeans = [];\n  let currentSamples = [];\n  let currentMean = null;\n  let autoTimer = null;\n\n  // ═══════════════════════════════════════════════════\n  // OUTER WRAPPER\n  // ═══════════════════════════════════════════════════\n  const outer = document.createElement(\"div\");\n  outer.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:1120px;margin:0 auto;`;\n  outer.appendChild(injectStyle());\n\n  // ═══════════════════════════════════════════════════\n  // CONTROLS ROW\n  // ═══════════════════════════════════════════════════\n  const controlRow = document.createElement(\"div\");\n  controlRow.style.cssText = `display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end;\n    width:100%;margin-bottom:14px;padding:12px 16px;\n    background:#f8fafc;border-radius:12px;border:1px solid #e2e8f0;`;\n\n  // Distribution dropdown\n  const distCol = document.createElement(\"div\");\n  distCol.style.cssText = \"display:flex;flex-direction:column;min-width:140px;\";\n  const distLbl = document.createElement(\"span\");\n  distLbl.style.cssText = \"font-size:12px;font-weight:600;color:#64748b;letter-spacing:0.3px;text-transform:uppercase;margin-bottom:5px;\";\n  distLbl.textContent = \"Distribution\";\n  const distSelect = document.createElement(\"select\");\n  distSelect.style.cssText = `padding:7px 10px;border-radius:8px;border:1px solid #d1d5db;\n    font-size:13px;font-weight:600;color:${COL.label};background:#fff;cursor:pointer;\n    font-family:inherit;`;\n  Object.keys(DISTRIBUTIONS).forEach(name =&gt; {\n    const opt = document.createElement(\"option\");\n    opt.value = name; opt.textContent = name;\n    distSelect.appendChild(opt);\n  });\n  distCol.appendChild(distLbl);\n  distCol.appendChild(distSelect);\n  controlRow.appendChild(distCol);\n\n  // Parameter sliders container\n  const paramBox = document.createElement(\"div\");\n  paramBox.style.cssText = \"display:flex;gap:12px;flex:1;min-width:200px;\";\n  controlRow.appendChild(paramBox);\n\n  // Sample size slider\n  const SL = {};\n\n  outer.appendChild(controlRow);\n\n  // ── Second controls row: samples + speed ──\n  const controlRow2 = document.createElement(\"div\");\n  controlRow2.style.cssText = `display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end;\n    width:100%;margin-bottom:14px;padding:12px 16px;\n    background:#f8fafc;border-radius:12px;border:1px solid #e2e8f0;`;\n\n  SL.n = createSlider(\"Samples (n)\", 1, 100, 1, 30, \"#1e293b\", \"dark\");\n  SL.n.el.style.flex = \"1 1 200px\";\n  controlRow2.appendChild(SL.n.el);\n\n  // Speed slider: 1 (slowest) to 10 (fastest), maps internally to interval ms\n  SL.speed = createSlider(\"Speed\", 1, 10, 1, 5, \"#d97706\", \"amber\");\n  SL.speed.el.style.flex = \"1 1 200px\";\n  controlRow2.appendChild(SL.speed.el);\n\n  // Convert speed value (1-10) to interval in ms: 10 → 50ms, 1 → 1500ms\n  function speedToInterval(v) {\n    return Math.round(1500 - (v - 1) * (1450 / 9));\n  }\n\n  outer.appendChild(controlRow2);\n\n  // ── Buttons row ──\n  const btnRow = document.createElement(\"div\");\n  btnRow.style.cssText = `display:flex;gap:8px;width:100%;margin-bottom:14px;`;\n\n  const btnSample = createButton(\"▶  Sample Once\", \"go\");\n  const btnAuto = createButton(\"⚡ Auto Sample\", \"auto\");\n  const btnReset = createButton(\"↺  Reset\", \"reset\");\n\n  btnRow.appendChild(btnSample.el);\n  btnRow.appendChild(btnAuto.el);\n  btnRow.appendChild(btnReset.el);\n  outer.appendChild(btnRow);\n\n  // ── Count display ──\n  const countEl = document.createElement(\"div\");\n  countEl.style.cssText = `font-size:12px;font-weight:600;color:${COL.axis};margin-bottom:8px;width:100%;text-align:left;`;\n  countEl.textContent = \"Means collected: 0\";\n  outer.appendChild(countEl);\n\n  // ═══════════════════════════════════════════════════\n  // SVG PANELS\n  // ═══════════════════════════════════════════════════\n  const panelRow = document.createElement(\"div\");\n  panelRow.style.cssText = \"display:flex;gap:8px;width:100%;justify-content:center;\";\n\n  // ── LEFT SVG (PDF) ──\n  const svgLeft = d3.create(\"svg\")\n    .attr(\"viewBox\", `0 0 ${W_LEFT} ${H}`)\n    .attr(\"width\", \"100%\")\n    .style(\"max-width\", W_LEFT + \"px\")\n    .style(\"background\", COL.bg)\n    .style(\"border-radius\", \"12px\")\n    .style(\"border\", \"1px solid #e2e8f0\")\n    .style(\"flex\", \"1 1 480px\");\n\n  // Left axes groups\n  const gLeftX = svgLeft.append(\"g\").attr(\"transform\", `translate(0,${H - MARGIN.bottom})`);\n  const gLeftY = svgLeft.append(\"g\").attr(\"transform\", `translate(${MARGIN.left},0)`);\n  const gLeftGrid = svgLeft.append(\"g\").attr(\"class\", \"grid\");\n  const gPdf = svgLeft.append(\"g\");\n  const gSamples = svgLeft.append(\"g\");\n  const gMean = svgLeft.append(\"g\");\n\n  // Left title\n  svgLeft.append(\"text\")\n    .attr(\"x\", W_LEFT / 2).attr(\"y\", 22)\n    .attr(\"text-anchor\", \"middle\").attr(\"font-size\", 16).attr(\"font-weight\", 700)\n    .attr(\"fill\", COL.label).text(\"Source Distribution (PDF)\");\n\n  // Mean line elements\n  const meanLine = gMean.append(\"line\")\n    .attr(\"stroke\", COL.mean).attr(\"stroke-width\", 2.5)\n    .attr(\"stroke-dasharray\", \"6,3\").attr(\"opacity\", 0);\n  const meanLabel = gMean.append(\"g\").attr(\"opacity\", 0);\n  const meanLabelBg = meanLabel.append(\"rect\")\n    .attr(\"rx\", 6).attr(\"fill\", COL.mean);\n  const meanLabelTxt = meanLabel.append(\"text\")\n    .attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\")\n    .attr(\"fill\", \"#fff\").attr(\"font-size\", 12).attr(\"font-weight\", 700);\n\n  const leftPanel = document.createElement(\"div\");\n  leftPanel.style.cssText = \"flex:1 1 0;min-width:0;overflow:hidden;\";\n  leftPanel.appendChild(svgLeft.node());\n  panelRow.appendChild(leftPanel);\n\n  // ── RIGHT SVG (Stacked histogram) ──\n  const svgRight = d3.create(\"svg\")\n    .attr(\"viewBox\", `0 0 ${W_RIGHT} ${H}`)\n    .attr(\"width\", \"100%\")\n    .style(\"max-width\", W_RIGHT + \"px\")\n    .style(\"background\", COL.bg)\n    .style(\"border-radius\", \"12px\")\n    .style(\"border\", \"1px solid #e2e8f0\")\n    .style(\"flex\", \"1 1 480px\");\n\n  const gRightX = svgRight.append(\"g\").attr(\"transform\", `translate(0,${H - MARGIN.bottom})`);\n  const gRightY = svgRight.append(\"g\").attr(\"transform\", `translate(${MARGIN.left},0)`);\n  const gRightGrid = svgRight.append(\"g\").attr(\"class\", \"grid\");\n  const gBlocks = svgRight.append(\"g\");\n\n  // Right title\n  svgRight.append(\"text\")\n    .attr(\"x\", W_RIGHT / 2).attr(\"y\", 22)\n    .attr(\"text-anchor\", \"middle\").attr(\"font-size\", 16).attr(\"font-weight\", 700)\n    .attr(\"fill\", COL.label).text(\"Distribution of x̄\");\n\n  // Normal overlay on the right\n  const gNormalOverlay = svgRight.append(\"g\");\n\n  const rightPanel = document.createElement(\"div\");\n  rightPanel.style.cssText = \"flex:1 1 0;min-width:0;overflow:hidden;\";\n  rightPanel.appendChild(svgRight.node());\n  panelRow.appendChild(rightPanel);\n\n  outer.appendChild(panelRow);\n\n  // ═══════════════════════════════════════════════════\n  // PARAM SLIDERS (dynamic)\n  // ═══════════════════════════════════════════════════\n  let paramSliders = [];\n\n  function rebuildParamSliders() {\n    paramBox.innerHTML = \"\";\n    paramSliders = [];\n    const dist = DISTRIBUTIONS[currentDist];\n    dist.params.forEach(p =&gt; {\n      const sl = createSlider(p.name, p.min, p.max, p.step, p.val, p.color, p.cls);\n      sl.input.addEventListener(\"input\", () =&gt; { sl.sync(); updatePdf(); });\n      paramSliders.push(sl);\n      paramBox.appendChild(sl.el);\n    });\n  }\n\n  function getParams() {\n    return paramSliders.map(sl =&gt; sl.val());\n  }\n\n  // ═══════════════════════════════════════════════════\n  // PDF RENDERING\n  // ═══════════════════════════════════════════════════\n  let xScaleLeft, yScaleLeft;\n\n  function updatePdf() {\n    const dist = DISTRIBUTIONS[currentDist];\n    const params = getParams();\n    const [xMin, xMax] = dist.xRange(params);\n\n    xScaleLeft = d3.scaleLinear().domain([xMin, xMax])\n      .range([MARGIN.left, W_LEFT - MARGIN.right]);\n\n    // Compute PDF values\n    const nPts = 300;\n    const step = (xMax - xMin) / nPts;\n    const pts = [];\n    let yMax = 0;\n    for (let i = 0; i &lt;= nPts; i++) {\n      const x = xMin + i * step;\n      const y = dist.pdf(x, params);\n      if (isFinite(y) && y &gt;= 0) {\n        pts.push({ x, y });\n        if (y &gt; yMax) yMax = y;\n      }\n    }\n    yMax = Math.max(yMax * 1.15, 0.1);\n\n    yScaleLeft = d3.scaleLinear().domain([0, yMax])\n      .range([H - MARGIN.bottom, MARGIN.top]);\n\n    // Axes\n    gLeftX.call(d3.axisBottom(xScaleLeft).ticks(6))\n      .call(g =&gt; g.select(\".domain\").attr(\"stroke\", COL.axis))\n      .call(g =&gt; g.selectAll(\".tick text\").attr(\"fill\", COL.axis).attr(\"font-size\", 13))\n      .call(g =&gt; g.selectAll(\".tick line\").attr(\"stroke\", COL.axis));\n\n    gLeftY.call(d3.axisLeft(yScaleLeft).ticks(5).tickFormat(d3.format(\".2f\")))\n      .call(g =&gt; g.select(\".domain\").attr(\"stroke\", COL.axis))\n      .call(g =&gt; g.selectAll(\".tick text\").attr(\"fill\", COL.axis).attr(\"font-size\", 13))\n      .call(g =&gt; g.selectAll(\".tick line\").attr(\"stroke\", COL.axis));\n\n    // Grid\n    gLeftGrid.selectAll(\"*\").remove();\n    yScaleLeft.ticks(6).forEach(t =&gt; {\n      gLeftGrid.append(\"line\")\n        .attr(\"x1\", MARGIN.left).attr(\"x2\", W_LEFT - MARGIN.right)\n        .attr(\"y1\", yScaleLeft(t)).attr(\"y2\", yScaleLeft(t))\n        .attr(\"stroke\", COL.gridLine).attr(\"stroke-width\", 0.5);\n    });\n\n    // PDF path\n    const area = d3.area()\n      .x(d =&gt; xScaleLeft(d.x))\n      .y0(H - MARGIN.bottom)\n      .y1(d =&gt; yScaleLeft(d.y))\n      .curve(d3.curveBasis);\n\n    const line = d3.line()\n      .x(d =&gt; xScaleLeft(d.x))\n      .y(d =&gt; yScaleLeft(d.y))\n      .curve(d3.curveBasis);\n\n    gPdf.selectAll(\"*\").remove();\n    gPdf.append(\"path\").datum(pts)\n      .attr(\"d\", area)\n      .attr(\"fill\", COL.pdfFill);\n    gPdf.append(\"path\").datum(pts)\n      .attr(\"d\", line)\n      .attr(\"fill\", \"none\").attr(\"stroke\", COL.pdf)\n      .attr(\"stroke-width\", 2.5);\n\n    // Re-render samples if present\n    renderSamples();\n  }\n\n  // ═══════════════════════════════════════════════════\n  // SAMPLING\n  // ═══════════════════════════════════════════════════\n  function drawOneSampleSet() {\n    const dist = DISTRIBUTIONS[currentDist];\n    const params = getParams();\n    const n = SL.n.val();\n    const samples = [];\n    for (let i = 0; i &lt; n; i++) {\n      samples.push(dist.sample(params));\n    }\n    const mean = d3.mean(samples);\n    currentSamples = samples;\n    currentMean = mean;\n    allMeans.push(mean);\n    countEl.textContent = `Means collected: ${allMeans.length}`;\n    renderSamples();\n    updateHistogram(true);\n  }\n\n  function renderSamples() {\n    gSamples.selectAll(\"*\").remove();\n    gMean.selectAll(\"line, g\").attr(\"opacity\", 0);\n\n    if (!currentSamples.length || !xScaleLeft || !yScaleLeft) return;\n\n    const dist = DISTRIBUTIONS[currentDist];\n    const params = getParams();\n\n    // Draw sample dots along the x-axis area\n    gSamples.selectAll(\"circle\")\n      .data(currentSamples)\n      .join(\"circle\")\n      .attr(\"cx\", d =&gt; xScaleLeft(d))\n      .attr(\"cy\", () =&gt; H - MARGIN.bottom - 6 - Math.random() * 16)\n      .attr(\"r\", 3.5)\n      .attr(\"fill\", COL.sample)\n      .attr(\"stroke\", COL.sampleStroke)\n      .attr(\"stroke-width\", 0.8)\n      .attr(\"opacity\", 0.75);\n\n    // Mean line\n    if (currentMean != null) {\n      const mx = xScaleLeft(currentMean);\n      meanLine\n        .attr(\"x1\", mx).attr(\"x2\", mx)\n        .attr(\"y1\", MARGIN.top).attr(\"y2\", H - MARGIN.bottom)\n        .attr(\"opacity\", 1);\n\n      const txt = `x̄ = ${currentMean.toFixed(3)}`;\n      meanLabelTxt.text(txt);\n      const bbox = meanLabelTxt.node().getBBox ? meanLabelTxt.node().getBBox() : { width: 70, height: 16 };\n      const pw = bbox.width + 14, ph = bbox.height + 8;\n      meanLabelBg.attr(\"x\", -pw / 2).attr(\"y\", -ph / 2).attr(\"width\", pw).attr(\"height\", ph);\n      meanLabelTxt.attr(\"x\", 0).attr(\"y\", 1);\n      meanLabel.attr(\"transform\", `translate(${mx},${MARGIN.top - 14})`).attr(\"opacity\", 1);\n    }\n  }\n\n  // ═══════════════════════════════════════════════════\n  // RIGHT HISTOGRAM (stacked blocks)\n  // ═══════════════════════════════════════════════════\n  let xScaleRight, yScaleRight;\n  let bins = [];\n  const NUM_BINS = 35;\n\n  function computeHistBounds() {\n    const dist = DISTRIBUTIONS[currentDist];\n    const params = getParams();\n    const [xMin, xMax] = dist.xRange(params);\n    // The mean range is narrower than the full range\n    const range = xMax - xMin;\n    const n = SL.n.val();\n    // For means: they cluster more tightly\n    const shrink = Math.max(0.3, 1 / Math.sqrt(Math.max(n, 1)));\n    const center = (xMin + xMax) / 2;\n    // Use theoretical mean as center for common distributions\n    let theoMean = center;\n    if (currentDist === \"Uniform\") theoMean = (params[0] + params[1]) / 2;\n    else if (currentDist === \"Exponential\") theoMean = 1 / params[0];\n    else if (currentDist === \"Beta\") theoMean = params[0] / (params[0] + params[1]);\n\n    const halfSpan = (range * shrink) / 2;\n    // also ensure all existing means fit\n    let lo = theoMean - halfSpan;\n    let hi = theoMean + halfSpan;\n    if (allMeans.length &gt; 0) {\n      lo = Math.min(lo, d3.min(allMeans) - halfSpan * 0.1);\n      hi = Math.max(hi, d3.max(allMeans) + halfSpan * 0.1);\n    }\n    return [lo, hi];\n  }\n\n  function updateHistogram(highlightLast = false) {\n    const [hMin, hMax] = computeHistBounds();\n    const binWidth = (hMax - hMin) / NUM_BINS;\n\n    // Count means per bin\n    const binCounts = new Array(NUM_BINS).fill(0);\n    allMeans.forEach(m =&gt; {\n      let idx = Math.floor((m - hMin) / binWidth);\n      if (idx &lt; 0) idx = 0;\n      if (idx &gt;= NUM_BINS) idx = NUM_BINS - 1;\n      binCounts[idx]++;\n    });\n\n    const maxCount = Math.max(d3.max(binCounts), 1);\n\n    // Compute block size so blocks fit nicely\n    const plotW = W_RIGHT - MARGIN.left - MARGIN.right;\n    const plotH = H - MARGIN.top - MARGIN.bottom;\n    const bw = Math.max(2, Math.floor(plotW / NUM_BINS) - 1);\n    const bh = bw; // square blocks\n\n    // How many blocks can stack vertically?\n    const maxStack = Math.max(maxCount, Math.floor(plotH / bh));\n\n    xScaleRight = d3.scaleLinear().domain([hMin, hMax])\n      .range([MARGIN.left, W_RIGHT - MARGIN.right]);\n\n    // y-scale: 0 at bottom, maxStack at top (1 unit = 1 block height)\n    const yDomainMax = Math.max(maxCount + 1, 5);\n    yScaleRight = d3.scaleLinear().domain([0, yDomainMax])\n      .range([H - MARGIN.bottom, MARGIN.top]);\n\n    // Axes\n    gRightX.call(d3.axisBottom(xScaleRight).ticks(6).tickFormat(d3.format(\".2f\")))\n      .call(g =&gt; g.select(\".domain\").attr(\"stroke\", COL.axis))\n      .call(g =&gt; g.selectAll(\".tick text\").attr(\"fill\", COL.axis).attr(\"font-size\", 13))\n      .call(g =&gt; g.selectAll(\".tick line\").attr(\"stroke\", COL.axis));\n\n    gRightY.call(d3.axisLeft(yScaleRight).ticks(5).tickFormat(d3.format(\"d\")))\n      .call(g =&gt; g.select(\".domain\").attr(\"stroke\", COL.axis))\n      .call(g =&gt; g.selectAll(\".tick text\").attr(\"fill\", COL.axis).attr(\"font-size\", 13))\n      .call(g =&gt; g.selectAll(\".tick line\").attr(\"stroke\", COL.axis));\n\n    // Grid\n    gRightGrid.selectAll(\"*\").remove();\n    yScaleRight.ticks(6).forEach(t =&gt; {\n      gRightGrid.append(\"line\")\n        .attr(\"x1\", MARGIN.left).attr(\"x2\", W_RIGHT - MARGIN.right)\n        .attr(\"y1\", yScaleRight(t)).attr(\"y2\", yScaleRight(t))\n        .attr(\"stroke\", COL.gridLine).attr(\"stroke-width\", 0.5);\n    });\n\n    // Build block rects data\n    const blocks = [];\n    const lastMeanBin = currentMean != null\n      ? Math.min(NUM_BINS - 1, Math.max(0, Math.floor((currentMean - hMin) / binWidth)))\n      : -1;\n\n    // Track which block in the last bin is the newest\n    const binCounterForLast = new Array(NUM_BINS).fill(0);\n    allMeans.forEach((m, idx) =&gt; {\n      let bi = Math.floor((m - hMin) / binWidth);\n      if (bi &lt; 0) bi = 0;\n      if (bi &gt;= NUM_BINS) bi = NUM_BINS - 1;\n      binCounterForLast[bi]++;\n      const isLast = highlightLast && (idx === allMeans.length - 1);\n      blocks.push({\n        bin: bi,\n        stack: binCounterForLast[bi] - 1,\n        isNew: isLast,\n      });\n    });\n\n    // Draw blocks\n    gBlocks.selectAll(\"*\").remove();\n    const blockSel = gBlocks.selectAll(\"rect\")\n      .data(blocks)\n      .join(\"rect\")\n      .attr(\"x\", d =&gt; {\n        const binCenter = hMin + (d.bin + 0.5) * binWidth;\n        return xScaleRight(binCenter) - bw / 2;\n      })\n      .attr(\"y\", d =&gt; yScaleRight(d.stack + 1))\n      .attr(\"width\", bw)\n      .attr(\"height\", Math.max(1, yScaleRight(0) - yScaleRight(1) - 1))\n      .attr(\"rx\", 1)\n      .attr(\"fill\", d =&gt; d.isNew ? COL.blockNew : COL.block)\n      .attr(\"stroke\", d =&gt; d.isNew ? \"#d97706\" : COL.blockStroke)\n      .attr(\"stroke-width\", d =&gt; d.isNew ? 1.5 : 0.5)\n      .attr(\"opacity\", d =&gt; d.isNew ? 1 : 0.85);\n\n    // Highlight new block with glow\n    if (highlightLast) {\n      blockSel.filter(d =&gt; d.isNew)\n        .style(\"filter\", \"drop-shadow(0 0 6px rgba(245,158,11,0.7))\");\n    }\n\n    // Draw theoretical normal overlay if enough means\n    gNormalOverlay.selectAll(\"*\").remove();\n    if (allMeans.length &gt;= 10) {\n      const sampleMeanOfMeans = d3.mean(allMeans);\n      const sampleSdOfMeans = d3.deviation(allMeans);\n      if (sampleSdOfMeans &gt; 0) {\n        const nPts = 200;\n        const ovPts = [];\n        for (let i = 0; i &lt;= nPts; i++) {\n          const x = hMin + (i / nPts) * (hMax - hMin);\n          const z = (x - sampleMeanOfMeans) / sampleSdOfMeans;\n          const y = (1 / (sampleSdOfMeans * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);\n          // Scale density to count: density * totalCount * binWidth\n          const yScaled = y * allMeans.length * binWidth;\n          ovPts.push({ x, y: yScaled });\n        }\n        const ovLine = d3.line()\n          .x(d =&gt; xScaleRight(d.x))\n          .y(d =&gt; yScaleRight(d.y))\n          .curve(d3.curveBasis);\n\n        gNormalOverlay.append(\"path\")\n          .datum(ovPts)\n          .attr(\"d\", ovLine)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", COL.mean)\n          .attr(\"stroke-width\", 2)\n          .attr(\"stroke-dasharray\", \"6,4\")\n          .attr(\"opacity\", 0.7);\n\n\n      }\n    }\n  }\n\n  // ═══════════════════════════════════════════════════\n  // EVENTS\n  // ═══════════════════════════════════════════════════\n  distSelect.addEventListener(\"change\", () =&gt; {\n    currentDist = distSelect.value;\n    rebuildParamSliders();\n    resetAll();\n  });\n\n  SL.n.input.addEventListener(\"input\", () =&gt; {\n    SL.n.sync();\n  });\n\n  SL.speed.input.addEventListener(\"input\", () =&gt; {\n    SL.speed.sync();\n    // If auto-sampling is active, restart with new speed\n    if (autoTimer) {\n      clearInterval(autoTimer);\n      autoTimer = setInterval(drawOneSampleSet, speedToInterval(SL.speed.val()));\n    }\n  });\n\n  btnSample.el.addEventListener(\"click\", () =&gt; {\n    drawOneSampleSet();\n  });\n\n  btnAuto.el.addEventListener(\"click\", () =&gt; {\n    if (autoTimer) {\n      clearInterval(autoTimer);\n      autoTimer = null;\n      btnAuto.setText(\"⚡ Auto Sample\");\n      btnAuto.el.className = \"sl-btn sl-btn-auto\";\n    } else {\n      autoTimer = setInterval(drawOneSampleSet, speedToInterval(SL.speed.val()));\n      btnAuto.setText(\"⏸  Pause\");\n      btnAuto.el.className = \"sl-btn sl-btn-pause\";\n    }\n  });\n\n  btnReset.el.addEventListener(\"click\", () =&gt; {\n    resetAll();\n  });\n\n  function resetAll() {\n    if (autoTimer) {\n      clearInterval(autoTimer);\n      autoTimer = null;\n      btnAuto.setText(\"⚡ Auto Sample\");\n      btnAuto.el.className = \"sl-btn sl-btn-auto\";\n    }\n    allMeans = [];\n    currentSamples = [];\n    currentMean = null;\n    countEl.textContent = \"Means collected: 0\";\n    gSamples.selectAll(\"*\").remove();\n    gMean.selectAll(\"line, g\").attr(\"opacity\", 0);\n    meanLine.attr(\"opacity\", 0);\n    meanLabel.attr(\"opacity\", 0);\n    gBlocks.selectAll(\"*\").remove();\n    gNormalOverlay.selectAll(\"*\").remove();\n    updatePdf();\n    updateHistogram(false);\n  }\n\n  // ═══════════════════════════════════════════════════\n  // INIT\n  // ═══════════════════════════════════════════════════\n  rebuildParamSliders();\n  updatePdf();\n  updateHistogram(false);\n\n  // Cleanup on invalidation\n  invalidation.then(() =&gt; {\n    if (autoTimer) clearInterval(autoTimer);\n  });\n\n  outer.value = {};\n  return outer;\n}",
    "crumbs": [
      "Phân phối liên tục",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Phân phối bình thường</span>"
    ]
  },
  {
    "objectID": "distr-lnorm.html",
    "href": "distr-lnorm.html",
    "title": "6  Phân phối log-normal",
    "section": "",
    "text": "6.0.1 Biến tỉ số\nBiến tỉ số (ratio scale variables) là loại biến mà các đơn vị được đo lường trên thang tỉ số. Loại biến này có các đặc điểm sau (Motulsky, Head, and Clarke 2025):\n\nKhông tồn tại giá trị âm. Biến chỉ có thể nhận các giá trị dương\nGiá trị 0 mang ý nghĩa tuyệt đối: Số 0 hoặc đại diện cho sự vắng mặt hoàn toàn của biến đó (không có), hoặc là một giới hạn tiệm cận.\n\n\n0 = không có: Cân nặng hoặc chiều dài. Cân nặng bằng 0 nghĩa là không có trọng lượng. Chiều cao bằng 0 nghĩa là không có chiều cao.\n0 = tiệm cận: Các chỉ số như EC50 hoặc Km. Các tham số này về lý thuyết không thể bằng 0, nhưng giá trị của chúng có thể cực nhỏ và tiến dần về 0.\n\n\nChuyển đổi đơn vị chỉ dùng phép Nhân hoặc Chia\nViệc tính tỉ số (ratio) mang ý nghĩa thực tiễn: Ví dụ, 4 cm dài gấp đôi 2 cm; 6 lít nước nhiều gấp 3 lần 2 lít nước\n\nKhi 1 biến là biến tỉ số thì sự khác biệt cần phải được đo bằng tỉ số (gấp bao nhiêu lần, bằng phép chia) chứ không phải là chênh lệch bao nhiêu giá trị (phép trừ).\nVí dụ: Nhiệt độ không phải là biến tỉ số\n\nCó giá trị âm\nĐiểm 0 là quy ước, không phải tuyệt đối. 0°C không có nghĩa là “không có nhiệt độ”\nCông thức chuyển đổi từ độ C sang độ F\n\n\\[^\\circ C = (^\\circ F - 32) \\times \\frac{5}{9}\\]\n\nTỉ số (ratio) không có ý nghĩa thực tiễn: 200°C không nóng gấp đôi 100°C. Sự thay đổi nhiệt độ phải được diễn đạt dưới dạng chênh lệch bao nhiêu giá trị (hiệu số).\n\n\n\n\n\n\n\nNote\n\n\n\nBiến nào là biến tỉ số? Tại sao?\n\nTuổi\nNồng độ kháng thể\nKhoảng thời gian\nChỉ số IQ\nTải lượng virus (viral load)\n\n\n\nKhi log(biến) có phân phối chuẩn\nKhi có outliers làm cho phân phối bị lệch phải.\n\n\n6.0.2 Tại sao dùng log?\n\\[\\log(a \\times b) = \\log(a) + \\log(b)\\]\n\n\n6.0.3 Cơ chế tạo ra log-normal\nĐặc trưng của phân phối log-normal là phép nhân.\nĐịnh lý giới hạn trung tâm cho biết rằng tổng của nhiều biến ngẫu nhiên độc lập sẽ tạo ra phân phối Chuẩn. Tương tự, tích của nhiều biến ngẫu nhiên sẽ tạo ra phân phối log-normal (Motulsky, Head, and Clarke 2025). Đây được gọi là Quy luật Tác động Tỉ lệ (Law of Proportionate Effect).\nMột số cơ chế tạo ra phân phối này (Koch 1966):\n\nSự tăng trưởng tích lũy: Giá trị của bước tiếp theo là kết quả của bước hiện tại nhân với một tỉ lệ biến động ngẫu nhiên (lãi suất, tốc độ tăng trưởng)\n\n\\(X_{t+1} = X_t \\times (1 + r)\\)\n\nSự phân mảnh: Ngược lại với quá trình tích lũy, là quá trình phá vỡ một vật thể lớn thành nhiều mảnh nhỏ. Ví dụ: Kích thước của sỏi đá trong địa chất, hoặc các mảnh vụn khi nghiền bánh quy.\nSự phân chia sinh học: tế bào phân chia\n\n\n\n\n\nKoch, Arthur L. 1966. “The Logarithm in Biology 1. Mechanisms Generating the Log-Normal Distribution Exactly.” Journal of Theoretical Biology 12 (2): 276–90. https://doi.org/10.1016/0022-5193(66)90119-6.\n\n\nMotulsky, Harvey J., Trajen Head, and Paul B. S. Clarke. 2025. “Analyzing Lognormal Data: A Nonmathematical Practical Guide.” Pharmacological Reviews 77 (3): 100049. https://doi.org/10.1016/j.pharmr.2025.100049.",
    "crumbs": [
      "Phân phối liên tục",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Phân phối log-normal</span>"
    ]
  },
  {
    "objectID": "distr-exp.html",
    "href": "distr-exp.html",
    "title": "7  Phân phối mũ",
    "section": "",
    "text": "7.1 Định nghĩa\nPhân phối mũ (exponential distribution) dùng để mô hình thời gian chờ từ khi một biến cố xảy ra cho đến biến cố tiếp theo trong một quá trình Poisson.\n\\[f(x) = \\underbrace{\\lambda}_{\\text{Cường độ ban đầu}} \\cdot \\underbrace{e^{-\\lambda x}}_{\\text{Quy luật suy giảm}}\\]\nVì vậy phân phối mũ có liên hệ chặt chẽ với phân phối Poisson.\nTrong mô hình SIR, khi chúng ta định nghĩa \\(I\\) hồi phục với tần suất trung bình là \\(\\gamma\\), thì sự di chuyển từ \\(I\\) sang \\(R\\) là 1 quá trình Poisson. Thời gian một người từ lúc bước vào khoang \\(I\\) cho tới khi chuyển sang khoang \\(R\\) sẽ tuân theo phân phối mũ.\nviewof sir_sim = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. STYLE\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:960px;margin:0 auto;\n  `;\n\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    .sir-slider{position:relative;height:8px;border-radius:4px;background:#e2e8f0;}\n    .sir-slider-fill{position:absolute;left:0;top:0;height:100%;border-radius:4px;transition:width 0.04s;}\n    .sir-slider input[type=range]{\n      position:absolute;top:0;left:0;width:100%;height:100%;\n      -webkit-appearance:none;appearance:none;background:transparent;\n      cursor:pointer;margin:0;padding:0;\n    }\n    .sir-slider input[type=range]::-webkit-slider-thumb{\n      -webkit-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;\n      border:3px solid #fff;box-shadow:0 1px 5px rgba(0,0,0,0.28);\n      cursor:pointer;margin-top:-6px;background:#475569;\n    }\n    .sir-slider input[type=range]::-moz-range-thumb{\n      width:14px;height:14px;border-radius:50%;border:3px solid #fff;\n      box-shadow:0 1px 5px rgba(0,0,0,0.28);cursor:pointer;background:#475569;\n    }\n    .sir-slider input[type=range]::-webkit-slider-runnable-track{height:8px;background:transparent;}\n    .sir-slider input[type=range]::-moz-range-track{height:8px;background:transparent;}\n    .sir-slider-blue input[type=range]::-webkit-slider-thumb{background:#3b82f6;}\n    .sir-slider-blue input[type=range]::-moz-range-thumb{background:#3b82f6;}\n    .sir-slider-red input[type=range]::-webkit-slider-thumb{background:#dc2626;}\n    .sir-slider-red input[type=range]::-moz-range-thumb{background:#dc2626;}\n    .sir-slider-amber input[type=range]::-webkit-slider-thumb{background:#d97706;}\n    .sir-slider-amber input[type=range]::-moz-range-thumb{background:#d97706;}\n    .sir-slider-green input[type=range]::-webkit-slider-thumb{background:#16a34a;}\n    .sir-slider-green input[type=range]::-moz-range-thumb{background:#16a34a;}\n    .sir-btn{\n      padding:8px 0;border-radius:8px;border:1px solid #d1d5db;\n      background:#fff;color:#374151;font-size:13px;font-weight:600;\n      cursor:pointer;transition:background 0.1s;font-family:inherit;text-align:center;flex:1;\n    }\n    .sir-btn:hover{background:#f3f4f6;}\n    .sir-btn-step{background:#3b82f6;color:#fff;border-color:#2563eb;}\n    .sir-btn-step:hover{background:#2563eb;color:#fff;}\n    .sir-btn-auto{background:#16a34a;color:#fff;border-color:#15803d;}\n    .sir-btn-auto:hover{background:#15803d;color:#fff;}\n    .sir-btn-reset{background:#fef2f2;color:#dc2626;border-color:#fecaca;}\n    .sir-btn-reset:hover{background:#fee2e2;color:#dc2626;}\n  `;\n  wrapper.appendChild(style);\n\n  // ══════════════════════════════════════════════════════\n  // 2. SLIDERS\n  // ══════════════════════════════════════════════════════\n  function createSlider(label,min,max,step,val,color,cls){\n    const row=document.createElement(\"div\");\n    row.style.cssText=\"display:flex;flex-direction:column;flex:1;min-width:140px;\";\n    const head=document.createElement(\"div\");\n    head.style.cssText=\"display:flex;justify-content:space-between;align-items:baseline;margin-bottom:5px;\";\n    const lbl=document.createElement(\"span\");\n    lbl.style.cssText=\"font-size:11px;font-weight:600;color:#64748b;letter-spacing:0.3px;text-transform:uppercase;\";\n    lbl.textContent=label;\n    const valSpan=document.createElement(\"span\");\n    valSpan.style.cssText=`font-size:17px;font-weight:800;color:${color};font-variant-numeric:tabular-nums;font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;`;\n    valSpan.textContent=step&lt;1?Number(val).toFixed(2):val;\n    head.appendChild(lbl);head.appendChild(valSpan);\n    const track=document.createElement(\"div\");\n    track.className=\"sir-slider sir-slider-\"+cls;\n    const fill=document.createElement(\"div\");\n    fill.className=\"sir-slider-fill\";fill.style.background=color;\n    fill.style.width=((val-min)/(max-min))*100+\"%\";\n    track.appendChild(fill);\n    const input=document.createElement(\"input\");\n    input.type=\"range\";input.min=min;input.max=max;input.step=step;input.value=val;\n    track.appendChild(input);\n    row.appendChild(head);row.appendChild(track);\n    return{el:row,input,valSpan,fill,\n      val(){return+input.value},\n      sync(){const v=+input.value;valSpan.textContent=step&lt;1?v.toFixed(2):String(v);fill.style.width=((v-min)/(max-min))*100+\"%\";}\n    };\n  }\n\n  const SL={};\n  SL.s0=createSlider(\"Initial Susceptible\",50,300,1,200,\"#3b82f6\",\"blue\");\n  SL.i0=createSlider(\"Initial Infected\",1,5,1,1,\"#dc2626\",\"red\");\n  SL.beta=createSlider(\"\\u03B2 (infect per day)\",0.5,5,0.5,2,\"#d97706\",\"amber\");\n  SL.gamma=createSlider(\"\\u03B3 (recovery prob/day)\",0.05,0.80,0.05,0.20,\"#16a34a\",\"green\");\n\n  const r1=document.createElement(\"div\");\n  r1.style.cssText=\"display:flex;gap:24px;width:100%;margin-bottom:10px;\";\n  r1.appendChild(SL.s0.el);r1.appendChild(SL.i0.el);\n  wrapper.appendChild(r1);\n  const r2=document.createElement(\"div\");\n  r2.style.cssText=\"display:flex;gap:24px;width:100%;margin-bottom:12px;\";\n  r2.appendChild(SL.beta.el);r2.appendChild(SL.gamma.el);\n  wrapper.appendChild(r2);\n\n  const r3=document.createElement(\"div\");\n  r3.style.cssText=\"display:flex;gap:10px;width:100%;margin-bottom:14px;padding-bottom:14px;border-bottom:1px solid #e2e8f0;\";\n  const btnStep=document.createElement(\"button\");\n  btnStep.className=\"sir-btn sir-btn-step\";btnStep.textContent=\"▶  Step\";\n  const btnAuto=document.createElement(\"button\");\n  btnAuto.className=\"sir-btn sir-btn-auto\";btnAuto.textContent=\"⏩  Auto\";\n  const btnReset=document.createElement(\"button\");\n  btnReset.className=\"sir-btn sir-btn-reset\";btnReset.textContent=\"↺  Reset\";\n  r3.appendChild(btnStep);r3.appendChild(btnAuto);r3.appendChild(btnReset);\n  wrapper.appendChild(r3);\n\n  // ══════════════════════════════════════════════════════\n  // 3. COMPARTMENT BOXES\n  // ══════════════════════════════════════════════════════\n  const boxRow=document.createElement(\"div\");\n  boxRow.style.cssText=\"display:flex;gap:10px;width:100%;margin-bottom:14px;\";\n\n  function makeBox(label,borderColor,bgColor,countColor){\n    const box=document.createElement(\"div\");\n    box.style.cssText=`flex:1;border-radius:10px;border:2px solid ${borderColor};background:${bgColor};padding:10px;min-height:120px;overflow:hidden;`;\n    const hdr=document.createElement(\"div\");\n    hdr.style.cssText=\"display:flex;justify-content:space-between;align-items:baseline;margin-bottom:8px;\";\n    const lbl=document.createElement(\"span\");\n    lbl.style.cssText=`font-size:12px;font-weight:700;color:${countColor};text-transform:uppercase;letter-spacing:0.5px;`;\n    lbl.textContent=label;\n    const cnt=document.createElement(\"span\");\n    cnt.style.cssText=`font-size:20px;font-weight:800;color:${countColor};font-family:\"SF Mono\",monospace;`;\n    cnt.textContent=\"0\";\n    hdr.appendChild(lbl);hdr.appendChild(cnt);box.appendChild(hdr);\n    const grid=document.createElement(\"div\");\n    grid.style.cssText=\"display:flex;flex-wrap:wrap;gap:3px;align-content:flex-start;\";\n    box.appendChild(grid);\n    return{box,cnt,grid};\n  }\n\n  const boxS=makeBox(\"Susceptible\",\"#bfdbfe\",\"#eff6ff\",\"#1d4ed8\");\n  const boxI=makeBox(\"Infected\",\"#fecaca\",\"#fef2f2\",\"#dc2626\");\n  const boxR=makeBox(\"Recovered\",\"#bbf7d0\",\"#f0fdf4\",\"#16a34a\");\n  boxRow.appendChild(boxS.box);boxRow.appendChild(boxI.box);boxRow.appendChild(boxR.box);\n  wrapper.appendChild(boxRow);\n\n  const dayLabel=document.createElement(\"div\");\n  dayLabel.style.cssText=`width:100%;text-align:center;font-size:14px;font-weight:700;color:#334155;margin-bottom:10px;font-family:\"SF Mono\",monospace;`;\n  wrapper.appendChild(dayLabel);\n\n  // ══════════════════════════════════════════════════════\n  // 4. HISTOGRAM SVG\n  // ══════════════════════════════════════════════════════\n  const NS=\"http://www.w3.org/2000/svg\";\n  const CW=760,CH=300;\n  const cmg={t:20,r:20,b:48,l:56};\n  const ccw=CW-cmg.l-cmg.r,cch=CH-cmg.t-cmg.b;\n\n  const svg=document.createElementNS(NS,\"svg\");\n  svg.setAttribute(\"viewBox\",`0 0 ${CW} ${CH}`);\n  svg.style.cssText=`width:100%;max-width:${CW}px;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;`;\n\n  function el(tag,a){const e=document.createElementNS(NS,tag);if(a)for(const[k,v]of Object.entries(a))e.setAttribute(k,v);return e;}\n\n  const gridLines=[];\n  for(let i=0;i&lt;=4;i++){const l=el(\"line\",{stroke:\"#e2e8f0\",\"stroke-width\":\"0.7\"});svg.appendChild(l);gridLines.push(l);}\n  const yLabelsH=[];\n  for(let i=0;i&lt;=4;i++){const t=el(\"text\",{\"text-anchor\":\"end\",fill:\"#94a3b8\",\"font-size\":\"10\",\"font-family\":\"'SF Mono',monospace\"});svg.appendChild(t);yLabelsH.push(t);}\n\n  const BPOOL=60;\n  const hBars=[];\n  for(let i=0;i&lt;BPOOL;i++){\n    const r=el(\"rect\",{rx:\"2\",fill:\"#16a34a\",stroke:\"#15803d\",\"stroke-width\":\"0.5\",opacity:\"0.7\"});\n    r.style.display=\"none\";svg.appendChild(r);hBars.push(r);\n  }\n\n  const expPath=el(\"path\",{fill:\"none\",stroke:\"#dc2626\",\"stroke-width\":\"2.5\",opacity:\"0.85\"});\n  svg.appendChild(expPath);\n\n  const xAx=el(\"line\",{stroke:\"#94a3b8\"});svg.appendChild(xAx);\n  const xTickPool=[];\n  for(let i=0;i&lt;20;i++){\n    const ln=el(\"line\",{stroke:\"#94a3b8\",y2:\"5\"});ln.style.display=\"none\";svg.appendChild(ln);\n    const t=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#64748b\",\"font-size\":\"11\",\"font-family\":\"'SF Mono',monospace\",dy:\"16\"});t.style.display=\"none\";svg.appendChild(t);\n    xTickPool.push({ln,t});\n  }\n  svg.appendChild(el(\"line\",{x1:String(cmg.l),x2:String(cmg.l),y1:String(cmg.t),y2:String(cmg.t+cch),stroke:\"#94a3b8\"}));\n\n  const xLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#64748b\",\"font-size\":\"12\",y:String(CH-4)});\n  xLbl.textContent=\"Length of Stay (days)\";svg.appendChild(xLbl);\n  const yLbl=el(\"text\",{\"text-anchor\":\"middle\",fill:\"#64748b\",\"font-size\":\"12\",x:\"14\",y:String(cmg.t+cch/2),transform:`rotate(-90,14,${cmg.t+cch/2})`});\n  yLbl.textContent=\"Proportion\";svg.appendChild(yLbl);\n\n  const legR1=el(\"rect\",{x:\"580\",y:\"8\",width:\"14\",height:\"10\",rx:\"2\",fill:\"#16a34a\",opacity:\"0.7\"});\n  const legT1=el(\"text\",{x:\"600\",y:\"17\",fill:\"#475569\",\"font-size\":\"11\"});legT1.textContent=\"Observed LOS\";\n  const legL2=el(\"line\",{x1:\"580\",x2:\"594\",y1:\"30\",y2:\"30\",stroke:\"#dc2626\",\"stroke-width\":\"2.5\"});\n  const legT2=el(\"text\",{x:\"600\",y:\"34\",fill:\"#475569\",\"font-size\":\"11\"});legT2.textContent=\"Geometric(\\u03B3)\";\n  svg.appendChild(legR1);svg.appendChild(legT1);svg.appendChild(legL2);svg.appendChild(legT2);\n\n  wrapper.appendChild(svg);\n\n  // ══════════════════════════════════════════════════════\n  // 5. FIXED CHART SETUP (axes + theoretical line)\n  // ══════════════════════════════════════════════════════\n  let chartHiX=1,chartMaxP=0.1;\n  let chartSx,chartSy,chartBarW,chartBaseline;\n\n  function initChart(){\n    const gamma=SL.gamma.val();\n\n    // X range: start at 1, go until geometric PMF &lt; 0.5%\n    chartHiX=Math.max(10,Math.ceil(1+Math.log(0.005/Math.max(gamma,0.01))/Math.log(Math.max(1-gamma,0.01))));\n    chartHiX=Math.min(chartHiX,60);\n\n    // Y range: peak at k=1 is gamma\n    chartMaxP=gamma*1.25;\n    if(chartMaxP&lt;0.05)chartMaxP=0.05;\n\n    // X axis starts at 1 (not 0)\n    chartSx=x=&gt;cmg.l+((x-1)/(chartHiX-1))*ccw;\n    chartSy=y=&gt;cmg.t+cch-(y/chartMaxP)*cch;\n    chartBarW=Math.max(2,Math.min(24,ccw/(chartHiX-1)*0.7));\n    chartBaseline=chartSy(0);\n\n    // Grid\n    for(let i=0;i&lt;=4;i++){\n      const v=(chartMaxP/4)*i,yy=chartSy(v);\n      gridLines[i].setAttribute(\"x1\",cmg.l);gridLines[i].setAttribute(\"x2\",CW-cmg.r);\n      gridLines[i].setAttribute(\"y1\",yy);gridLines[i].setAttribute(\"y2\",yy);\n      yLabelsH[i].setAttribute(\"x\",cmg.l-8);yLabelsH[i].setAttribute(\"y\",yy+4);\n      yLabelsH[i].textContent=v.toFixed(v&lt;0.01?3:2);\n    }\n\n    // X axis\n    xAx.setAttribute(\"x1\",cmg.l);xAx.setAttribute(\"x2\",CW-cmg.r);\n    xAx.setAttribute(\"y1\",chartBaseline);xAx.setAttribute(\"y2\",chartBaseline);\n    xLbl.setAttribute(\"x\",cmg.l+ccw/2);\n\n    const ts=chartHiX&gt;40?5:chartHiX&gt;20?2:1;\n    let ti=0;\n    for(let x=1;x&lt;=chartHiX&&ti&lt;20;x+=ts){\n      const xx=chartSx(x);\n      xTickPool[ti].ln.setAttribute(\"x1\",xx);xTickPool[ti].ln.setAttribute(\"x2\",xx);\n      xTickPool[ti].ln.setAttribute(\"y1\",chartBaseline);xTickPool[ti].ln.setAttribute(\"y2\",chartBaseline+5);\n      xTickPool[ti].ln.style.display=\"\";\n      xTickPool[ti].t.setAttribute(\"x\",xx);xTickPool[ti].t.setAttribute(\"y\",chartBaseline+5);\n      xTickPool[ti].t.textContent=x;xTickPool[ti].t.style.display=\"\";\n      ti++;\n    }\n    for(;ti&lt;20;ti++){xTickPool[ti].ln.style.display=\"none\";xTickPool[ti].t.style.display=\"none\";}\n\n    // Theoretical geometric curve starting at k=1\n    // P(X=k) = gamma * (1-gamma)^(k-1), k = 1, 2, ...\n    const q=1-gamma;\n    let d=\"\";\n    for(let k=1;k&lt;=chartHiX;k+=0.2){\n      const fx=gamma*Math.pow(q,k-1);\n      const px=chartSx(k),py=chartSy(fx);\n      d+=(k===1?\"M\":\"L\")+px.toFixed(1)+\",\"+py.toFixed(1);\n    }\n    expPath.setAttribute(\"d\",d);\n\n    for(let i=0;i&lt;BPOOL;i++)hBars[i].style.display=\"none\";\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 6. SIMULATION STATE\n  // ══════════════════════════════════════════════════════\n  let S_count=0,I_list=[],R_list=[],day=0,autoId=0,running=false;\n\n  let rngState=12345;\n  function rng(){rngState=(rngState*16807)%2147483647;return(rngState-1)/2147483646;}\n\n  function initSim(){\n    clearInterval(autoId);running=false;\n    btnAuto.textContent=\"⏩  Auto\";\n    rngState=12345+(Date.now()&0xFFFF);\n    S_count=SL.s0.val();\n    I_list=[];\n    for(let i=0;i&lt;SL.i0.val();i++)I_list.push({days:0});\n    R_list=[];day=0;\n    initChart();\n    drawAll();\n  }\n\n  function stepSim(){\n    if(I_list.length===0&&day&gt;0)return;\n    const beta=SL.beta.val(),gamma=SL.gamma.val();\n\n    let newInf=Math.min(S_count,Math.floor(beta*I_list.length));\n    S_count-=newInf;\n    const newI=[];\n    for(let i=0;i&lt;newInf;i++)newI.push({days:0});\n\n    const stayI=[];\n    for(let i=0;i&lt;I_list.length;i++){\n      I_list[i].days++;\n      if(rng()&lt;gamma){R_list.push({los:I_list[i].days});}\n      else{stayI.push(I_list[i]);}\n    }\n\n    I_list=stayI.concat(newI);\n    day++;\n    drawAll();\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 7. RENDER BOXES\n  // ══════════════════════════════════════════════════════\n  function personDot(color,text){\n    const d=document.createElement(\"div\");\n    d.style.cssText=`\n      width:${text?\"auto\":\"10px\"};height:${text?\"auto\":\"10px\"};min-width:10px;\n      border-radius:${text?\"6px\":\"50%\"};background:${color};\n      ${text?\"padding:1px 4px;font-size:9px;font-weight:700;color:#fff;font-family:'SF Mono',monospace;text-align:center;\":\"\"}\n    `;\n    if(text)d.textContent=text;\n    return d;\n  }\n\n  function drawBoxes(){\n    boxS.cnt.textContent=S_count;\n    boxI.cnt.textContent=I_list.length;\n    boxR.cnt.textContent=R_list.length;\n\n    boxS.grid.innerHTML=\"\";\n    const sShow=Math.min(S_count,100);\n    for(let i=0;i&lt;sShow;i++)boxS.grid.appendChild(personDot(\"#3b82f6\"));\n    if(S_count&gt;100){const m=document.createElement(\"span\");m.style.cssText=\"font-size:10px;color:#64748b;margin-left:4px;\";m.textContent=\"+\"+(S_count-100);boxS.grid.appendChild(m);}\n\n    boxI.grid.innerHTML=\"\";\n    const iShow=Math.min(I_list.length,60);\n    for(let i=0;i&lt;iShow;i++)boxI.grid.appendChild(personDot(\"#dc2626\",String(I_list[i].days)));\n    if(I_list.length&gt;60){const m=document.createElement(\"span\");m.style.cssText=\"font-size:10px;color:#64748b;margin-left:4px;\";m.textContent=\"+\"+(I_list.length-60);boxI.grid.appendChild(m);}\n\n    boxR.grid.innerHTML=\"\";\n    const rShow=Math.min(R_list.length,60);\n    for(let i=R_list.length-1;i&gt;=Math.max(0,R_list.length-rShow);i--)\n      boxR.grid.appendChild(personDot(\"#16a34a\",String(R_list[i].los)));\n    if(R_list.length&gt;60){const m=document.createElement(\"span\");m.style.cssText=\"font-size:10px;color:#64748b;margin-left:4px;\";m.textContent=\"+\"+(R_list.length-60);boxR.grid.appendChild(m);}\n\n    dayLabel.textContent=\"Day \"+day+(I_list.length===0&&day&gt;0?\" — Epidemic ended\":\"\");\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 8. HISTOGRAM BARS ONLY\n  // ══════════════════════════════════════════════════════\n  function drawHistBars(){\n    if(R_list.length===0){\n      for(let i=0;i&lt;BPOOL;i++)hBars[i].style.display=\"none\";\n      return;\n    }\n\n    const losArr=R_list.map(r=&gt;r.los);\n    const maxLOS=Math.max(...losArr);\n    const bins=new Int32Array(Math.min(maxLOS+1,BPOOL));\n    for(const v of losArr)if(v&lt;bins.length)bins[v]++;\n\n    const total=R_list.length;\n\n    for(let i=0;i&lt;BPOOL;i++){\n      if(i&gt;=1&&i&lt;bins.length&&bins[i]&gt;0){\n        const prop=bins[i]/total;\n        const bx=chartSx(i)-chartBarW/2;\n        const by=chartSy(prop);\n        hBars[i].setAttribute(\"x\",bx);\n        hBars[i].setAttribute(\"y\",by);\n        hBars[i].setAttribute(\"width\",chartBarW);\n        hBars[i].setAttribute(\"height\",Math.max(0,chartBaseline-by));\n        hBars[i].style.display=\"\";\n      }else{\n        hBars[i].style.display=\"none\";\n      }\n    }\n  }\n\n  function drawAll(){drawBoxes();drawHistBars();}\n\n  // ══════════════════════════════════════════════════════\n  // 9. BUTTONS\n  // ══════════════════════════════════════════════════════\n  function onStep(){stepSim();}\n  function onAuto(){\n    if(running){clearInterval(autoId);running=false;btnAuto.textContent=\"⏩  Auto\";return;}\n    running=true;btnAuto.textContent=\"⏸  Stop\";\n    autoId=setInterval(()=&gt;{\n      if(I_list.length===0&&day&gt;0){clearInterval(autoId);running=false;btnAuto.textContent=\"⏩  Auto\";return;}\n      stepSim();\n    },200);\n  }\n  function onReset(){initSim();}\n\n  btnStep.addEventListener(\"click\",onStep);\n  btnAuto.addEventListener(\"click\",onAuto);\n  btnReset.addEventListener(\"click\",onReset);\n\n  function onParam(){SL.s0.sync();SL.i0.sync();SL.beta.sync();SL.gamma.sync();if(!running)initSim();}\n  SL.s0.input.addEventListener(\"input\",onParam);\n  SL.i0.input.addEventListener(\"input\",onParam);\n  SL.beta.input.addEventListener(\"input\",onParam);\n  SL.gamma.input.addEventListener(\"input\",onParam);\n\n  // ══════════════════════════════════════════════════════\n  // 10. INIT & CLEANUP\n  // ══════════════════════════════════════════════════════\n  initSim();\n\n  invalidation.then(()=&gt;{\n    clearInterval(autoId);\n    btnStep.removeEventListener(\"click\",onStep);\n    btnAuto.removeEventListener(\"click\",onAuto);\n    btnReset.removeEventListener(\"click\",onReset);\n    SL.s0.input.removeEventListener(\"input\",onParam);\n    SL.i0.input.removeEventListener(\"input\",onParam);\n    SL.beta.input.removeEventListener(\"input\",onParam);\n    SL.gamma.input.removeEventListener(\"input\",onParam);\n    I_list=[];R_list=[];\n  });\n\n  wrapper.value={};\n  return wrapper;\n})()\nTại sao thời gian ở khoảng \\(I\\) lại là hàm mũ?\nHãy tưởng tượng việc ở trong khoang nhiễm (\\(I\\)) giống như tham gia một trò chơi may rủi mỗi ngày.Giả sử mỗi ngày có một tỷ lệ cố định \\(p\\) số người sẽ hồi phục (rời đi).\\(\\rightarrow\\) Tỷ lệ người còn ở lại sau mỗi ngày là \\((1 - p)\\).Quy luật đào thải sẽ diễn ra như sau:Ngày 1: Bạn phải “sống sót” qua đợt lọc đầu tiên. Xác suất còn lại: \\((1 - p)\\).Ngày 2: Bạn phải tiếp tục sống sót qua đợt lọc thứ hai. Xác suất là: \\((1 - p) \\times (1 - p) = (1 - p)^2\\).Ngày \\(t\\): Bạn phải sống sót qua \\(t\\) lần lọc liên tiếp. Xác suất là: \\((1 - p)^t\\).\nSố lượng người còn lại trong khoang \\(I\\) giảm đi theo luỹ thừa của thời gian (cấp số nhân). Khi chúng ta chia nhỏ thời gian đến vô hạn (từ ngày \\(\\to\\) giờ \\(\\to\\) giây), công thức \\((1 - p)^t\\) sẽ chuyển thành hàm số mũ liên tục \\(e^{-\\lambda t}\\).\nĐó là lý do tại sao thời gian lưu trú tuân theo phân phối mũ.",
    "crumbs": [
      "Phân phối liên tục",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Phân phối mũ</span>"
    ]
  },
  {
    "objectID": "distr-exp.html#định-nghĩa",
    "href": "distr-exp.html#định-nghĩa",
    "title": "7  Phân phối mũ",
    "section": "",
    "text": "Poisson: đếm số lượng biến cố ngẫu nhiên xảy ra trong 1 khoảng thời gian cố định\nMũ: khoảng thời gian giữa 2 biến cố xảy ra",
    "crumbs": [
      "Phân phối liên tục",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Phân phối mũ</span>"
    ]
  },
  {
    "objectID": "distr-pl.html",
    "href": "distr-pl.html",
    "title": "8  Phân phối quy tắc lũy thừa",
    "section": "",
    "text": "\\[p(x) = Cx^{-\\alpha}\\]\n(Clauset, Shalizi, and Newman 2009)\n\n\n\n\nClauset, Aaron, Cosma Rohilla Shalizi, and M. E. J. Newman. 2009. “Power-Law Distributions in Empirical Data.” SIAM Review 51 (4): 661–703. https://doi.org/10.1137/070710111.",
    "crumbs": [
      "Phân phối liên tục",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Phân phối quy tắc lũy thừa</span>"
    ]
  },
  {
    "objectID": "lik.html",
    "href": "lik.html",
    "title": "9  Hàm hợp lý",
    "section": "",
    "text": "9.1 Định nghĩa\n\\[\\mathcal{L}(\\theta \\mid x) = \\mathbb{P}(x \\mid \\theta)\\]\nHàm hợp lý (Likelihood function) là xác suất quan sát được dữ liệu \\(x\\) nếu mô hình với tham số \\(\\theta\\) là đúng.\nLikelihood được sử dụng khi chúng ta đã có dữ liệu \\(x\\), và muốn tìm \\(\\theta\\) hợp lý nhất với dữ liệu này.\n\\(\\mathcal{L}\\) không phải là một phân phối xác suất. Chúng ta chỉ có 1 bộ dữ liệu \\(x\\), nhưng có nhiều giả thiết tham số \\(\\theta\\) khác nhau. Như chúng ta đã học, xác suất có điều kiện thực chất là thu nhỏ không gian mẫu.\n\\[\\begin{aligned}\n\\sum_{\\theta} \\mathcal{L}(\\theta \\mid x) &= \\sum_{\\theta} \\mathbb{P}(x \\mid \\theta) \\\\\n&= \\mathbb{P}(x \\mid \\theta_1) + \\mathbb{P}(x \\mid \\theta_2) + \\dots + \\mathbb{P}(x \\mid \\theta_n) \\\\\n&\\neq 1\n\\end{aligned}\\]\nMỗi số hạng \\(\\mathbb{P}(x \\mid \\theta_i)\\) có mẫu số khác nhau, nên tổng không thể bằng 1.\nviewof pdf_vs_lik_large = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. MATH\n  // ══════════════════════════════════════════════════════\n  function lnComb(n, k) {\n    if (k &lt; 0 || k &gt; n) return -Infinity;\n    if (k === 0 || k === n) return 0;\n    let s = 0;\n    for (let i = 0; i &lt; k; i++) s += Math.log(n - i) - Math.log(i + 1);\n    return s;\n  }\n  function binomPMF(k, n, p) {\n    if (p &lt;= 0) return k === 0 ? 1 : 0;\n    if (p &gt;= 1) return k === n ? 1 : 0;\n    return Math.exp(lnComb(n, k) + k * Math.log(p) + (n - k) * Math.log(1 - p));\n  }\n  function binomLogLik(k, n, p) {\n    if (p &lt;= 0) return k === 0 ? 0 : -Infinity;\n    if (p &gt;= 1) return k === n ? 0 : -Infinity;\n    return lnComb(n, k) + k * Math.log(p) + (n - k) * Math.log(1 - p);\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:960px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  // Colors: p = blue, k = red — EVERYWHERE\n  const CP = \"#3b82f6\"; // p color\n  const CK = \"#dc2626\"; // k color\n\n  // ══════════════════════════════════════════════════════\n  // 3. FORMULA BOX (Reverted to smaller size)\n  // ══════════════════════════════════════════════════════\n  const formulaBox = document.createElement(\"div\");\n  formulaBox.style.cssText = `\n    width:100%;padding:16px 20px;border-radius:12px;margin-bottom:14px;\n    background:#f8fafc;border:1px solid #e2e8f0;text-align:center;\n    font-size:16px;line-height:1.9;color:#334155;\n    font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;\n  `;\n  wrapper.appendChild(formulaBox);\n\n  // ══════════════════════════════════════════════════════\n  // 4. CONTROLS\n  // ══════════════════════════════════════════════════════\n  const SL = {};\n  SL.n = createSlider(\"n (trials)\", 1, 30, 1, 10, \"#1e293b\", \"dark\");\n  SL.p = createSlider(\"p (probability)\", 0.01, 0.99, 0.01, 0.60, CP, \"blue\");\n  SL.k = createSlider(\"k (observed successes)\", 0, 30, 1, 6, CK, \"red\");\n\n  const r1 = document.createElement(\"div\"); r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;\";\n  r1.appendChild(SL.n.el);\n  wrapper.appendChild(r1);\n  const r2 = document.createElement(\"div\"); r2.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:12px;\";\n  r2.appendChild(SL.p.el); r2.appendChild(SL.k.el);\n  wrapper.appendChild(r2);\n\n  // NLL toggle\n  let showNLL = false;\n  const toggleRow = document.createElement(\"div\");\n  toggleRow.style.cssText = \"display:flex;gap:12px;width:100%;margin-bottom:14px;align-items:center;\";\n  const toggleLabel = document.createElement(\"span\");\n  toggleLabel.style.cssText = \"font-size:13px;font-weight:600;color:#64748b;\";\n  toggleLabel.textContent = \"Likelihood panel:\";\n  const btnLik = document.createElement(\"button\");\n  const btnNLL = document.createElement(\"button\");\n  function styleToggle(btn, active, color) {\n    btn.style.cssText = `padding:6px 16px;border-radius:8px;font-size:13px;font-weight:700;\n      font-family:inherit;cursor:pointer;transition:all 0.15s;\n      border:2px solid ${color};\n      background:${active ? color : \"#fff\"};color:${active ? \"#fff\" : color};`;\n  }\n  btnLik.textContent = \"L(p | k)\";\n  btnNLL.textContent = \"\\u2212log L(p | k)\";\n  toggleRow.appendChild(toggleLabel); toggleRow.appendChild(btnLik); toggleRow.appendChild(btnNLL);\n  wrapper.appendChild(toggleRow);\n\n  btnLik.addEventListener(\"click\", () =&gt; { showNLL = false; updateAll(); });\n  btnNLL.addEventListener(\"click\", () =&gt; { showNLL = true; updateAll(); });\n\n  // ══════════════════════════════════════════════════════\n  // 5. SVG PANELS\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const PW = 460, PH = 400; // Increased height\n  // Increased margins significantly to fit larger fonts\n  const mg_ = { t: 80, r: 25, b: 80, l: 75 };\n  const pw_ = PW - mg_.l - mg_.r, ph_ = PH - mg_.t - mg_.b;\n\n  function mkEl(tag, a) {\n    const e = document.createElementNS(NS, tag);\n    if (a) for (const [k,v] of Object.entries(a)) e.setAttribute(k,v);\n    return e;\n  }\n\n  function createPanel() {\n    const svg = document.createElementNS(NS, \"svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${PW} ${PH}`);\n    svg.style.cssText = \"flex:1;min-width:0;border-radius:12px;border:1px solid #e2e8f0;background:#fff;\";\n\n    // HUGE FONTS\n    const title = mkEl(\"text\", { x: String(PW / 2), y: \"34\", \"text-anchor\": \"middle\", \"font-size\": \"26\", \"font-weight\": \"700\" });\n    svg.appendChild(title);\n    const sub = mkEl(\"text\", { x: String(PW / 2), y: \"60\", \"text-anchor\": \"middle\", \"font-size\": \"18\", fill: \"#64748b\" });\n    svg.appendChild(sub);\n\n    const grids = []; for (let i = 0; i &lt;= 4; i++) { svg.appendChild(mkEl(\"line\", { stroke: \"#f1f5f9\", \"stroke-width\": \"1\" })); grids.push(svg.lastChild); }\n    // Y-Tick Font 16\n    const yLbls = []; for (let i = 0; i &lt;= 4; i++) { svg.appendChild(mkEl(\"text\", { \"text-anchor\": \"end\", fill: \"#94a3b8\", \"font-size\": \"16\", \"font-family\": \"'SF Mono',monospace\" })); yLbls.push(svg.lastChild); }\n\n    const bars = []; for (let i = 0; i &lt; 31; i++) { const r = mkEl(\"rect\", { rx: \"2\" }); r.style.display = \"none\"; svg.appendChild(r); bars.push(r); }\n\n    const pathFill = mkEl(\"path\", { \"stroke-width\": \"0\" }); pathFill.style.display = \"none\"; svg.appendChild(pathFill);\n    const path = mkEl(\"path\", { fill: \"none\", \"stroke-width\": \"3\" }); path.style.display = \"none\"; svg.appendChild(path);\n\n    svg.appendChild(mkEl(\"line\", { x1: String(mg_.l), x2: String(mg_.l), y1: String(mg_.t), y2: String(mg_.t + ph_), stroke: \"#cbd5e1\" }));\n    const xAx = mkEl(\"line\", { stroke: \"#cbd5e1\" }); svg.appendChild(xAx);\n    \n    // X-Tick Font 16\n    const xTicks = []; for (let i = 0; i &lt; 31; i++) { const t = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"16\", \"font-family\": \"'SF Mono',monospace\" }); t.style.display = \"none\"; svg.appendChild(t); xTicks.push(t); }\n    \n    // Axis Label Font 18\n    const xLabel = mkEl(\"text\", { x: String(mg_.l + pw_ / 2), y: String(PH - 12), \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"18\", \"font-weight\": \"600\" });\n    svg.appendChild(xLabel);\n\n    // Y-axis label (rotated) - Font 18\n    const yLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"18\", \"font-weight\": \"600\" });\n    svg.appendChild(yLabel);\n\n    // Highlight elements (hidden by default)\n    const hlLine = mkEl(\"line\", { \"stroke-width\": \"2\", \"stroke-dasharray\": \"5,3\" }); hlLine.style.display = \"none\"; svg.appendChild(hlLine);\n    const hlDot = mkEl(\"circle\", { r: \"7\", stroke: \"#fff\", \"stroke-width\": \"2.5\" }); hlDot.style.display = \"none\"; svg.appendChild(hlDot);\n    const hlLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"700\" }); hlLabel.style.display = \"none\"; svg.appendChild(hlLabel);\n\n    return { svg, title, sub, grids, yLbls, bars, path, pathFill, xAx, xTicks, xLabel, yLabel, hlLine, hlDot, hlLabel };\n  }\n\n  const panelPDF = createPanel();\n  const panelLik = createPanel();\n\n  const chartRow = document.createElement(\"div\");\n  chartRow.style.cssText = \"display:flex;gap:12px;width:100%;\";\n  chartRow.appendChild(panelPDF.svg); chartRow.appendChild(panelLik.svg);\n  wrapper.appendChild(chartRow);\n\n  // ══════════════════════════════════════════════════════\n  // 6. RENDER\n  // ══════════════════════════════════════════════════════\n  function fmtY(v) { if (v === 0) return \"0\"; if (Math.abs(v) &gt; 100) return v.toFixed(0); if (Math.abs(v) &gt;= 10) return v.toFixed(1); if (Math.abs(v) &gt;= 1) return v.toFixed(2); if (Math.abs(v) &lt; 0.01) return v.toFixed(3); return v.toFixed(2); }\n\n  function setYLabel(panel, text, color) {\n    const lx = 24, ly = mg_.t + ph_ / 2; // Adjusted lx for larger font\n    panel.yLabel.setAttribute(\"x\", lx); panel.yLabel.setAttribute(\"y\", ly);\n    panel.yLabel.setAttribute(\"transform\", `rotate(-90,${lx},${ly})`);\n    panel.yLabel.setAttribute(\"fill\", color);\n    panel.yLabel.textContent = text;\n  }\n\n  function renderPDF(panel, n, p, k) {\n    panel.title.textContent = \"PDF:  P( k | p )\";\n    panel.title.setAttribute(\"fill\", CP);\n    panel.sub.textContent = `Fix p = ${p.toFixed(2)}, vary k = 0, 1, \\u2026, ${n}`;\n    setYLabel(panel, \"P(k)\", CP);\n\n    const vals = [];\n    for (let ki = 0; ki &lt;= n; ki++) vals.push(binomPMF(ki, n, p));\n    const maxVal = Math.max(...vals) * 1.25 || 0.1;\n\n    const baseline = mg_.t + ph_;\n    const sx = ki =&gt; mg_.l + (ki + 0.5) / (n + 1) * pw_;\n    const sy = v =&gt; mg_.t + ph_ - (v / maxVal) * ph_;\n    const barW = Math.max(4, Math.min(28, pw_ / (n + 1) * 0.7));\n\n    for (let i = 0; i &lt;= 4; i++) {\n      const v = (maxVal / 4) * i, yy = sy(v);\n      panel.grids[i].setAttribute(\"x1\", mg_.l); panel.grids[i].setAttribute(\"x2\", PW - mg_.r);\n      panel.grids[i].setAttribute(\"y1\", yy); panel.grids[i].setAttribute(\"y2\", yy);\n      panel.yLbls[i].setAttribute(\"x\", mg_.l - 10); panel.yLbls[i].setAttribute(\"y\", yy + 6);\n      panel.yLbls[i].textContent = fmtY(v);\n    }\n\n    for (let i = 0; i &lt; 31; i++) {\n      if (i &lt;= n) {\n        const bx = sx(i) - barW / 2, by = sy(vals[i]);\n        panel.bars[i].setAttribute(\"x\", bx); panel.bars[i].setAttribute(\"y\", by);\n        panel.bars[i].setAttribute(\"width\", barW);\n        panel.bars[i].setAttribute(\"height\", Math.max(0, baseline - by));\n        panel.bars[i].setAttribute(\"fill\", \"#93c5fd\");\n        panel.bars[i].setAttribute(\"stroke\", \"#60a5fa\");\n        panel.bars[i].setAttribute(\"stroke-width\", \"0.5\");\n        panel.bars[i].setAttribute(\"opacity\", \"0.55\");\n        panel.bars[i].style.display = \"\";\n      } else { panel.bars[i].style.display = \"none\"; }\n    }\n\n    for (let i = 0; i &lt; 31; i++) {\n      if (i &lt;= n) {\n        const step = n &gt; 20 ? 5 : n &gt; 10 ? 2 : 1;\n        panel.xTicks[i].setAttribute(\"x\", sx(i)); panel.xTicks[i].setAttribute(\"y\", baseline + 24);\n        panel.xTicks[i].textContent = i % step === 0 ? i : \"\";\n        panel.xTicks[i].setAttribute(\"fill\", \"#64748b\");\n        panel.xTicks[i].setAttribute(\"font-weight\", \"400\");\n        panel.xTicks[i].style.display = \"\";\n      } else { panel.xTicks[i].style.display = \"none\"; }\n    }\n\n    panel.xAx.setAttribute(\"x1\", mg_.l); panel.xAx.setAttribute(\"x2\", PW - mg_.r);\n    panel.xAx.setAttribute(\"y1\", baseline); panel.xAx.setAttribute(\"y2\", baseline);\n    panel.xLabel.textContent = \"k (number of successes)\";\n    panel.xLabel.setAttribute(\"fill\", CK);\n\n    panel.hlDot.style.display = \"none\"; panel.hlLabel.style.display = \"none\";\n    panel.hlLine.style.display = \"none\";\n    panel.path.style.display = \"none\"; panel.pathFill.style.display = \"none\";\n  }\n\n  function renderLik(panel, n, p, k) {\n    const nll = showNLL;\n    panel.title.textContent = nll ? \"Neg Log-Lik:  \\u2212ln L( p | k )\" : \"Likelihood:  L( p | k )\";\n    panel.title.setAttribute(\"fill\", CK);\n    panel.sub.textContent = `Fix k = ${k}, vary p \\u2208 [0, 1]`;\n    setYLabel(panel, nll ? \"\\u2212ln L(p)\" : \"L(p)\", CK);\n\n    const NPTS = 200;\n    const curve = [];\n    for (let i = 0; i &lt;= NPTS; i++) {\n      const pi = Math.max(0.001, Math.min(0.999, i / NPTS));\n      curve.push({ p: pi, v: nll ? -binomLogLik(k, n, pi) : binomPMF(k, n, pi) });\n    }\n\n    let minVal, maxVal;\n    if (nll) {\n      minVal = Math.min(...curve.map(c =&gt; c.v));\n      maxVal = Math.max(...curve.filter(c =&gt; isFinite(c.v)).map(c =&gt; c.v));\n      const range = maxVal - minVal || 1;\n      maxVal = minVal + range * 1.2;\n    } else {\n      minVal = 0;\n      maxVal = Math.max(...curve.map(c =&gt; c.v)) * 1.25 || 0.1;\n    }\n\n    const baseline = mg_.t + ph_;\n    const sx = pi =&gt; mg_.l + pi * pw_;\n    const sy = v =&gt; mg_.t + ph_ - ((v - minVal) / ((maxVal - minVal) || 1)) * ph_;\n\n    for (let i = 0; i &lt;= 4; i++) {\n      const v = minVal + ((maxVal - minVal) / 4) * i, yy = sy(v);\n      panel.grids[i].setAttribute(\"x1\", mg_.l); panel.grids[i].setAttribute(\"x2\", PW - mg_.r);\n      panel.grids[i].setAttribute(\"y1\", yy); panel.grids[i].setAttribute(\"y2\", yy);\n      panel.yLbls[i].setAttribute(\"x\", mg_.l - 10); panel.yLbls[i].setAttribute(\"y\", yy + 6);\n      panel.yLbls[i].textContent = fmtY(v);\n    }\n\n    let d = \"\", dFill = \"\";\n    if (!nll) dFill = `M${sx(0).toFixed(1)},${baseline}`;\n    for (let i = 0; i &lt;= NPTS; i++) {\n      const px = sx(curve[i].p), py = sy(curve[i].v);\n      d += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n      if (!nll) dFill += `L${px.toFixed(1)},${py.toFixed(1)}`;\n    }\n\n    if (!nll) {\n      dFill += `L${sx(1).toFixed(1)},${baseline}Z`;\n      panel.pathFill.setAttribute(\"d\", dFill); panel.pathFill.setAttribute(\"fill\", \"#fecaca\");\n      panel.pathFill.setAttribute(\"opacity\", \"0.3\"); panel.pathFill.style.display = \"\";\n    } else { panel.pathFill.style.display = \"none\"; }\n    panel.path.setAttribute(\"d\", d); panel.path.setAttribute(\"stroke\", CK);\n    panel.path.style.display = \"\";\n\n    for (let i = 0; i &lt; 31; i++) {\n      if (i &lt;= 10) {\n        const pi = i / 10;\n        panel.xTicks[i].setAttribute(\"x\", sx(pi)); panel.xTicks[i].setAttribute(\"y\", baseline + 24);\n        panel.xTicks[i].textContent = i % 2 === 0 ? pi.toFixed(1) : \"\";\n        panel.xTicks[i].setAttribute(\"fill\", \"#64748b\"); panel.xTicks[i].setAttribute(\"font-weight\", \"400\");\n        panel.xTicks[i].style.display = \"\";\n      } else { panel.xTicks[i].style.display = \"none\"; }\n    }\n\n    panel.xAx.setAttribute(\"x1\", mg_.l); panel.xAx.setAttribute(\"x2\", PW - mg_.r);\n    panel.xAx.setAttribute(\"y1\", baseline); panel.xAx.setAttribute(\"y2\", baseline);\n    panel.xLabel.textContent = \"p (probability parameter)\";\n    panel.xLabel.setAttribute(\"fill\", CP);\n\n    panel.hlLine.style.display = \"none\";\n    panel.hlDot.style.display = \"none\";\n    panel.hlLabel.style.display = \"none\";\n\n    for (let i = 0; i &lt; 31; i++) panel.bars[i].style.display = \"none\";\n  }\n\n  function updateFormula(n, p, k) {\n    const nmk = n - k;\n    const omp = (1 - p).toFixed(2);\n\n    // REVERTED to smaller formula font sizes\n    formulaBox.innerHTML = `\n      &lt;div style=\"margin-bottom:6px;font-size:13px;color:#64748b;\"&gt;Same formula — different perspective:&lt;/div&gt;\n      &lt;div style=\"font-size:18px;margin-bottom:12px;\"&gt;\n        f(&lt;span style=\"color:${CK};font-weight:700\"&gt;k&lt;/span&gt;, &lt;span style=\"color:${CP};font-weight:700\"&gt;p&lt;/span&gt;)\n        = C(n, &lt;span style=\"color:${CK}\"&gt;k&lt;/span&gt;)\n        \\u00D7 &lt;span style=\"color:${CP}\"&gt;p&lt;/span&gt;&lt;sup style=\"color:${CK}\"&gt;k&lt;/sup&gt;\n        \\u00D7 (1 \\u2212 &lt;span style=\"color:${CP}\"&gt;p&lt;/span&gt;)&lt;sup style=\"color:${CK}\"&gt;n\\u2212k&lt;/sup&gt;\n      &lt;/div&gt;\n      &lt;div style=\"display:flex;gap:24px;justify-content:center;flex-wrap:wrap;\"&gt;\n        &lt;div style=\"text-align:center;padding:10px 18px;border-radius:8px;background:#eff6ff;border:1px solid #bfdbfe;\"&gt;\n          &lt;div style=\"font-size:13px;color:${CP};font-weight:700;margin-bottom:6px;\"&gt;PDF: fix &lt;span style=\"color:${CP}\"&gt;p = ${p.toFixed(2)}&lt;/span&gt;, vary &lt;span style=\"color:${CK}\"&gt;k&lt;/span&gt;&lt;/div&gt;\n          &lt;div style=\"font-size:16px;color:#334155;\"&gt;\n            P(&lt;span style=\"color:${CK};font-weight:700\"&gt;k&lt;/span&gt;)\n            = C(${n}, &lt;span style=\"color:${CK};font-weight:700\"&gt;k&lt;/span&gt;)\n            \\u00D7 ${p.toFixed(2)}&lt;sup style=\"color:${CK};font-weight:700\"&gt;k&lt;/sup&gt;\n            \\u00D7 ${omp}&lt;sup style=\"font-size:13px\"&gt;${n}\\u2212&lt;span style=\"color:${CK};font-weight:700\"&gt;k&lt;/span&gt;&lt;/sup&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div style=\"text-align:center;padding:10px 18px;border-radius:8px;background:#fef2f2;border:1px solid #fecaca;\"&gt;\n          &lt;div style=\"font-size:13px;color:${CK};font-weight:700;margin-bottom:6px;\"&gt;Likelihood: fix &lt;span style=\"color:${CK}\"&gt;k = ${k}&lt;/span&gt;, vary &lt;span style=\"color:${CP}\"&gt;p&lt;/span&gt;&lt;/div&gt;\n          &lt;div style=\"font-size:16px;color:#334155;\"&gt;\n            L(&lt;span style=\"color:${CP};font-weight:700\"&gt;p&lt;/span&gt;)\n            = C(${n}, ${k})\n            \\u00D7 &lt;span style=\"color:${CP};font-weight:700\"&gt;p&lt;/span&gt;&lt;sup&gt;${k}&lt;/sup&gt;\n            \\u00D7 (1\\u2212&lt;span style=\"color:${CP};font-weight:700\"&gt;p&lt;/span&gt;)&lt;sup&gt;${nmk}&lt;/sup&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `;\n  }\n\n  function updateAll() {\n    const n = SL.n.val();\n    const p = SL.p.val();\n    let k = SL.k.val();\n    if (k &gt; n) { SL.k.input.value = n; SL.k.sync(); k = n; }\n\n    styleToggle(btnLik, !showNLL, CK);\n    styleToggle(btnNLL, showNLL, CK);\n\n    updateFormula(n, p, k);\n    renderPDF(panelPDF, n, p, k);\n    renderLik(panelLik, n, p, k);\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 7. EVENTS\n  // ══════════════════════════════════════════════════════\n  function onInput() { SL.n.sync(); SL.p.sync(); SL.k.sync(); updateAll(); }\n  SL.n.input.addEventListener(\"input\", onInput);\n  SL.p.input.addEventListener(\"input\", onInput);\n  SL.k.input.addEventListener(\"input\", onInput);\n  updateAll();\n\n  invalidation.then(() =&gt; {\n    SL.n.input.removeEventListener(\"input\", onInput);\n    SL.p.input.removeEventListener(\"input\", onInput);\n    SL.k.input.removeEventListener(\"input\", onInput);\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "lik.html#định-nghĩa",
    "href": "lik.html#định-nghĩa",
    "title": "9  Hàm hợp lý",
    "section": "",
    "text": "Important\n\n\n\n\nTổng xác suất của mọi dữ liệu \\(x\\) trên một tham số \\(\\theta\\) cố định thì bằng 1 (\\(\\sum_x \\mathbb{P}(x \\mid \\theta) = 1\\)).\nNhưng tổng Likelihood của mọi tham số \\(\\theta\\) trên một dữ liệu \\(x\\) cố định thì không bằng 1 (\\(\\sum_\\theta \\mathcal{L}(\\theta \\mid x) \\neq 1\\)).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "lik.html#đường-cong-hợp-lý",
    "href": "lik.html#đường-cong-hợp-lý",
    "title": "9  Hàm hợp lý",
    "section": "9.2 Đường cong hợp lý",
    "text": "9.2 Đường cong hợp lý",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "lik.html#tỉ-số-hợp-lý",
    "href": "lik.html#tỉ-số-hợp-lý",
    "title": "9  Hàm hợp lý",
    "section": "9.3 Tỉ số hợp lý",
    "text": "9.3 Tỉ số hợp lý\nGiả sử ta có các mô hình \\(\\theta_1, \\theta_2 \\dots\\) và một bộ dữ liệu \\(x\\). Để xác định mô hình nào giải thích dữ liệu tốt hơn, ta so sánh khả năng sinh ra dữ liệu \\(x\\) của từng mô hình.\nTỉ số hợp lý (likelihood ratio) được tính bằng cách chia các giá trị likelihood này cho nhau, nhằm định lượng mức độ ủng hộ của dữ liệu đối với mô hình này so với mô hình kia (Bolker 2008).\n\\[LR = \\frac{\\mathcal{L}(\\theta_1 \\mid x)}{\\mathcal{L}(\\theta_2 \\mid x)}\\]\n\n\\(LR &gt; 1\\): dữ liệu \\(x\\) cho thấy \\(\\theta_1\\) hợp lý hơn\n\\(LR &lt; 1\\): dữ liệu \\(x\\) cho thấy \\(\\theta_2\\) hợp lý hơn",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "lik.html#phép-kiểm-tỉ-số-hợp-lý",
    "href": "lik.html#phép-kiểm-tỉ-số-hợp-lý",
    "title": "9  Hàm hợp lý",
    "section": "9.4 Phép kiểm tỉ số hợp lý",
    "text": "9.4 Phép kiểm tỉ số hợp lý\nPhép kiểm tỉ số hợp lý (Likelihood Ratio Test, LRT) is a procedure to compare two models.\n\\[2 \\left[ \\text{neglog}(\\mathcal{L}_2) - \\text{neglog}(\\mathcal{L}_1) \\right] \\sim \\chi^2_r\\]\nVới \\(r\\) là số parameter đang ước lượng.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "lik.html#khoảng-tin-cậy",
    "href": "lik.html#khoảng-tin-cậy",
    "title": "9  Hàm hợp lý",
    "section": "9.5 Khoảng tin cậy",
    "text": "9.5 Khoảng tin cậy\nNguyên lý: Tìm tập hợp các giá trị tham số sao cho mô hình fit dữ liệu kém hơn mức tối ưu, nhưng nằm trong giới hạn chấp nhận được.\nTheo định lý Wilks, sự chênh lệch log-likelihood tuân theo phân phối Chi-bình phương (\\(\\chi^2\\)).\n\\[2 \\left[ \\text{NLL}(\\theta) - \\text{NLL}_{\\min} \\right] \\le \\chi^2_k(1-\\alpha)\\]\nVới \\(\\text{NLL}_\\text{min}\\) là điểm cực tiểu của \\(NLL\\) tìm được bằng MLE.\n\\[\\text{NLL}_{\\text{cutoff}} = \\text{NLL}_{\\min} + \\frac{\\chi^2_k(1-\\alpha)}{2}\\]\n\nviewof ci_nll_clipped = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. MATH\n  // ══════════════════════════════════════════════════════\n  function lnComb(n, k) {\n    if (k &lt; 0 || k &gt; n) return -Infinity;\n    if (k === 0 || k === n) return 0;\n    let s = 0;\n    for (let i = 0; i &lt; k; i++) s += Math.log(n - i) - Math.log(i + 1);\n    return s;\n  }\n  function binomLogLik(k, n, p) {\n    if (p &lt;= 0) return k === 0 ? 0 : -Infinity;\n    if (p &gt;= 1) return k === n ? 0 : -Infinity;\n    return lnComb(n, k) + k * Math.log(p) + (n - k) * Math.log(1 - p);\n  }\n\n  // Chi-square PDF (df=1)\n  function chi2PDF(x) {\n    if (x &lt;= 0) return 0;\n    return Math.exp(-0.5 * x - 0.5 * Math.log(x) - 0.5 * Math.log(2 * Math.PI));\n  }\n\n  // Chi-square quantile (df=1)\n  function normCDF(z) {\n    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429, pp = 0.3275911;\n    const sign = z &lt; 0 ? -1 : 1;\n    z = Math.abs(z) / Math.SQRT2;\n    const t = 1.0 / (1.0 + pp * z);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);\n    return 0.5 * (1.0 + sign * y);\n  }\n  function chi2CDF(x) {\n    if (x &lt;= 0) return 0;\n    return 2 * normCDF(Math.sqrt(x)) - 1;\n  }\n  function chi2Quantile(cl) {\n    let lo = 0, hi = 30;\n    for (let i = 0; i &lt; 80; i++) {\n      const mid = (lo + hi) / 2;\n      if (chi2CDF(mid) &lt; cl) lo = mid; else hi = mid;\n    }\n    return (lo + hi) / 2;\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:960px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  const COL = { nll: \"#7c3aed\", chi: \"#dc2626\", ci: \"#16a34a\", mle: \"#3b82f6\" };\n\n  // ══════════════════════════════════════════════════════\n  // 4. CONTROLS\n  // ══════════════════════════════════════════════════════\n  const SL = {};\n  SL.n  = createSlider(\"n (trials)\", 5, 100, 1, 20, \"#1e293b\", \"dark\");\n  SL.k  = createSlider(\"k (successes)\", 0, 100, 1, 6, \"#1e293b\", \"dark\");\n  SL.cl = createSlider(\"Confidence level\", 0.50, 0.99, 0.01, 0.95, COL.ci, \"green\");\n\n  const r1 = document.createElement(\"div\"); r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;\";\n  r1.appendChild(SL.n.el); r1.appendChild(SL.k.el);\n  wrapper.appendChild(r1);\n  const r2 = document.createElement(\"div\"); r2.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:16px;\";\n  r2.appendChild(SL.cl.el);\n  const sp = document.createElement(\"div\"); sp.style.cssText = \"flex:1;\";\n  r2.appendChild(sp);\n  wrapper.appendChild(r2);\n\n  // ══════════════════════════════════════════════════════\n  // 5. SVG PANELS\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const PW = 460, PH = 400; // Increased Height\n  // Increased Margins for larger text\n  const mg_ = { t: 90, r: 30, b: 80, l: 80 };\n  const pw_ = PW - mg_.l - mg_.r, ph_ = PH - mg_.t - mg_.b;\n\n  function mkEl(tag, a) {\n    const e = document.createElementNS(NS, tag);\n    if (a) for (const [k,v] of Object.entries(a)) e.setAttribute(k,v);\n    return e;\n  }\n\n  function createPanel(bg) {\n    const svg = document.createElementNS(NS, \"svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${PW} ${PH}`);\n    svg.style.cssText = `flex:1;min-width:0;border-radius:12px;border:1px solid #e2e8f0;background:${bg || \"#fff\"};`;\n\n    // 1. DEFINE CLIP PATH (To fix the horizontal line issue)\n    // This allows the curve to go \"off screen\" mathematically, but visually cut at the border.\n    const defs = document.createElementNS(NS, \"defs\");\n    const clipId = \"chart-clip-\" + Math.random().toString(36).substr(2,9);\n    const clipPath = document.createElementNS(NS, \"clipPath\");\n    clipPath.setAttribute(\"id\", clipId);\n    const clipRect = document.createElementNS(NS, \"rect\");\n    clipRect.setAttribute(\"x\", mg_.l);\n    clipRect.setAttribute(\"y\", mg_.t);\n    clipRect.setAttribute(\"width\", pw_);\n    clipRect.setAttribute(\"height\", ph_);\n    clipPath.appendChild(clipRect);\n    defs.appendChild(clipPath);\n    svg.appendChild(defs);\n\n    // Title Font Size 24\n    const title = mkEl(\"text\", { x: String(PW / 2), y: \"32\", \"text-anchor\": \"middle\", \"font-size\": \"24\", \"font-weight\": \"700\" });\n    svg.appendChild(title);\n    // Subtitle Font Size 18\n    const sub = mkEl(\"text\", { x: String(PW / 2), y: \"58\", \"text-anchor\": \"middle\", \"font-size\": \"18\", fill: \"#64748b\" });\n    svg.appendChild(sub);\n\n    const grids = [];\n    for (let i = 0; i &lt;= 5; i++) { svg.appendChild(mkEl(\"line\", { stroke: \"#f1f5f9\", \"stroke-width\": \"1\" })); grids.push(svg.lastChild); }\n    // Y-Labels Font Size 15\n    const yLbls = [];\n    for (let i = 0; i &lt;= 5; i++) { svg.appendChild(mkEl(\"text\", { \"text-anchor\": \"end\", fill: \"#94a3b8\", \"font-size\": \"15\", \"font-family\": \"'SF Mono',monospace\" })); yLbls.push(svg.lastChild); }\n\n    // Apply Clip Path to curves and fills\n    const fillPath = mkEl(\"path\", { \"stroke-width\": \"0\", \"clip-path\": `url(#${clipId})` }); \n    fillPath.style.display = \"none\"; svg.appendChild(fillPath);\n    \n    const curvePath = mkEl(\"path\", { fill: \"none\", \"stroke-width\": \"3\", \"stroke-linejoin\": \"round\", \"clip-path\": `url(#${clipId})` }); \n    svg.appendChild(curvePath);\n\n    svg.appendChild(mkEl(\"line\", { x1: String(mg_.l), x2: String(mg_.l), y1: String(mg_.t), y2: String(mg_.t + ph_), stroke: \"#cbd5e1\" }));\n    const xAx = mkEl(\"line\", { stroke: \"#cbd5e1\" }); svg.appendChild(xAx);\n\n    // X-Ticks Font Size 15\n    const xTicks = [];\n    for (let i = 0; i &lt; 20; i++) { const t = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"15\", \"font-family\": \"'SF Mono',monospace\" }); t.style.display = \"none\"; svg.appendChild(t); xTicks.push(t); }\n    \n    // Axis Label Font Size 18\n    const xLabel = mkEl(\"text\", { x: String(mg_.l + pw_ / 2), y: String(PH - 12), \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"18\", \"font-weight\": \"600\" });\n    svg.appendChild(xLabel);\n    \n    // Y Axis Label Font Size 18\n    const yLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"18\", \"font-weight\": \"600\" });\n    svg.appendChild(yLabel);\n\n    return { svg, title, sub, grids, yLbls, fillPath, curvePath, xAx, xTicks, xLabel, yLabel, clipId };\n  }\n\n  const pNLL = createPanel(\"#fff\");\n  const pChi = createPanel(\"#fff\");\n\n  const chartRow = document.createElement(\"div\");\n  chartRow.style.cssText = \"display:flex;gap:12px;width:100%;margin-bottom:14px;\";\n  chartRow.appendChild(pNLL.svg); chartRow.appendChild(pChi.svg);\n  wrapper.appendChild(chartRow);\n\n  // ══════════════════════════════════════════════════════\n  // 6. RENDER HELPERS\n  // ══════════════════════════════════════════════════════\n  function setYLabel(panel, text, color) {\n    const lx = 24, ly = mg_.t + ph_ / 2;\n    panel.yLabel.setAttribute(\"x\", lx); panel.yLabel.setAttribute(\"y\", ly);\n    panel.yLabel.setAttribute(\"transform\", `rotate(-90,${lx},${ly})`);\n    panel.yLabel.setAttribute(\"fill\", color);\n    panel.yLabel.textContent = text;\n  }\n\n  function setGrid(panel, minV, maxV, nGrid) {\n    for (let i = 0; i &lt;= nGrid; i++) {\n      const v = minV + (maxV - minV) / nGrid * i;\n      const yy = mg_.t + ph_ - ((v - minV) / ((maxV - minV) || 1)) * ph_;\n      if (i &lt; panel.grids.length) {\n        panel.grids[i].setAttribute(\"x1\", mg_.l); panel.grids[i].setAttribute(\"x2\", PW - mg_.r);\n        panel.grids[i].setAttribute(\"y1\", yy); panel.grids[i].setAttribute(\"y2\", yy);\n        panel.grids[i].style.display = \"\";\n        panel.yLbls[i].setAttribute(\"x\", mg_.l - 10); panel.yLbls[i].setAttribute(\"y\", yy + 5);\n        const fmt = Math.abs(v) &gt; 10 ? v.toFixed(1) : v.toFixed(2);\n        panel.yLbls[i].textContent = fmt;\n        panel.yLbls[i].style.display = \"\";\n      }\n    }\n    for (let i = nGrid + 1; i &lt; panel.grids.length; i++) { panel.grids[i].style.display = \"none\"; panel.yLbls[i].style.display = \"none\"; }\n  }\n\n  function setXAxis(panel) {\n    const baseline = mg_.t + ph_;\n    panel.xAx.setAttribute(\"x1\", mg_.l); panel.xAx.setAttribute(\"x2\", PW - mg_.r);\n    panel.xAx.setAttribute(\"y1\", baseline); panel.xAx.setAttribute(\"y2\", baseline);\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 7. RENDER NLL (left)\n  // ══════════════════════════════════════════════════════\n  const nllHLine = mkEl(\"line\", { \"stroke-width\": \"2\", \"stroke-dasharray\": \"6,4\" });\n  pNLL.svg.appendChild(nllHLine);\n  \n  // Apply clip-path to the CI Fill area too\n  const nllCIFill = mkEl(\"path\", { \"stroke-width\": \"0\", \"clip-path\": `url(#${pNLL.clipId})` }); \n  pNLL.svg.appendChild(nllCIFill);\n  \n  const nllMLELine = mkEl(\"line\", { \"stroke-width\": \"2\", \"stroke-dasharray\": \"4,3\" }); pNLL.svg.appendChild(nllMLELine);\n  const nllMLEDot = mkEl(\"circle\", { r: \"6\", stroke: \"#fff\", \"stroke-width\": \"2\" }); pNLL.svg.appendChild(nllMLEDot);\n  // Annotations 16px\n  const nllMLELabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"700\" }); pNLL.svg.appendChild(nllMLELabel);\n  const nllCILLine = mkEl(\"line\", { \"stroke-width\": \"2\", \"stroke-dasharray\": \"4,3\" }); pNLL.svg.appendChild(nllCILLine);\n  const nllCIRLine = mkEl(\"line\", { \"stroke-width\": \"2\", \"stroke-dasharray\": \"4,3\" }); pNLL.svg.appendChild(nllCIRLine);\n  const nllCILLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"700\" }); pNLL.svg.appendChild(nllCILLabel);\n  const nllCIRLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"700\" }); pNLL.svg.appendChild(nllCIRLabel);\n  const nllCutLabel = mkEl(\"text\", { \"text-anchor\": \"start\", \"font-size\": \"16\", \"font-weight\": \"600\" }); pNLL.svg.appendChild(nllCutLabel);\n  const nllBracket = mkEl(\"line\", { \"stroke-width\": \"3\", \"stroke-linecap\": \"round\" }); pNLL.svg.appendChild(nllBracket);\n  const nllBracketLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"700\" }); pNLL.svg.appendChild(nllBracketLabel);\n\n  function renderNLL(n, k, cl) {\n    const chiQ = chi2Quantile(cl);\n    const cutoff = chiQ / 2;\n    const mle = n &gt; 0 ? k / n : 0.5;\n\n    pNLL.title.textContent = \"Negative Log-Likelihood\";\n    pNLL.title.setAttribute(\"fill\", COL.nll);\n    pNLL.sub.textContent = `n = ${n},  k = ${k},  p\\u0302 = ${mle.toFixed(3)}`;\n    setYLabel(pNLL, \"\\u2212ln L(p) + const\", COL.nll);\n    pNLL.xLabel.textContent = \"p\"; pNLL.xLabel.setAttribute(\"fill\", COL.nll);\n    setXAxis(pNLL);\n\n    const NPTS = 300;\n    const curve = [];\n    const pMin = 0.001, pMax = 0.999;\n    const nllMLE = -binomLogLik(k, n, mle);\n    for (let i = 0; i &lt;= NPTS; i++) {\n      const p = pMin + (pMax - pMin) * i / NPTS;\n      const nll = -binomLogLik(k, n, p) - nllMLE;\n      curve.push({ p, nll });\n    }\n\n    const yMax = Math.max(cutoff * 2.5, 4);\n    const yMin = 0;\n\n    setGrid(pNLL, yMin, yMax, 5);\n\n    const baseline = mg_.t + ph_;\n    const sx = p =&gt; mg_.l + ((p - pMin) / (pMax - pMin)) * pw_;\n    const sy = v =&gt; mg_.t + ph_ - ((v - yMin) / (yMax - yMin)) * ph_;\n\n    for (let i = 0; i &lt; 20; i++) {\n      if (i &lt;= 10) {\n        const v = i / 10;\n        pNLL.xTicks[i].setAttribute(\"x\", sx(v)); pNLL.xTicks[i].setAttribute(\"y\", baseline + 24);\n        pNLL.xTicks[i].textContent = i % 2 === 0 ? v.toFixed(1) : \"\";\n        pNLL.xTicks[i].style.display = \"\";\n      } else { pNLL.xTicks[i].style.display = \"none\"; }\n    }\n\n    // DRAW CURVE (No Math.min clamping, rely on ClipPath)\n    let d = \"\";\n    for (let i = 0; i &lt;= NPTS; i++) {\n      const px = sx(curve[i].p);\n      const py = sy(curve[i].nll); // Just plot the true value!\n      d += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n    }\n    pNLL.curvePath.setAttribute(\"d\", d); pNLL.curvePath.setAttribute(\"stroke\", COL.nll);\n    pNLL.fillPath.style.display = \"none\";\n\n    const mleX = sx(mle), mleY = sy(0);\n    nllMLELine.setAttribute(\"x1\", mleX); nllMLELine.setAttribute(\"x2\", mleX);\n    nllMLELine.setAttribute(\"y1\", sy(0)); nllMLELine.setAttribute(\"y2\", baseline);\n    nllMLELine.setAttribute(\"stroke\", COL.mle);\n    nllMLEDot.setAttribute(\"cx\", mleX); nllMLEDot.setAttribute(\"cy\", mleY);\n    nllMLEDot.setAttribute(\"fill\", COL.mle);\n    nllMLELabel.setAttribute(\"x\", mleX); nllMLELabel.setAttribute(\"y\", mleY - 16);\n    nllMLELabel.setAttribute(\"fill\", COL.mle);\n    nllMLELabel.textContent = `p\\u0302 = ${mle.toFixed(3)}`;\n\n    const cutY = sy(cutoff);\n    nllHLine.setAttribute(\"x1\", mg_.l); nllHLine.setAttribute(\"x2\", PW - mg_.r);\n    nllHLine.setAttribute(\"y1\", cutY); nllHLine.setAttribute(\"y2\", cutY);\n    nllHLine.setAttribute(\"stroke\", COL.ci);\n\n    nllCutLabel.setAttribute(\"x\", PW - mg_.r - 2); nllCutLabel.setAttribute(\"y\", cutY - 8);\n    nllCutLabel.setAttribute(\"text-anchor\", \"end\");\n    nllCutLabel.setAttribute(\"fill\", COL.ci);\n    nllCutLabel.textContent = `\\u03C7\\u00B2 / 2 = ${cutoff.toFixed(3)}`;\n\n    let ciLo = pMin, ciHi = pMax;\n    {\n      let lo = pMin, hi = mle;\n      for (let iter = 0; iter &lt; 80; iter++) {\n        const mid = (lo + hi) / 2;\n        const nll = -binomLogLik(k, n, mid) - nllMLE;\n        if (nll &gt; cutoff) lo = mid; else hi = mid;\n      }\n      ciLo = (lo + hi) / 2;\n    }\n    {\n      let lo = mle, hi = pMax;\n      for (let iter = 0; iter &lt; 80; iter++) {\n        const mid = (lo + hi) / 2;\n        const nll = -binomLogLik(k, n, mid) - nllMLE;\n        if (nll &gt; cutoff) hi = mid; else lo = mid;\n      }\n      ciHi = (lo + hi) / 2;\n    }\n\n    let dFill = `M${sx(ciLo).toFixed(1)},${baseline}`;\n    for (let i = 0; i &lt;= NPTS; i++) {\n      if (curve[i].p &gt;= ciLo && curve[i].p &lt;= ciHi) {\n        // Use true value, let clip-path handle the cutoff top\n        dFill += `L${sx(curve[i].p).toFixed(1)},${sy(curve[i].nll).toFixed(1)}`;\n      }\n    }\n    dFill += `L${sx(ciHi).toFixed(1)},${baseline}Z`;\n    nllCIFill.setAttribute(\"d\", dFill);\n    nllCIFill.setAttribute(\"fill\", COL.ci); nllCIFill.setAttribute(\"opacity\", \"0.12\");\n    nllCIFill.style.display = \"\";\n\n    const cLoX = sx(ciLo), cHiX = sx(ciHi);\n    nllCILLine.setAttribute(\"x1\", cLoX); nllCILLine.setAttribute(\"x2\", cLoX);\n    nllCILLine.setAttribute(\"y1\", cutY); nllCILLine.setAttribute(\"y2\", baseline);\n    nllCILLine.setAttribute(\"stroke\", COL.ci);\n    nllCIRLine.setAttribute(\"x1\", cHiX); nllCIRLine.setAttribute(\"x2\", cHiX);\n    nllCIRLine.setAttribute(\"y1\", cutY); nllCIRLine.setAttribute(\"y2\", baseline);\n    nllCIRLine.setAttribute(\"stroke\", COL.ci);\n\n    // 95% CI text above the line, increase the number to make it go down\n    nllCILLabel.setAttribute(\"x\", cLoX); nllCILLabel.setAttribute(\"y\", baseline + 40);\n    nllCILLabel.setAttribute(\"fill\", COL.ci); nllCILLabel.textContent = ciLo.toFixed(3);\n    nllCIRLabel.setAttribute(\"x\", cHiX); nllCIRLabel.setAttribute(\"y\", baseline + 40);\n    nllCIRLabel.setAttribute(\"fill\", COL.ci); nllCIRLabel.textContent = ciHi.toFixed(3);\n\n    const bracketY = baseline + 48;\n    nllBracket.setAttribute(\"x1\", cLoX); nllBracket.setAttribute(\"x2\", cHiX);\n    nllBracket.setAttribute(\"y1\", bracketY); nllBracket.setAttribute(\"y2\", bracketY);\n    nllBracket.setAttribute(\"stroke\", COL.ci);\n    nllBracketLabel.setAttribute(\"x\", (cLoX + cHiX) / 2); nllBracketLabel.setAttribute(\"y\", bracketY + 18);\n    nllBracketLabel.setAttribute(\"fill\", COL.ci);\n    nllBracketLabel.textContent = `${(cl * 100).toFixed(0)}% CI`;\n\n    return { ciLo, ciHi, mle, chiQ, cutoff };\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 8. RENDER CHI-SQUARE (right)\n  // ══════════════════════════════════════════════════════\n  const chiCritLine = mkEl(\"line\", { \"stroke-width\": \"2.5\" }); pChi.svg.appendChild(chiCritLine);\n  const chiCritDot = mkEl(\"circle\", { r: \"6\", stroke: \"#fff\", \"stroke-width\": \"2\" }); pChi.svg.appendChild(chiCritDot);\n  const chiCritLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"700\" }); pChi.svg.appendChild(chiCritLabel);\n  const chiAreaLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"16\", \"font-weight\": \"600\" }); pChi.svg.appendChild(chiAreaLabel);\n  // Apply clip path to shade too\n  const chiShade = mkEl(\"path\", { \"stroke-width\": \"0\", \"clip-path\": `url(#${pChi.clipId})` }); \n  pChi.svg.insertBefore(chiShade, pChi.curvePath);\n\n  function renderChi(cl, chiQ) {\n    pChi.title.textContent = \"Chi-Squared Distribution (df = 1)\";\n    pChi.title.setAttribute(\"fill\", COL.chi);\n    pChi.sub.textContent = `Critical value at ${(cl * 100).toFixed(0)}% level`;\n    setYLabel(pChi, \"f(x)\", COL.chi);\n    pChi.xLabel.textContent = \"x\"; pChi.xLabel.setAttribute(\"fill\", COL.chi);\n    setXAxis(pChi);\n\n    const xMax = Math.max(chiQ * 2, 6);\n    const NPTS = 300;\n    const curve = [];\n    for (let i = 0; i &lt;= NPTS; i++) {\n      const x = 0.01 + (xMax - 0.01) * i / NPTS;\n      curve.push({ x, y: chi2PDF(x) });\n    }\n    const yMax = Math.min(2.0, Math.max(...curve.map(c =&gt; c.y)) * 1.1);\n    const yMin = 0;\n\n    setGrid(pChi, yMin, yMax, 5);\n\n    const baseline = mg_.t + ph_;\n    const sxC = x =&gt; mg_.l + (x / xMax) * pw_;\n    const syC = y =&gt; mg_.t + ph_ - ((y - yMin) / ((yMax - yMin) || 1)) * ph_;\n\n    const xStep = xMax &gt; 10 ? 2 : 1;\n    for (let i = 0; i &lt; 20; i++) {\n      const v = i * xStep;\n      if (v &lt;= xMax) {\n        pChi.xTicks[i].setAttribute(\"x\", sxC(v)); pChi.xTicks[i].setAttribute(\"y\", baseline + 24);\n        pChi.xTicks[i].textContent = v;\n        pChi.xTicks[i].style.display = \"\";\n      } else { pChi.xTicks[i].style.display = \"none\"; }\n    }\n\n    let d = \"\";\n    for (let i = 0; i &lt;= NPTS; i++) {\n      const px = sxC(curve[i].x), py = syC(curve[i].y);\n      d += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n    }\n    pChi.curvePath.setAttribute(\"d\", d); pChi.curvePath.setAttribute(\"stroke\", COL.chi);\n\n    let dShade = \"\";\n    let started = false;\n    for (let i = 0; i &lt;= NPTS; i++) {\n      if (curve[i].x &gt;= chiQ) {\n        const px = sxC(curve[i].x), py = syC(curve[i].y);\n        if (!started) { dShade = `M${px.toFixed(1)},${baseline}`; started = true; }\n        dShade += `L${px.toFixed(1)},${py.toFixed(1)}`;\n      }\n    }\n    dShade += `L${sxC(xMax).toFixed(1)},${baseline}Z`;\n    chiShade.setAttribute(\"d\", dShade); chiShade.setAttribute(\"fill\", COL.chi);\n    chiShade.setAttribute(\"opacity\", \"0.15\"); chiShade.style.display = \"\";\n\n    let dBody = `M${sxC(0.01).toFixed(1)},${baseline}`;\n    for (let i = 0; i &lt;= NPTS; i++) {\n      if (curve[i].x &lt;= chiQ) {\n        const px = sxC(curve[i].x), py = syC(curve[i].y);\n        dBody += `L${px.toFixed(1)},${py.toFixed(1)}`;\n      }\n    }\n    dBody += `L${sxC(chiQ).toFixed(1)},${baseline}Z`;\n    pChi.fillPath.setAttribute(\"d\", dBody); pChi.fillPath.setAttribute(\"fill\", COL.ci);\n    pChi.fillPath.setAttribute(\"opacity\", \"0.1\"); pChi.fillPath.style.display = \"\";\n\n    const critX = sxC(chiQ), critY = syC(Math.min(chi2PDF(chiQ), yMax));\n    chiCritLine.setAttribute(\"x1\", critX); chiCritLine.setAttribute(\"x2\", critX);\n    chiCritLine.setAttribute(\"y1\", critY); chiCritLine.setAttribute(\"y2\", baseline);\n    chiCritLine.setAttribute(\"stroke\", COL.ci);\n    chiCritDot.setAttribute(\"cx\", critX); chiCritDot.setAttribute(\"cy\", critY);\n    chiCritDot.setAttribute(\"fill\", COL.ci);\n\n    chiCritLabel.setAttribute(\"x\", critX); chiCritLabel.setAttribute(\"y\", critY - 16);\n    chiCritLabel.setAttribute(\"fill\", COL.ci);\n    chiCritLabel.textContent = `\\u03C7\\u00B2 = ${chiQ.toFixed(3)}`;\n\n    const bodyMidX = sxC(chiQ * 0.4);\n    chiAreaLabel.setAttribute(\"x\", bodyMidX); chiAreaLabel.setAttribute(\"y\", baseline - 10);\n    chiAreaLabel.setAttribute(\"fill\", COL.ci);\n    chiAreaLabel.textContent = `${(cl * 100).toFixed(0)}%`;\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 9. UPDATE\n  // ══════════════════════════════════════════════════════\n  function updateAll() {\n    const n = SL.n.val();\n    let k = SL.k.val();\n    if (k &gt; n) { SL.k.input.value = n; SL.k.sync(); k = n; }\n    const cl = SL.cl.val();\n\n    const { ciLo, ciHi, mle, chiQ, cutoff } = renderNLL(n, k, cl);\n    renderChi(cl, chiQ);\n  }\n\n  function onInput() { SL.n.sync(); SL.k.sync(); SL.cl.sync(); updateAll(); }\n  SL.n.input.addEventListener(\"input\", onInput);\n  SL.k.input.addEventListener(\"input\", onInput);\n  SL.cl.input.addEventListener(\"input\", onInput);\n  updateAll();\n\n  invalidation.then(() =&gt; {\n    SL.n.input.removeEventListener(\"input\", onInput);\n    SL.k.input.removeEventListener(\"input\", onInput);\n    SL.cl.input.removeEventListener(\"input\", onInput);\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()\n\n\n\n\n\n\nKhoảng tin cậy đo lường mức độ không chắc chắn của tham số ước lượng. Khoảng tin cậy 95% \\([\\theta_{\\text{lower}}, \\theta_{\\text{upper}}]\\) của 1 tham số ước lượng \\(\\hat{\\theta}\\) được diễn giải là: giá trị thực \\(\\theta^*\\) nằm trong \\([\\theta_{\\text{lower}}, \\theta_{\\text{upper}}]\\) với xác suất là 95% (Raue et al. 2010).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "lik.html#tính-định-danh",
    "href": "lik.html#tính-định-danh",
    "title": "9  Hàm hợp lý",
    "section": "9.6 Tính định danh",
    "text": "9.6 Tính định danh\nTính định danh (identifiability) của một tham số \\(\\theta_i\\) được định nghĩa như sau (Raue et al. 2010):\n\nTính định danh cấu trúc (structurally identifiable): nếu ước lượng \\(\\hat{\\theta}_i\\) của nó là cực tiểu duy nhất của hàm \\(\\chi^2(\\theta)\\).\nTính định danh thực tế (practically identifiable) nếu khoảng tin cậy của ước lượng đó là hữu hạn.\nKhông định danh được (nonidentifiable) khi khoảng tin cậy của nó là vô hạn.\n\n\n\n\n\nBolker, Benjamin M. 2008. Ecological Models and Data in R. Princeton University Press. https://doi.org/10.1515/9781400840908.\n\n\nRaue, A., V. Becker, U. Klingmüller, and J. Timmer. 2010. “Identifiability and Observability Analysis for Experimental Design in Nonlinear Dynamical Models.” Chaos: An Interdisciplinary Journal of Nonlinear Science 20 (4): 045105. https://doi.org/10.1063/1.3528102.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Hàm hợp lý</span>"
    ]
  },
  {
    "objectID": "bayes.html",
    "href": "bayes.html",
    "title": "10  Bayesian",
    "section": "",
    "text": "10.1 Xác suất có điều kiện\nXác suất có điều kiện thực chất là thu nhỏ không gian mẫu.\nVí dụ, tại một ngôi trường có 3 lớp A, B, C với số lượng học sinh như sau:\nChọn ngẫu nhiên 1 học sinh trong trường.\n1. Xác suất không điều kiện\nTính xác suất học sinh này là Nữ?\nLúc này không gian mẫu là toàn bộ ngôi trường.\n\\[\\mathbb{P}(\\text{Nữ}) = \\frac{\\overbrace{55}^{\\text{Tổng số Nữ toàn trường}}}{\\underbrace{120}_{\\text{Tổng số học sinh toàn trường}}} \\approx 45.8\\%\\]\n2. Xác suất có điều kiện\nBiết rằng học sinh được chọn ở Lớp A. Tính xác suất học sinh này là Nữ?\nThông tin “Học sinh Lớp A” đã làm thu nhỏ không gian mẫu. Không gian mẫu lúc này chỉ là Học sinh lớp A thôi.\n\\[\\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) = \\frac{\\overbrace{10}^{\\text{Số Nữ trong Lớp A}}}{\\underbrace{40}_{\\text{Tổng sĩ số Lớp A}}} = 25.0\\%\\]\nviewof classroom_prob_sharp = (() =&gt; {\n  // --- 1. SETUP ---\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    margin-top: 20px;\n    width: 100%;\n    max-width: 800px;\n    margin-left: auto;\n    margin-right: auto;\n  `;\n\n  // --- 2. DATA ---\n  const CLASSES = {\n    A: { boys: 30, girls: 10, color: \"#ef4444\" }, \n    B: { boys: 20, girls: 20, color: \"#3b82f6\" }, \n    C: { boys: 15, girls: 25, color: \"#10b981\" } \n  };\n  \n  const students = [];\n  Object.keys(CLASSES).forEach(cls =&gt; {\n    const data = CLASSES[cls];\n    for(let i=0; i&lt;data.boys; i++) students.push({ id: `b-${cls}-${i}`, cls: cls, gender: \"Nam\", color: data.color });\n    for(let i=0; i&lt;data.girls; i++) students.push({ id: `g-${cls}-${i}`, cls: cls, gender: \"Nữ\", color: data.color });\n  });\n\n  // --- 3. CONTROLS ---\n  const controlPanel = document.createElement(\"div\");\n  controlPanel.style.cssText = `\n    background: #ffffff;\n    border: 1px solid #e2e8f0;\n    border-radius: 12px;\n    padding: 16px;\n    margin-bottom: 24px;\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n    gap: 12px;\n    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);\n    width: 100%;\n    box-sizing: border-box;\n  `;\n\n  function createSelect(options) {\n    const sel = document.createElement(\"select\");\n    sel.style.cssText = `\n      padding: 8px 12px;\n      border-radius: 8px;\n      border: 1px solid #d1d5db;\n      background-color: #f9fafb;\n      font-size: 14px;\n      font-weight: 600;\n      color: #1e293b;\n      cursor: pointer;\n    `;\n    options.forEach(opt =&gt; {\n      const el = document.createElement(\"option\");\n      el.value = opt.val;\n      el.textContent = opt.label;\n      sel.appendChild(el);\n    });\n    return sel;\n  }\n\n  const targetOpts = [\n    {val: \"Nam\", label: \"Học sinh Nam\"},\n    {val: \"Nữ\", label: \"Học sinh Nữ\"},\n    {val: \"A\", label: \"Học sinh Lớp A\"},\n    {val: \"B\", label: \"Học sinh Lớp B\"},\n    {val: \"C\", label: \"Học sinh Lớp C\"}\n  ];\n\n  const givenOpts = [\n    {val: \"Universe\", label: \"Toàn trường\"},\n    {val: \"A\", label: \"Học sinh Lớp A\"},\n    {val: \"B\", label: \"Học sinh Lớp B\"},\n    {val: \"C\", label: \"Học sinh Lớp C\"},\n    {val: \"Nam\", label: \"Đó là Nam\"},\n    {val: \"Nữ\", label: \"Đó là Nữ\"}\n  ];\n\n  const selTarget = createSelect(targetOpts);\n  const selGiven = createSelect(givenOpts);\n  selTarget.value = \"Nữ\";\n  selGiven.value = \"A\";\n\n  const t1 = document.createElement(\"span\"); t1.textContent = \"Tính xác suất chọn\"; t1.style.color = \"#334155\";\n  const t2 = document.createElement(\"span\"); t2.textContent = \"biết rằng\"; t2.style.color = \"#334155\";\n\n  controlPanel.appendChild(t1);\n  controlPanel.appendChild(selTarget);\n  controlPanel.appendChild(t2);\n  controlPanel.appendChild(selGiven);\n  wrapper.appendChild(controlPanel);\n\n  // --- 4. CANVAS (High Resolution) ---\n  const canvas = document.createElement(\"canvas\");\n  const logicalW = 800;\n  const logicalH = 340; \n  \n  // Set Display Size (CSS)\n  canvas.style.width = `${logicalW}px`;\n  canvas.style.height = `${logicalH}px`;\n  // Responsive Max Width\n  canvas.style.maxWidth = \"100%\";\n  canvas.style.height = \"auto\";\n  \n  // Set Actual Pixel Size (High DPI)\n  const dpr = window.devicePixelRatio || 1;\n  canvas.width = logicalW * dpr;\n  canvas.height = logicalH * dpr;\n  \n  const ctx = canvas.getContext(\"2d\");\n  // Scale drawing operations so we can use logical coordinates\n  ctx.scale(dpr, dpr);\n  wrapper.appendChild(canvas);\n\n  // --- 5. MATH PANEL ---\n  const mathDiv = document.createElement(\"div\");\n  mathDiv.style.cssText = `\n    font-size: 18px;\n    margin-top: 20px; \n    margin-bottom: 10px;\n    text-align: center;\n    line-height: 1.6;\n    width: 100%;\n  `;\n  wrapper.appendChild(mathDiv);\n\n  // --- 6. GEOMETRY PRE-CALCULATION ---\n  const boxW = 180;\n  const boxH = 300; \n  const gap = 24;   \n  const startX = (logicalW - (3 * boxW + 2 * gap)) / 2;\n  const startY = 10;\n\n  const dotCols = 5;\n  const dotDiam = 13;   \n  const dotGap = 13;    \n  const gridWidth = (dotCols * dotDiam) + ((dotCols - 1) * dotGap);\n  const dotRad = dotDiam / 2;\n\n  const posMap = {}; \n  ['A', 'B', 'C'].forEach((cls, i) =&gt; {\n     const clsStudents = students.filter(s =&gt; s.cls === cls);\n     const bx = startX + i * (boxW + gap);\n     const by = startY;\n     const gridStartX = bx + (boxW - gridWidth) / 2 + dotRad;\n     const gridStartY = by + 80; \n     \n     clsStudents.forEach((s, idx) =&gt; {\n        const c = idx % dotCols;\n        const r = Math.floor(idx / dotCols);\n        posMap[s.id] = {\n            x: gridStartX + c * (dotDiam + dotGap),\n            y: gridStartY + r * (dotDiam + dotGap),\n            bx: bx, by: by \n        };\n     });\n  });\n\n  // --- 7. LOGIC ---\n  function check(student, condition) {\n    if (condition === \"Universe\") return true;\n    if (condition === \"A\" || condition === \"B\" || condition === \"C\") return student.cls === condition;\n    if (condition === \"Nam\" || condition === \"Nữ\") return student.gender === condition;\n    return false;\n  }\n\n  function update() {\n    const targetCond = selTarget.value;\n    const givenCond = selGiven.value;\n    const validUniverse = students.filter(s =&gt; check(s, givenCond));\n    const validTarget = validUniverse.filter(s =&gt; check(s, targetCond));\n    const num = validTarget.length;\n    const den = validUniverse.length;\n    const prob = den === 0 ? 0 : ((num / den) * 100).toFixed(1);\n\n    const dict = {\n        \"Nam\": \"Nam\", \"Nữ\": \"Nữ\",\n        \"A\": \"Lớp A\", \"B\": \"Lớp B\", \"C\": \"Lớp C\",\n        \"Universe\": \"Toàn trường\"\n    };\n\n    // Cleaned up text, 18px base size\n    mathDiv.innerHTML = `\n      &lt;div style=\"display:inline-block; padding: 15px 30px; background:#f8fafc; border-radius:12px; border:1px solid #e2e8f0;\"&gt;\n        &lt;div style=\"font-size: 18px; color:#0f172a; line-height: 1.4;\"&gt;\n          P(${dict[targetCond] || targetCond} | ${dict[givenCond] || givenCond}) = \n          &lt;span style=\"color: #be185d; font-weight: bold;\"&gt;${num}&lt;/span&gt; \n          / \n          &lt;span style=\"color: #0f172a; font-weight: bold;\"&gt;${den}&lt;/span&gt; \n          = &lt;b&gt;${prob}%&lt;/b&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `;\n\n    drawScene(givenCond, targetCond, validUniverse, validTarget);\n  }\n\n  function drawScene(given, target, universeSet, targetSet) {\n    ctx.clearRect(0, 0, logicalW, logicalH);\n    \n    // Draw Boxes\n    ['A', 'B', 'C'].forEach((cls, i) =&gt; {\n       const bx = startX + i * (boxW + gap);\n       const by = startY;\n       const boxHasUniverse = universeSet.some(s =&gt; s.cls === cls);\n       \n       if (given === cls) {\n           ctx.fillStyle = \"#eff6ff\"; ctx.strokeStyle = \"#3b82f6\"; ctx.lineWidth = 3;\n           ctx.shadowColor = \"rgba(59, 130, 246, 0.15)\"; ctx.shadowBlur = 15; ctx.shadowOffsetY = 4;\n       } else if (boxHasUniverse) {\n           ctx.fillStyle = \"#ffffff\"; ctx.strokeStyle = \"#cbd5e1\"; ctx.lineWidth = 1.5;\n           ctx.shadowColor = \"rgba(0,0,0,0)\";\n       } else {\n           ctx.fillStyle = \"#f8fafc\"; ctx.strokeStyle = \"#e2e8f0\"; ctx.lineWidth = 1;\n           ctx.shadowColor = \"rgba(0,0,0,0)\";\n       }\n\n       ctx.beginPath();\n       ctx.roundRect(bx, by, boxW, boxH, 16);\n       ctx.fill();\n       ctx.stroke();\n       ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n       // Text\n       ctx.textAlign = \"center\";\n       ctx.fillStyle = boxHasUniverse ? \"#1e293b\" : \"#cbd5e1\";\n       ctx.font = \"bold 20px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\";\n       ctx.fillText(`Lớp ${cls}`, bx + boxW/2, by + 35);\n       \n       const count = CLASSES[cls];\n       ctx.font = \"500 13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\";\n       ctx.fillStyle = boxHasUniverse ? \"#64748b\" : \"#e2e8f0\";\n       ctx.fillText(`${count.boys} Nam • ${count.girls} Nữ`, bx + boxW/2, by + 56);\n       \n       if (boxHasUniverse) {\n         ctx.beginPath(); ctx.strokeStyle = \"#f1f5f9\"; ctx.lineWidth = 1;\n         ctx.moveTo(bx + 30, by + 68); ctx.lineTo(bx + boxW - 30, by + 68); ctx.stroke();\n       }\n    });\n\n    // Draw Students\n    students.forEach(s =&gt; {\n        const pos = posMap[s.id];\n        const isUniverse = universeSet.includes(s);\n        const isTarget = targetSet.includes(s);\n\n        let alpha = 0.1;\n        let radius = 6;\n        let color = \"#e5e7eb\"; \n\n        if (isUniverse) {\n            alpha = 0.4;\n            color = s.gender === \"Nam\" ? \"#60a5fa\" : \"#f472b6\"; \n        }\n        \n        if (isTarget) {\n            alpha = 1.0; \n            radius = 7.5;\n            color = s.gender === \"Nam\" ? \"#2563eb\" : \"#db2777\";\n        } else if (!isUniverse) {\n             color = \"#f1f5f9\"; \n        }\n\n        ctx.globalAlpha = alpha;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(pos.x, pos.y, radius, 0, Math.PI*2);\n        ctx.fill();\n\n        if (isTarget) {\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = \"#ffffff\";\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.arc(pos.x, pos.y, radius + 1.5, 0, Math.PI*2);\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.4;\n            ctx.stroke();\n        }\n    });\n    ctx.globalAlpha = 1.0;\n  }\n\n  selTarget.addEventListener(\"change\", update);\n  selGiven.addEventListener(\"change\", update);\n  \n  update();\n\n  return wrapper;\n})();",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#xác-suất-có-điều-kiện",
    "href": "bayes.html#xác-suất-có-điều-kiện",
    "title": "10  Bayesian",
    "section": "",
    "text": "Nam\nNữ\nTổng\n\n\n\n\nLớp A\n30\n10\n40\n\n\nLớp B\n20\n20\n40\n\n\nLớp C\n15\n25\n40\n\n\nTổng\n65\n55\n120",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#định-lý-bayes",
    "href": "bayes.html#định-lý-bayes",
    "title": "10  Bayesian",
    "section": "10.2 Định lý Bayes",
    "text": "10.2 Định lý Bayes\nTrong ví dụ chọn ngẫu nhiên 1 học sinh trong trường, chúng ta có hai câu hỏi trái ngược nhau:\n\nNếu đã biết là học sinh Lớp A, xác suất đó là Nữ là bao nhiêu?\n\n\\[\\begin{aligned}\n\\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) &= \\frac{\\text{Số Nữ trong Lớp A}}{\\text{Tổng sĩ số Lớp A}} \\\\[10pt]\n\\Leftrightarrow \\text{Số Nữ trong Lớp A} &= \\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) \\times \\text{Tổng sĩ số Lớp A} \\quad (1)\n\\end{aligned}\\]\n\nNếu đã biết là Nữ, xác suất đó là học sinh Lớp A là bao nhiêu?\n\n\\[\\begin{aligned}\n\\mathbb{P}(\\text{Lớp A} \\mid \\text{Nữ}) &= \\frac{\\text{Số Nữ trong Lớp A}}{\\text{Tổng số Nữ toàn trường}} \\\\[10pt]\n\\Leftrightarrow \\text{Số Nữ trong Lớp A} &= \\mathbb{P}(\\text{Lớp A} \\mid \\text{Nữ}) \\times \\text{Tổng số Nữ toàn trường} \\quad (2)\n\\end{aligned}\\]\nTừ \\((1)\\) và \\((2)\\) ta thấy vế trái đều là \\(\\text{Số Nữ trong Lớp A}\\), vậy:\n\\[\\begin{aligned}\n\\mathbb{P}(\\text{Lớp A} \\mid \\text{Nữ}) \\times \\text{Tổng Nữ} &= \\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) \\times \\text{Tổng Lớp A} \\\\[10pt]\n\\Leftrightarrow \\mathbb{P}(\\text{Lớp A} \\mid \\text{Nữ}) &= \\frac{\\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) \\times \\text{Tổng Lớp A}}{\\text{Tổng Nữ}}\n\\end{aligned}\\]\nChia cả Tử số và Mẫu số cho Tổng số học sinh toàn trường:\n\\[\\begin{aligned}\n\\mathbb{P}(\\text{Lớp A} \\mid \\text{Nữ}) &= \\frac{\\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) \\times \\text{Tổng Lớp A}}{\\text{Tổng Nữ}} \\\\\n&= \\frac{\\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) \\times \\frac{\\text{Tổng Lớp A}}{\\text{Tổng HS}}}{\\frac{\\text{Tổng Nữ}}{\\text{Tổng HS}}} \\\\\n&= \\frac{\\mathbb{P}(\\text{Nữ} \\mid \\text{Lớp A}) \\times \\mathbb{P}(\\text{Lớp A})}{\\mathbb{P}(\\text{Nữ})} \\quad (3)\n\\end{aligned}\\]\nĐặt \\(A = \\text{Lớp A}\\), \\(B = \\text{Nữ}\\). Thay vào \\((3)\\), ta có Định lý Bayes:\n\\[\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(B \\mid A) \\times \\mathbb{P}(A)}{\\mathbb{P}(B)}\\]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#ví-dụ",
    "href": "bayes.html#ví-dụ",
    "title": "10  Bayesian",
    "section": "10.3 Ví dụ",
    "text": "10.3 Ví dụ\nBạn đang muốn tìm một đối tượng để hẹn hò nghiêm túc. Bạn có 2 ứng viên mập mờ tiềm năng: A và B. Bạn cần quyết định chọn ai trong 2 người để thực sự nghiêm túc.\nTrước khi đi hẹn hò, bạn đã có sẵn một thiên kiến ban đầu. Có thể bạn hơi nghiêng về A vì cả hai có nhiều sở thích chung hơn, hoặc có thể bạn hoàn toàn trung lập.\n\nHãy hình dung một hình vuông lớn đại diện cho 100% niềm tin của bạn\nHình vuông này được chia làm 2 phần, bên trái dành cho A bên phải dành cho B\nChiều rộng của mỗi ô là thiên kiến ban đầu, trong thống kê Bayesian gọi là Xác suất tiên nghiệm (Prior) của bạn đối với mỗi người\n\nBạn quyết định đi date với từng người để thu thập dữ liệu thực tế. Sau khi đi date, bạn chấm điểm buổi date đó.\n\nPhần được tô màu là điểm buổi date của từng người, trong thống kê Bayesian gọi là Hàm khả năng (Likelihood)\n\nSau khi đã đi date với từng người, bạn muốn tính xác suất mình nên chọn A \\(\\mathbb{P}(A|Date)\\)\n\nTư duy Bayes: Chúng ta so sánh Diện tích tô màu của A so với B. Đây là Xác suất hậu nghiệm (Posterior).\n\nBiểu đồ này được tạo theo phương pháp trong video Bayes theorem, the geometry of changing beliefs của kênh 3Blue1Brown.\n\nviewof bayes_mosaic = (() =&gt; {\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:700px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  // ══════════════════════════════════════════════════════\n  // PALETTE (light theme)\n  // ══════════════════════════════════════════════════════\n  const COL = {\n    likeA:   \"#60a5fa\",  // blue-400  — Thích A\n    unlikeA: \"#bfdbfe\",  // blue-200  — Không thích A\n    likeB:   \"#f59e0b\",  // amber-500 — Thích B\n    unlikeB: \"#fde68a\",  // amber-200 — Không thích B\n    txtA:    \"#1d4ed8\",  // blue-700\n    txtB:    \"#b45309\",  // amber-700\n    grid:    \"#e2e8f0\",\n    fg:      \"#1e293b\",\n    fgSub:   \"#64748b\",\n  };\n\n  // ══════════════════════════════════════════════════════\n  // CONTROLS\n  // ══════════════════════════════════════════════════════\n  const SL = {};\n  SL.prior = createSlider(\"P(A)  — Prior\", 0.05, 0.95, 0.05, 0.50, COL.txtA, \"blue\");\n  SL.likA  = createSlider(\"P(Date | A)  — Likelihood A\", 0.05, 0.95, 0.05, 0.80, COL.txtA, \"blue\");\n  SL.likB  = createSlider(\"P(Date | B)  — Likelihood B\", 0.05, 0.95, 0.05, 0.15, COL.txtB, \"amber\");\n\n  const r1 = document.createElement(\"div\"); r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;\";\n  r1.appendChild(SL.prior.el);\n  wrapper.appendChild(r1);\n  const r2 = document.createElement(\"div\"); r2.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:16px;\";\n  r2.appendChild(SL.likA.el); r2.appendChild(SL.likB.el);\n  wrapper.appendChild(r2);\n\n  // ══════════════════════════════════════════════════════\n  // SVG\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const W = 620, H = 480;\n  const mg = { t: 55, r: 80, b: 25, l: 80 };\n  const pw = W - mg.l - mg.r, ph = H - mg.t - mg.b;\n\n  function mkEl(tag, a) {\n    const e = document.createElementNS(NS, tag);\n    if (a) for (const [k,v] of Object.entries(a)) e.setAttribute(k,v);\n    return e;\n  }\n\n  const svg = document.createElementNS(NS, \"svg\");\n  svg.setAttribute(\"viewBox\", `0 0 ${W} ${H}`);\n  svg.style.cssText = `width:100%;max-width:${W}px;border-radius:12px;border:1px solid #e2e8f0;margin-bottom:16px;`;\n\n  // White background\n  svg.appendChild(mkEl(\"rect\", { x: \"0\", y: \"0\", width: String(W), height: String(H), fill: \"#ffffff\", rx: \"12\" }));\n\n  // 4 mosaic rects\n  const boxes = [];\n  for (let i = 0; i &lt; 4; i++) {\n    const r = mkEl(\"rect\", { stroke: \"#fff\", \"stroke-width\": \"2\", rx: \"3\" });\n    svg.appendChild(r); boxes.push(r);\n  }\n\n  // Labels\n  const lbls = [];\n  for (let i = 0; i &lt; 4; i++) {\n    const t = mkEl(\"text\", { \"text-anchor\": \"middle\", \"dominant-baseline\": \"middle\", \"font-size\": \"15\", \"font-weight\": \"700\" });\n    svg.appendChild(t); lbls.push(t);\n  }\n  // Area sub-labels\n  const aLbls = [];\n  for (let i = 0; i &lt; 4; i++) {\n    const t = mkEl(\"text\", { \"text-anchor\": \"middle\", \"dominant-baseline\": \"middle\", \"font-size\": \"12\", \"font-family\": \"'SF Mono',monospace\" });\n    svg.appendChild(t); aLbls.push(t);\n  }\n\n  // ── Top annotation ──\n  const topLine = mkEl(\"line\", { stroke: COL.fg, \"stroke-width\": \"2\" }); svg.appendChild(topLine);\n  const topText = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: COL.fg, \"font-size\": \"15\", \"font-weight\": \"700\" }); svg.appendChild(topText);\n\n  // ── Left annotation ──\n  const leftLine = mkEl(\"line\", { stroke: COL.txtA, \"stroke-width\": \"2\" }); svg.appendChild(leftLine);\n  const leftText = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: COL.txtA, \"font-size\": \"14\", \"font-weight\": \"700\" }); svg.appendChild(leftText);\n\n  // ── Right annotation ──\n  const rightLine = mkEl(\"line\", { stroke: COL.txtB, \"stroke-width\": \"2\" }); svg.appendChild(rightLine);\n  const rightText = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: COL.txtB, \"font-size\": \"14\", \"font-weight\": \"700\" }); svg.appendChild(rightText);\n\n  wrapper.appendChild(svg);\n\n  // ══════════════════════════════════════════════════════\n  // FORMULA\n  // ══════════════════════════════════════════════════════\n  const formulaBox = document.createElement(\"div\");\n  formulaBox.style.cssText = `\n    width:100%;padding:16px 20px;border-radius:12px;\n    background:#f8fafc;border:1px solid #e2e8f0;\n    display:flex;align-items:center;justify-content:center;gap:8px;flex-wrap:wrap;\n    font-size:18px;font-weight:700;color:${COL.fg};\n    font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;\n  `;\n  wrapper.appendChild(formulaBox);\n\n  // ══════════════════════════════════════════════════════\n  // UPDATE\n  // ══════════════════════════════════════════════════════\n  const rectNames  = [\"Thích A\", \"Không thích A\", \"Thích B\", \"Không thích B\"];\n  const rectColors = [COL.likeA, COL.unlikeA, COL.likeB, COL.unlikeB];\n  // Text color: dark on light rects, white on saturated\n  const txtColors  = [\"#fff\", COL.txtA, \"#fff\", COL.txtB];\n  const subColors  = [\"rgba(255,255,255,0.7)\", COL.txtA + \"99\", \"rgba(255,255,255,0.7)\", COL.txtB + \"99\"];\n\n  function update() {\n    const pA = SL.prior.val();\n    const lA = SL.likA.val();\n    const lB = SL.likB.val();\n    const pB = 1 - pA;\n\n    const data = [\n      { x1: 0,  x2: pA, y1: 0,  y2: lA },\n      { x1: 0,  x2: pA, y1: lA, y2: 1  },\n      { x1: pA, x2: 1,  y1: 0,  y2: lB },\n      { x1: pA, x2: 1,  y1: lB, y2: 1  },\n    ];\n\n    const sx = v =&gt; mg.l + v * pw;\n    const sy = v =&gt; mg.t + (1 - v) * ph;\n\n    for (let i = 0; i &lt; 4; i++) {\n      const d = data[i];\n      const px1 = sx(d.x1), px2 = sx(d.x2);\n      const py1 = sy(d.y2), py2 = sy(d.y1);\n      const rw = px2 - px1, rh = py2 - py1;\n\n      boxes[i].setAttribute(\"x\", px1); boxes[i].setAttribute(\"y\", py1);\n      boxes[i].setAttribute(\"width\", Math.max(0, rw)); boxes[i].setAttribute(\"height\", Math.max(0, rh));\n      boxes[i].setAttribute(\"fill\", rectColors[i]);\n\n      const cx = (px1 + px2) / 2, cy = (py1 + py2) / 2;\n      lbls[i].setAttribute(\"x\", cx); lbls[i].setAttribute(\"y\", cy - 8);\n      lbls[i].setAttribute(\"fill\", txtColors[i]);\n      lbls[i].textContent = (rw &gt; 60 && rh &gt; 35) ? rectNames[i] : \"\";\n\n      const area = (d.x2 - d.x1) * (d.y2 - d.y1);\n      aLbls[i].setAttribute(\"x\", cx); aLbls[i].setAttribute(\"y\", cy + 14);\n      aLbls[i].setAttribute(\"fill\", subColors[i]);\n      aLbls[i].textContent = (rw &gt; 60 && rh &gt; 35) ? area.toFixed(3) : \"\";\n    }\n\n    // ── Top: P(A) ──\n    const topY = mg.t - 18;\n    topLine.setAttribute(\"x1\", sx(0)); topLine.setAttribute(\"x2\", sx(pA));\n    topLine.setAttribute(\"y1\", topY); topLine.setAttribute(\"y2\", topY);\n    topText.setAttribute(\"x\", (sx(0) + sx(pA)) / 2); topText.setAttribute(\"y\", topY - 12);\n    topText.textContent = `P(A) = ${pA.toFixed(2)}`;\n\n    // ── Left: P(Date|A) ──\n    const leftX = mg.l - 14;\n    leftLine.setAttribute(\"x1\", leftX); leftLine.setAttribute(\"x2\", leftX);\n    leftLine.setAttribute(\"y1\", sy(lA)); leftLine.setAttribute(\"y2\", sy(0));\n    const leftMidY = (sy(lA) + sy(0)) / 2;\n    leftText.setAttribute(\"x\", leftX - 16); leftText.setAttribute(\"y\", leftMidY);\n    leftText.setAttribute(\"transform\", `rotate(-90,${leftX - 16},${leftMidY})`);\n    leftText.textContent = `P(Date|A) = ${lA.toFixed(2)}`;\n\n    // ── Right: P(Date|B) ──\n    const rightX = sx(1) + 14;\n    rightLine.setAttribute(\"x1\", rightX); rightLine.setAttribute(\"x2\", rightX);\n    rightLine.setAttribute(\"y1\", sy(lB)); rightLine.setAttribute(\"y2\", sy(0));\n    const rightMidY = (sy(lB) + sy(0)) / 2;\n    rightText.setAttribute(\"x\", rightX + 16); rightText.setAttribute(\"y\", rightMidY);\n    rightText.setAttribute(\"transform\", `rotate(90,${rightX + 16},${rightMidY})`);\n    rightText.textContent = `P(Date|B) = ${lB.toFixed(2)}`;\n\n    // ── Formula ──\n    const areaA = pA * lA;\n    const areaB = pB * lB;\n    const total = areaA + areaB;\n    const posterior = total &gt; 0 ? areaA / total : 0;\n\n    function miniRect(color, w, h, val, textColor) {\n      const maxH = 28;\n      const rw = Math.max(14, w / Math.max(w, h) * maxH * 1.5);\n      const rh = Math.max(10, h / Math.max(w, h) * maxH);\n      return `&lt;span style=\"display:inline-flex;align-items:center;gap:4px;vertical-align:middle;\"&gt;` +\n        `&lt;span style=\"display:inline-block;width:${rw.toFixed(0)}px;height:${rh.toFixed(0)}px;` +\n        `background:${color};border-radius:3px;border:1px solid ${textColor}30;vertical-align:middle;\"&gt;&lt;/span&gt;` +\n        `&lt;span style=\"color:${textColor}\"&gt;${val}&lt;/span&gt;&lt;/span&gt;`;\n    }\n\n    formulaBox.innerHTML = `\n      &lt;div style=\"display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:center;\"&gt;\n        &lt;span&gt;P(A | Date) =&lt;/span&gt;\n        &lt;div style=\"display:flex;flex-direction:column;align-items:center;gap:2px;\"&gt;\n          &lt;div style=\"padding-bottom:5px;border-bottom:2px solid ${COL.fg};\"&gt;\n            ${miniRect(COL.likeA, pA, lA, areaA.toFixed(3), COL.txtA)}\n          &lt;/div&gt;\n          &lt;div style=\"padding-top:5px;display:flex;align-items:center;gap:6px;\"&gt;\n            ${miniRect(COL.likeA, pA, lA, areaA.toFixed(3), COL.txtA)}\n            &lt;span style=\"color:${COL.fgSub}\"&gt;+&lt;/span&gt;\n            ${miniRect(COL.likeB, pB, lB, areaB.toFixed(3), COL.txtB)}\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;span style=\"color:${COL.txtA};font-size:22px;margin-left:4px;\"&gt;= ${(posterior * 100).toFixed(1)}%&lt;/span&gt;\n      &lt;/div&gt;\n    `;\n  }\n\n  // ══════════════════════════════════════════════════════\n  // EVENTS\n  // ══════════════════════════════════════════════════════\n  function onInput() { SL.prior.sync(); SL.likA.sync(); SL.likB.sync(); update(); }\n  SL.prior.input.addEventListener(\"input\", onInput);\n  SL.likA.input.addEventListener(\"input\", onInput);\n  SL.likB.input.addEventListener(\"input\", onInput);\n  update();\n\n  invalidation.then(() =&gt; {\n    SL.prior.input.removeEventListener(\"input\", onInput);\n    SL.likA.input.removeEventListener(\"input\", onInput);\n    SL.likB.input.removeEventListener(\"input\", onInput);\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#ứng-dụng",
    "href": "bayes.html#ứng-dụng",
    "title": "10  Bayesian",
    "section": "10.4 Ứng dụng",
    "text": "10.4 Ứng dụng\nGiả sử một bệnh nhân nhận kết quả xét nghiệm dương tính với một căn bệnh. Các thông số của xét nghiệm như sau:\n\nĐộ nhạy (Sensitivity): 95%\nĐộ đặc hiệu (Specificity): 90%\nTỉ lệ hiện mắc: Căn bệnh này chiếm 10% dân số\n\nXác suất thực sự người đó bị bệnh khi cầm kết quả dương tính \\(\\mathbb{P}(B|D)\\) là bao nhiêu?\nCách khác để đặt câu hỏi này là: Trong số những người cầm tờ giấy xét nghiệm Dương tính, có bao nhiêu phần trăm là Dương tính thật? Để trả lời, ta cần tìm Tổng diện tích Dương tính, rồi lấy Diện tích Dương tính thật chia cho tổng số đó.\nChúng ta sẽ áp dụng phương pháp “Hình vuông niềm tin” để giải quyết:\n\nHãy hình dung một hình vuông lớn đại diện cho 100% dân số\nHình vuông này được chia làm 2 phần, bên trái là tỉ lệ người bệnh trong dân số, bên phải là tỉ lệ người không bệnh\nTrong cột người bệnh, độ nhạy là 95%, tô màu 95% chiều cao của cột này, đây là phần dương tính thật, diện tích là \\(0.10 \\times 0.95 = 0.095\\)\nTrong cột người không bệnh, độ đặc hiệu là 90%, tô màu 10% chiều cao của cột này, đây là phần dương tính giả, diện tích là \\(0.90 \\times 0.10 = 0.09\\)\n\nBây giờ, hãy nhìn vào toàn bộ phần được tô màu trên hình vuông.\n\nTổng diện tích màu (tổng dương tính) là \\(0.095 \\text{ (Thật)} + 0.09 \\text{ (Giả)} = 0.185\\)\nPhần bị chiếm bởi dương tính thật chính là xác suất thực sự mắc bệnh khi có kết quả dương tính\n\n\nviewof prev = Inputs.range([0, 1], {\n  label: \"Tỉ lệ bệnh\", \n  value: 0.1, \n  step: 0.01\n})\n\nviewof sens = Inputs.range([0, 1], {\n  label: \"Độ nhạy\", \n  value: 0.95, \n  step: 0.01\n})\n\nviewof spec = Inputs.range([0, 1], {\n  label: \"Độ đặc hiệu\", \n  value: 0.9, \n  step: 0.01\n})\n\n// 2. THE CALCULATIONS (Reactive Data)\n// This array automatically updates whenever the sliders above move.\n// We define the 4 quadrants of the mosaic.\n\nrect_data2 = [\n  // --- COLUMN 1: ALEX (Left Side) ---\n  // The Width is determined by the 'prior'\n  \n  // 1. The \"Evidence\" Box (The bottom colored part)\n  {\n    label: \"Dương thật\",\n    x1: 0, \n    x2: prev, \n    y1: 0, \n    y2: sens, \n    color: \"#6ecae1\" // Light Blue (Strong Evidence)\n  },\n  \n  // 2. The \"Void\" Box (The top dark part)\n  {\n    label: \"Âm giả\",\n    x1: 0, \n    x2: prev, \n    y1: sens, \n    y2: 1, \n    color: \"#1a1a1a\" // Dark Grey\n  },\n\n  // --- COLUMN 2: BEN (Right Side) ---\n  // The Width starts where Alex ends ('prior') and goes to 1\n  \n  // 3. The \"Evidence\" Box (The bottom colored part)\n  {\n    label: \"Dương giả\",\n    x1: prev, \n    x2: 1, \n    y1: 0, \n    y2: 1 - spec, \n    color: \"#2f7e9b\" // Teal (Competing Evidence)\n  },\n  \n  // 4. The \"Void\" Box (The top dark part)\n  {\n    label: \"Âm thật\",\n    x1: prev, \n    x2: 1, \n    y1: 1 - spec, \n    y2: 1, \n    color: \"#0f0f0f\" // Black\n  }\n]\n\nPlot.plot({\n  width: 550, height: 450,\n  marginTop: 50,\n  marginLeft: 60,\n  marginRight: 60,\n  marginBottom: 20,\n\n  style: {\n    background: \"black\",\n    color: \"white\",\n    fontSize: \"16px\" \n  },\n  \n  x: { axis: null, domain: [0, 1] },\n  y: { axis: null, domain: [0, 1] },\n\n  marks: [\n    // --- PART 1: THE ANNOTATIONS ---\n    // Fix: Use [1] as dummy data, and arrow functions `() =&gt;` for text strings.\n\n    // A. TOP ANNOTATION: Prior P(H)\n    Plot.ruleY([1], { \n      y: 1.03,           \n      x1: 0, x2: prev,  \n      stroke: \"#000\", strokeWidth: 2,\n      clip: false\n    }),\n    Plot.text([1], {\n      x: prev / 2,      \n      y: 1.03, dy: -10,\n      text: () =&gt; `Tỉ lệ bệnh = ${prev.toFixed(2)}`, // &lt;--- Arrow function required\n      fill: \"#000\", fontWeight: \"bold\", fontSize: 16,\n      clip: false\n    }),\n\n    // B. LEFT ANNOTATION: P(E|H)\n    Plot.ruleX([1], {\n      x: -0.03,          \n      y1: 0, y2: sens, \n      stroke: \"#6ecae1\", strokeWidth: 2,\n      clip: false\n    }),\n    Plot.text([1], {\n      x: -0.03,          \n      y: sens / 2, \n      dx: -15, // Push slightly left away from the line\n      rotate: -90, // &lt;--- Rotates text vertically\n      text: () =&gt; `Độ nhạy = ${sens.toFixed(2)}`, // Removed \\n for cleaner vertical look\n      fill: \"#6ecae1\", \n      textAnchor: \"middle\", // Centers text on the bar height\n      fontWeight: \"bold\", fontSize: 16, clip: false\n    }),\n\n    // C. RIGHT ANNOTATION: P(E|¬H)\n    Plot.ruleX([1], {\n      x: 1.03,           \n      y1: 1 - spec, y2: 1, \n      stroke: \"#000\", strokeWidth: 2, clip: false\n    }),\n    Plot.text([1], {\n      x: 1.03,           \n      y: 1 - spec / 2, \n      dx: 15, // Push slightly right away from the line\n      rotate: -90, // &lt;--- Rotates text vertically\n      text: () =&gt; `Độ đặc hiệu = ${spec.toFixed(2)}`, \n      fill: \"#000\", \n      textAnchor: \"middle\", \n      fontWeight: \"bold\", fontSize: 16, clip: false\n    }),\n\n    // --- PART 2: THE MOSAIC ---\n    Plot.rect(rect_data2, {\n      x1: \"x1\", x2: \"x2\", y1: \"y1\", y2: \"y2\", \n      fill: \"color\", stroke: \"white\", strokeWidth: 1,\n      tip: {\n        fill: \"#222\", stroke: \"white\",\n        maxRadius: 100,\n        title: \"label\",\n        channels: {\n          \"Diện tích\": d =&gt; ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)\n        },\n        format: {\n          \"Diện tích\": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false\n        }\n      }\n    }),\n    \n    // Labels inside boxes\n    Plot.text(rect_data2, {\n      x: d =&gt; (d.x1 + d.x2) / 2, \n      y: d =&gt; (d.y1 + d.y2) / 2, \n      text: d =&gt; (d.y2 - d.y1) &gt; 0.1 && (d.x2 - d.x1) &gt; 0.1 ? d.label : \"\", \n      fill: \"white\", fontWeight: \"bold\", pointerEvents: \"none\" \n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narea_tpr = prev * sens\narea_fpr  = (1 - prev) * (1 - spec)\ntotal_area_risk = area_tpr + area_fpr\nposterior_risk = area_tpr / total_area_risk\n\nhtml`\n  &lt;div style=\"display: flex; align-items: center; flex-wrap: wrap;\"&gt;\n    &lt;div style=\"font-weight: bold; margin-right: 5px;\"&gt;\n      P(B | D) = \n    &lt;/div&gt;\n\n    &lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 5px;\"&gt;\n      \n      &lt;div style=\"border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;\"&gt;\n        &lt;span style=\"color: #6ecae1;\"&gt;${area_tpr.toFixed(3)}&lt;/span&gt;\n      &lt;/div&gt;\n      \n      &lt;div style=\"padding-top: 5px; text-align: center;\"&gt;\n        &lt;span style=\"color: #6ecae1;\"&gt;${area_tpr.toFixed(3)}&lt;/span&gt; + \n        &lt;span style=\"color: #2f7e9b;\"&gt;${area_fpr.toFixed(3)}&lt;/span&gt;\n      &lt;/div&gt;\n      \n    &lt;/div&gt;\n\n    &lt;div style=\"font-weight: bold; color: #6ecae1; margin-left: 5px;\"&gt;\n      = ${(posterior_risk * 100).toFixed(1)}%\n    &lt;/div&gt;\n  &lt;/div&gt;\n`",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#xấp-xỉ-lưới",
    "href": "bayes.html#xấp-xỉ-lưới",
    "title": "10  Bayesian",
    "section": "10.5 Xấp xỉ lưới",
    "text": "10.5 Xấp xỉ lưới\nChúng ta đã\n\nviewof bayes_grid = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. MATH\n  // ══════════════════════════════════════════════════════\n  function lgamma(x) {\n    if (x &lt;= 0) return 0;\n    const c = [0.99999999999980993,676.5203681218851,-1259.1392167224028,\n      771.32342877765313,-176.61502916214059,12.507343278686905,\n      -0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];\n    let sum = c[0];\n    for (let i = 1; i &lt; 9; i++) sum += c[i] / (x + i - 1);\n    const t = x + 6.5;\n    return 0.5 * Math.log(2 * Math.PI) + (x - 0.5) * Math.log(t) - t + Math.log(sum);\n  }\n  function lbeta(a, b) { return lgamma(a) + lgamma(b) - lgamma(a + b); }\n  function betaPDF(x, a, b) {\n    if (x &lt;= 0 || x &gt;= 1) return 0;\n    return Math.exp((a - 1) * Math.log(x) + (b - 1) * Math.log(1 - x) - lbeta(a, b));\n  }\n  function binomLik(p, k, n) {\n    if (p &lt;= 0) return k === 0 ? 1 : 0;\n    if (p &gt;= 1) return k === n ? 1 : 0;\n    return Math.exp(k * Math.log(p) + (n - k) * Math.log(1 - p));\n  }\n  function discretise(pdfFn, ps) {\n    const n = ps.length, w = 1 / n;\n    const vals = ps.map(p =&gt; pdfFn(p) * w);\n    const s = vals.reduce((a, v) =&gt; a + v, 0);\n    if (s &gt; 0) vals.forEach((v, i) =&gt; vals[i] = v / s);\n    return vals;\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:960px;margin:0 auto;\n  `;\n  wrapper.appendChild(injectStyle());\n\n  // ══════════════════════════════════════════════════════\n  // 3. CONTROLS\n  // ══════════════════════════════════════════════════════\n  const SL = {};\n  SL.alpha = createSlider(\"Prior \\u03B1\", 0.5, 10, 0.5, 1, \"#d97706\", \"amber\");\n  SL.beta  = createSlider(\"Prior \\u03B2\", 0.5, 10, 0.5, 1, \"#d97706\", \"amber\");\n  SL.n     = createSlider(\"n (trials)\", 1, 30, 1, 9, \"#7c3aed\", \"purple\");\n  SL.k     = createSlider(\"k (observed successes)\", 0, 30, 1, 6, \"#7c3aed\", \"purple\");\n  SL.grid  = createSlider(\"Grid points\", 5, 50, 1, 10, \"#1e293b\", \"dark\");\n\n  const r1 = document.createElement(\"div\");\n  r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;\";\n  r1.appendChild(SL.alpha.el); r1.appendChild(SL.beta.el);\n  wrapper.appendChild(r1);\n  const r2 = document.createElement(\"div\");\n  r2.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;\";\n  r2.appendChild(SL.n.el); r2.appendChild(SL.k.el);\n  wrapper.appendChild(r2);\n  const r3 = document.createElement(\"div\");\n  r3.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:12px;\";\n  r3.appendChild(SL.grid.el);\n  const spacer = document.createElement(\"div\"); spacer.style.cssText = \"flex:1;min-width:120px;\";\n  r3.appendChild(spacer);\n  wrapper.appendChild(r3);\n\n  const btnStep = createButton(\"▶  Step\", \"step\");\n  const btnAuto = createButton(\"⏩  Auto\", \"auto\");\n  const btnNorm = createButton(\"📊  Normalise\", \"go\");\n  const btnReset = createButton(\"↺  Reset\", \"reset\");\n  btnNorm.el.style.opacity = \"0.4\"; btnNorm.el.style.pointerEvents = \"none\";\n\n  const r4 = document.createElement(\"div\");\n  r4.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:14px;padding-bottom:14px;border-bottom:1px solid #e2e8f0;\";\n  r4.appendChild(btnStep.el); r4.appendChild(btnAuto.el); r4.appendChild(btnNorm.el); r4.appendChild(btnReset.el);\n  wrapper.appendChild(r4);\n\n  const calcBox = document.createElement(\"div\");\n  calcBox.style.cssText = `\n    width:100%;padding:10px 16px;border-radius:8px;margin-bottom:14px;\n    background:#f8fafc;border:1px solid #e2e8f0;min-height:28px;\n    font-size:14px;color:#334155;line-height:1.6;\n    font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;\n    text-align:center;\n  `;\n  wrapper.appendChild(calcBox);\n\n  // ══════════════════════════════════════════════════════\n  // 4. SVG PANELS — Prior & Likelihood (standard)\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const PW = 300, PH = 240;\n  const mg_ = { t: 34, r: 10, b: 42, l: 46 };\n  const pw_ = PW - mg_.l - mg_.r, ph_ = PH - mg_.t - mg_.b;\n\n  function mkEl(tag, a) {\n    const e = document.createElementNS(NS, tag);\n    if (a) for (const [k, v] of Object.entries(a)) e.setAttribute(k, v);\n    return e;\n  }\n\n  function createPanel(title, titleColor, barColor, barStroke) {\n    const svg = document.createElementNS(NS, \"svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${PW} ${PH}`);\n    svg.setAttribute(\"preserveAspectRatio\", \"xMidYMid meet\");\n    svg.style.cssText = \"flex:1;min-width:0;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;\";\n    const ttl = mkEl(\"text\", { x: String(PW / 2), y: \"22\", \"text-anchor\": \"middle\", fill: titleColor, \"font-size\": \"14\", \"font-weight\": \"700\" });\n    ttl.textContent = title; svg.appendChild(ttl);\n    const grids = []; for (let i = 0; i &lt;= 3; i++) { svg.appendChild(mkEl(\"line\", { stroke: \"#e2e8f0\", \"stroke-width\": \"0.7\" })); grids.push(svg.lastChild); }\n    const yLbls = []; for (let i = 0; i &lt;= 3; i++) { svg.appendChild(mkEl(\"text\", { \"text-anchor\": \"end\", fill: \"#94a3b8\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\" })); yLbls.push(svg.lastChild); }\n    const bars = []; for (let i = 0; i &lt; 50; i++) { const r = mkEl(\"rect\", { rx: \"2\", fill: barColor, opacity: \"0.6\", stroke: barStroke, \"stroke-width\": \"0.5\" }); r.style.display = \"none\"; svg.appendChild(r); bars.push(r); }\n    const dots = []; for (let i = 0; i &lt; 50; i++) { const c = mkEl(\"circle\", { r: \"5\", fill: barColor, stroke: \"#fff\", \"stroke-width\": \"2\" }); c.style.display = \"none\"; svg.appendChild(c); dots.push(c); }\n    const xAx = mkEl(\"line\", { stroke: \"#94a3b8\" }); svg.appendChild(xAx);\n    svg.appendChild(mkEl(\"line\", { x1: String(mg_.l), x2: String(mg_.l), y1: String(mg_.t), y2: String(mg_.t + ph_), stroke: \"#94a3b8\" }));\n    const xTicks = []; for (let i = 0; i &lt; 6; i++) { const ln = mkEl(\"line\", { stroke: \"#94a3b8\", y2: \"4\" }); ln.style.display = \"none\"; svg.appendChild(ln); const t = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\", dy: \"14\" }); t.style.display = \"none\"; svg.appendChild(t); xTicks.push({ ln, t }); }\n    const xLbl = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"12\", y: String(PH - 4) }); xLbl.textContent = \"p\"; svg.appendChild(xLbl);\n    return { svg, bars, dots, grids, yLbls, xAx, xTicks, xLbl, ttl };\n  }\n\n  const panelPrior = createPanel(\"Prior\", \"#d97706\", \"#d97706\", \"#b45309\");\n  const panelLik = createPanel(\"Likelihood\", \"#7c3aed\", \"#7c3aed\", \"#6d28d9\");\n\n  // ══════════════════════════════════════════════════════\n  // 5. POSTERIOR PANEL — dual axis: bars (left) + line (right)\n  // ══════════════════════════════════════════════════════\n  const postMg = { t: 34, r: 46, b: 42, l: 46 };\n  const postPw = PW - postMg.l - postMg.r;\n  const postPh = PH - postMg.t - postMg.b;\n\n  const postSvg = document.createElementNS(NS, \"svg\");\n  postSvg.setAttribute(\"viewBox\", `0 0 ${PW} ${PH}`);\n  postSvg.setAttribute(\"preserveAspectRatio\", \"xMidYMid meet\");\n  postSvg.style.cssText = \"flex:1;min-width:0;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;\";\n\n  const postTtl = mkEl(\"text\", { x: String(PW / 2), y: \"22\", \"text-anchor\": \"middle\", fill: \"#16a34a\", \"font-size\": \"14\", \"font-weight\": \"700\" });\n  postTtl.textContent = \"Posterior\"; postSvg.appendChild(postTtl);\n\n  // Left grid + labels (unstd)\n  const pGrids = []; for (let i = 0; i &lt;= 3; i++) { postSvg.appendChild(mkEl(\"line\", { stroke: \"#e2e8f0\", \"stroke-width\": \"0.7\" })); pGrids.push(postSvg.lastChild); }\n  const pYLbls = []; for (let i = 0; i &lt;= 3; i++) { postSvg.appendChild(mkEl(\"text\", { \"text-anchor\": \"end\", fill: \"#94a3b8\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\" })); pYLbls.push(postSvg.lastChild); }\n\n  // Bars (unstd, green)\n  const pBars = []; for (let i = 0; i &lt; 50; i++) { const r = mkEl(\"rect\", { rx: \"2\", fill: \"#16a34a\", opacity: \"0.6\", stroke: \"#15803d\", \"stroke-width\": \"0.5\" }); r.style.display = \"none\"; postSvg.appendChild(r); pBars.push(r); }\n\n  // Dots (step highlight)\n  const pDots = []; for (let i = 0; i &lt; 50; i++) { const c = mkEl(\"circle\", { r: \"5\", fill: \"#16a34a\", stroke: \"#fff\", \"stroke-width\": \"2\" }); c.style.display = \"none\"; postSvg.appendChild(c); pDots.push(c); }\n\n  // Normalised line + dots (overlay, red-orange, separate y-axis on right)\n  const normPath = mkEl(\"path\", { fill: \"none\", stroke: \"#dc2626\", \"stroke-width\": \"2.5\", opacity: \"0.9\" });\n  normPath.style.display = \"none\"; postSvg.appendChild(normPath);\n  const normDots = []; for (let i = 0; i &lt; 50; i++) { const c = mkEl(\"circle\", { r: \"4.5\", fill: \"#dc2626\", stroke: \"#fff\", \"stroke-width\": \"1.5\" }); c.style.display = \"none\"; postSvg.appendChild(c); normDots.push(c); }\n\n  // Right axis labels (normalised)\n  const rYLbls = []; for (let i = 0; i &lt;= 3; i++) { const t = mkEl(\"text\", { \"text-anchor\": \"start\", fill: \"#dc2626\", \"font-size\": \"11\", \"font-weight\": \"600\", \"font-family\": \"'SF Mono',monospace\" }); t.style.display = \"none\"; postSvg.appendChild(t); rYLbls.push(t); }\n  // Right axis line\n  const rAxis = mkEl(\"line\", { stroke: \"#dc2626\", \"stroke-width\": \"1\", opacity: \"0.5\" });\n  rAxis.style.display = \"none\"; postSvg.appendChild(rAxis);\n\n  // X axis\n  const pXAx = mkEl(\"line\", { stroke: \"#94a3b8\" }); postSvg.appendChild(pXAx);\n  postSvg.appendChild(mkEl(\"line\", { x1: String(postMg.l), x2: String(postMg.l), y1: String(postMg.t), y2: String(postMg.t + postPh), stroke: \"#94a3b8\" }));\n  const pXTicks = []; for (let i = 0; i &lt; 6; i++) { const ln = mkEl(\"line\", { stroke: \"#94a3b8\", y2: \"4\" }); ln.style.display = \"none\"; postSvg.appendChild(ln); const t = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\", dy: \"14\" }); t.style.display = \"none\"; postSvg.appendChild(t); pXTicks.push({ ln, t }); }\n  const pXLbl = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"12\", y: String(PH - 4) }); pXLbl.textContent = \"p\"; postSvg.appendChild(pXLbl);\n\n  // Legend\n  const legG = mkEl(\"g\"); legG.style.display = \"none\";\n  legG.appendChild(mkEl(\"rect\", { x: String(postMg.l + 4), y: String(postMg.t + 2), width: \"10\", height: \"10\", rx: \"2\", fill: \"#16a34a\", opacity: \"0.6\" }));\n  const lt1 = mkEl(\"text\", { x: String(postMg.l + 18), y: String(postMg.t + 11), fill: \"#16a34a\", \"font-size\": \"9\", \"font-weight\": \"600\" }); lt1.textContent = \"Unstd.\"; legG.appendChild(lt1);\n  legG.appendChild(mkEl(\"line\", { x1: String(postMg.l + 4), x2: String(postMg.l + 14), y1: String(postMg.t + 20), y2: String(postMg.t + 20), stroke: \"#dc2626\", \"stroke-width\": \"2.5\" }));\n  const lt2 = mkEl(\"text\", { x: String(postMg.l + 18), y: String(postMg.t + 24), fill: \"#dc2626\", \"font-size\": \"9\", \"font-weight\": \"600\" }); lt2.textContent = \"Normalised\"; legG.appendChild(lt2);\n  postSvg.appendChild(legG);\n\n  const chartRow = document.createElement(\"div\");\n  chartRow.style.cssText = \"display:flex;gap:8px;width:100%;\";\n  chartRow.appendChild(panelPrior.svg); chartRow.appendChild(panelLik.svg); chartRow.appendChild(postSvg);\n  wrapper.appendChild(chartRow);\n\n  // ══════════════════════════════════════════════════════\n  // 6. STATE\n  // ══════════════════════════════════════════════════════\n  let grid = [], stepIdx = -1, normalised = false, autoId = 0, running = false;\n  let fixedMaxPrior = 0.1, fixedMaxLik = 0.1, fixedMaxRaw = 0.1, fixedMaxNorm = 0.1;\n\n  function buildGrid() {\n    const nG = SL.grid.val(), a = SL.alpha.val(), b = SL.beta.val();\n    const k = Math.min(SL.k.val(), SL.n.val()), n = SL.n.val();\n    const ps = []; for (let i = 0; i &lt; nG; i++) ps.push((i + 0.5) / nG);\n    const priorVals = discretise(p =&gt; betaPDF(p, a, b), ps);\n    const likVals = ps.map(p =&gt; binomLik(p, k, n));\n    grid = []; let rawSum = 0;\n    for (let i = 0; i &lt; nG; i++) {\n      const raw = priorVals[i] * likVals[i]; rawSum += raw;\n      grid.push({ p: ps[i], prior: priorVals[i], lik: likVals[i], raw, postNorm: 0 });\n    }\n    if (rawSum &gt; 0) grid.forEach(g =&gt; g.postNorm = g.raw / rawSum);\n    fixedMaxPrior = Math.max(...grid.map(g =&gt; g.prior)) * 1.2 || 0.1;\n    fixedMaxLik = Math.max(...grid.map(g =&gt; g.lik)) * 1.2 || 0.1;\n    fixedMaxRaw = Math.max(...grid.map(g =&gt; g.raw)) * 1.2 || 0.001;\n    fixedMaxNorm = Math.max(...grid.map(g =&gt; g.postNorm)) * 1.2 || 0.1;\n    stepIdx = -1; normalised = false;\n    btnNorm.el.style.opacity = \"0.4\"; btnNorm.el.style.pointerEvents = \"none\";\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 7. RENDER\n  // ══════════════════════════════════════════════════════\n  function fmtY(v) { if (v === 0) return \"0\"; if (v &lt; 0.001) return v.toExponential(1); if (v &lt; 0.01) return v.toFixed(3); return v.toFixed(2); }\n  function fmtV(v) { if (v === 0) return \"0\"; if (v &lt; 0.0001) return v.toExponential(2); return v.toFixed(4); }\n\n  function renderStdPanel(panel, key, maxVal, showUpTo, highlightIdx) {\n    const nG = grid.length, barW = Math.max(3, Math.min(18, pw_ / nG * 0.8));\n    const sx = p =&gt; mg_.l + p * pw_, sy = v =&gt; mg_.t + ph_ - (v / (maxVal || 1)) * ph_, baseline = mg_.t + ph_;\n    for (let i = 0; i &lt;= 3; i++) { const v = (maxVal / 3) * i, yy = sy(v); panel.grids[i].setAttribute(\"x1\", mg_.l); panel.grids[i].setAttribute(\"x2\", PW - mg_.r); panel.grids[i].setAttribute(\"y1\", yy); panel.grids[i].setAttribute(\"y2\", yy); panel.yLbls[i].setAttribute(\"x\", mg_.l - 5); panel.yLbls[i].setAttribute(\"y\", yy + 4); panel.yLbls[i].textContent = fmtY(v); }\n    for (let i = 0; i &lt; 50; i++) { if (i &lt; nG && i &lt;= showUpTo) { const g = grid[i], bx = sx(g.p) - barW / 2, by = sy(g[key]); panel.bars[i].setAttribute(\"x\", bx); panel.bars[i].setAttribute(\"y\", by); panel.bars[i].setAttribute(\"width\", barW); panel.bars[i].setAttribute(\"height\", Math.max(0, baseline - by)); panel.bars[i].setAttribute(\"opacity\", highlightIdx &gt;= 0 && i === highlightIdx ? \"1\" : highlightIdx &gt;= 0 ? \"0.3\" : \"0.6\"); panel.bars[i].style.display = \"\"; } else { panel.bars[i].style.display = \"none\"; } }\n    for (let i = 0; i &lt; 50; i++) { if (i &lt; nG && i === highlightIdx && i &lt;= showUpTo) { panel.dots[i].setAttribute(\"cx\", sx(grid[i].p)); panel.dots[i].setAttribute(\"cy\", sy(grid[i][key])); panel.dots[i].style.display = \"\"; } else { panel.dots[i].style.display = \"none\"; } }\n    panel.xAx.setAttribute(\"x1\", mg_.l); panel.xAx.setAttribute(\"x2\", PW - mg_.r); panel.xAx.setAttribute(\"y1\", baseline); panel.xAx.setAttribute(\"y2\", baseline); panel.xLbl.setAttribute(\"x\", mg_.l + pw_ / 2);\n    const ticks = [0, 0.25, 0.5, 0.75, 1.0];\n    for (let i = 0; i &lt; 6; i++) { if (i &lt; ticks.length) { const xx = sx(ticks[i]); panel.xTicks[i].ln.setAttribute(\"x1\", xx); panel.xTicks[i].ln.setAttribute(\"x2\", xx); panel.xTicks[i].ln.setAttribute(\"y1\", baseline); panel.xTicks[i].ln.setAttribute(\"y2\", baseline + 4); panel.xTicks[i].ln.style.display = \"\"; panel.xTicks[i].t.setAttribute(\"x\", xx); panel.xTicks[i].t.setAttribute(\"y\", baseline + 4); panel.xTicks[i].t.textContent = ticks[i].toFixed(2); panel.xTicks[i].t.style.display = \"\"; } else { panel.xTicks[i].ln.style.display = \"none\"; panel.xTicks[i].t.style.display = \"none\"; } }\n  }\n\n  function renderPostPanel() {\n    const nG = grid.length, hi = (stepIdx &gt;= 0 && stepIdx &lt; nG) ? stepIdx : -1;\n    const showUpTo = stepIdx &gt;= 0 ? Math.min(stepIdx, nG - 1) : -1;\n    const barW = Math.max(3, Math.min(18, postPw / nG * 0.8));\n    const sx = p =&gt; postMg.l + p * postPw;\n    const syL = v =&gt; postMg.t + postPh - (v / (fixedMaxRaw || 1)) * postPh;\n    const syR = v =&gt; postMg.t + postPh - (v / (fixedMaxNorm || 1)) * postPh;\n    const baseline = postMg.t + postPh;\n\n    // Left grid + labels (unstd)\n    for (let i = 0; i &lt;= 3; i++) {\n      const v = (fixedMaxRaw / 3) * i, yy = syL(v);\n      pGrids[i].setAttribute(\"x1\", postMg.l); pGrids[i].setAttribute(\"x2\", PW - postMg.r);\n      pGrids[i].setAttribute(\"y1\", yy); pGrids[i].setAttribute(\"y2\", yy);\n      pYLbls[i].setAttribute(\"x\", postMg.l - 5); pYLbls[i].setAttribute(\"y\", yy + 4);\n      pYLbls[i].textContent = fmtY(v);\n      pYLbls[i].setAttribute(\"fill\", \"#94a3b8\");\n    }\n\n    // Bars (unstd) — always shown up to showUpTo (or all if normalised)\n    const barShowUpTo = normalised ? nG - 1 : showUpTo;\n    for (let i = 0; i &lt; 50; i++) {\n      if (i &lt; nG && i &lt;= barShowUpTo) {\n        const g = grid[i], bx = sx(g.p) - barW / 2, by = syL(g.raw);\n        pBars[i].setAttribute(\"x\", bx); pBars[i].setAttribute(\"y\", by);\n        pBars[i].setAttribute(\"width\", barW);\n        pBars[i].setAttribute(\"height\", Math.max(0, baseline - by));\n        pBars[i].setAttribute(\"opacity\",\n          normalised ? \"0.35\" :\n          hi &gt;= 0 && i === hi ? \"1\" : hi &gt;= 0 ? \"0.3\" : \"0.6\");\n        pBars[i].style.display = \"\";\n      } else { pBars[i].style.display = \"none\"; }\n    }\n\n    // Dots (step highlight, only during stepping)\n    for (let i = 0; i &lt; 50; i++) {\n      if (!normalised && i &lt; nG && i === hi && i &lt;= barShowUpTo) {\n        pDots[i].setAttribute(\"cx\", sx(grid[i].p)); pDots[i].setAttribute(\"cy\", syL(grid[i].raw));\n        pDots[i].style.display = \"\";\n      } else { pDots[i].style.display = \"none\"; }\n    }\n\n    // Normalised line + dots + right axis (only after normalise)\n    if (normalised) {\n      let d = \"\";\n      for (let i = 0; i &lt; nG; i++) {\n        const px = sx(grid[i].p), py = syR(grid[i].postNorm);\n        d += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n      }\n      normPath.setAttribute(\"d\", d); normPath.style.display = \"\";\n\n      for (let i = 0; i &lt; 50; i++) {\n        if (i &lt; nG) {\n          normDots[i].setAttribute(\"cx\", sx(grid[i].p));\n          normDots[i].setAttribute(\"cy\", syR(grid[i].postNorm));\n          normDots[i].style.display = \"\";\n        } else { normDots[i].style.display = \"none\"; }\n      }\n\n      // Right axis line\n      rAxis.setAttribute(\"x1\", PW - postMg.r); rAxis.setAttribute(\"x2\", PW - postMg.r);\n      rAxis.setAttribute(\"y1\", postMg.t); rAxis.setAttribute(\"y2\", baseline);\n      rAxis.style.display = \"\";\n\n      // Right axis labels\n      for (let i = 0; i &lt;= 3; i++) {\n        const v = (fixedMaxNorm / 3) * i, yy = syR(v);\n        rYLbls[i].setAttribute(\"x\", PW - postMg.r + 4); rYLbls[i].setAttribute(\"y\", yy + 4);\n        rYLbls[i].textContent = fmtY(v);\n        rYLbls[i].style.display = \"\";\n      }\n\n      legG.style.display = \"\";\n    } else {\n      normPath.style.display = \"none\";\n      for (let i = 0; i &lt; 50; i++) normDots[i].style.display = \"none\";\n      rAxis.style.display = \"none\";\n      for (let i = 0; i &lt;= 3; i++) rYLbls[i].style.display = \"none\";\n      legG.style.display = \"none\";\n    }\n\n    // X axis\n    pXAx.setAttribute(\"x1\", postMg.l); pXAx.setAttribute(\"x2\", PW - postMg.r);\n    pXAx.setAttribute(\"y1\", baseline); pXAx.setAttribute(\"y2\", baseline);\n    pXLbl.setAttribute(\"x\", postMg.l + postPw / 2);\n\n    const ticks = [0, 0.25, 0.5, 0.75, 1.0];\n    for (let i = 0; i &lt; 6; i++) {\n      if (i &lt; ticks.length) {\n        const xx = sx(ticks[i]);\n        pXTicks[i].ln.setAttribute(\"x1\", xx); pXTicks[i].ln.setAttribute(\"x2\", xx);\n        pXTicks[i].ln.setAttribute(\"y1\", baseline); pXTicks[i].ln.setAttribute(\"y2\", baseline + 4);\n        pXTicks[i].ln.style.display = \"\";\n        pXTicks[i].t.setAttribute(\"x\", xx); pXTicks[i].t.setAttribute(\"y\", baseline + 4);\n        pXTicks[i].t.textContent = ticks[i].toFixed(2); pXTicks[i].t.style.display = \"\";\n      } else { pXTicks[i].ln.style.display = \"none\"; pXTicks[i].t.style.display = \"none\"; }\n    }\n  }\n\n  function renderAll() {\n    const hi = (stepIdx &gt;= 0 && stepIdx &lt; grid.length) ? stepIdx : -1;\n    const done = stepIdx &gt;= grid.length;\n\n    renderStdPanel(panelPrior, \"prior\", fixedMaxPrior, grid.length - 1, hi);\n    renderStdPanel(panelLik, \"lik\", fixedMaxLik, grid.length - 1, hi);\n    renderPostPanel();\n\n    const a = SL.alpha.val(), b = SL.beta.val();\n    const k = Math.min(SL.k.val(), SL.n.val()), n = SL.n.val();\n    panelPrior.ttl.textContent = `Prior: Beta(${a}, ${b})`;\n    panelLik.ttl.textContent = `Lik: k=${k} from n=${n}`;\n    postTtl.textContent = normalised ? \"Posterior\" : done ? \"Posterior (unstandardised)\" : \"Posterior \\u221D Prior \\u00D7 Lik\";\n\n    if (stepIdx &lt; 0) {\n      calcBox.innerHTML = `Grid: &lt;b&gt;${grid.length}&lt;/b&gt; points. Prior sums to &lt;b&gt;${grid.reduce((s, g) =&gt; s + g.prior, 0).toFixed(3)}&lt;/b&gt;. Press &lt;b&gt;Step&lt;/b&gt; or &lt;b&gt;Auto&lt;/b&gt;.`;\n    } else if (stepIdx &lt; grid.length) {\n      const g = grid[stepIdx];\n      calcBox.innerHTML = `Point ${stepIdx + 1}/${grid.length}: &lt;b&gt;p = ${g.p.toFixed(3)}&lt;/b&gt; → &lt;span style=\"color:#d97706\"&gt;${fmtV(g.prior)}&lt;/span&gt; \\u00D7 &lt;span style=\"color:#7c3aed\"&gt;${fmtV(g.lik)}&lt;/span&gt; = &lt;span style=\"color:#16a34a;font-weight:700\"&gt;${fmtV(g.raw)}&lt;/span&gt;`;\n    } else if (!normalised) {\n      calcBox.innerHTML = `All &lt;b&gt;${grid.length}&lt;/b&gt; points done. Sum = &lt;b&gt;${grid.reduce((s, g) =&gt; s + g.raw, 0).toFixed(4)}&lt;/b&gt;. Click &lt;b style=\"color:#3b82f6\"&gt;Normalise&lt;/b&gt; to get the posterior.`;\n    } else {\n      calcBox.innerHTML = `&lt;span style=\"color:#16a34a;font-weight:700\"&gt;\\u2713 Normalised!&lt;/span&gt; &lt;span style=\"color:#16a34a\"&gt;Green bars&lt;/span&gt; = unstandardised (left axis), &lt;span style=\"color:#dc2626\"&gt;red line&lt;/span&gt; = normalised posterior (right axis, sums to 1).`;\n    }\n\n    if (done && !normalised) { btnNorm.el.style.opacity = \"1\"; btnNorm.el.style.pointerEvents = \"auto\"; }\n    else { btnNorm.el.style.opacity = \"0.4\"; btnNorm.el.style.pointerEvents = \"none\"; }\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 8. ACTIONS\n  // ══════════════════════════════════════════════════════\n  function doStep() { if (stepIdx &gt;= grid.length) return; stepIdx++; renderAll(); }\n  function doNormalise() { if (normalised || stepIdx &lt; grid.length) return; normalised = true; renderAll(); }\n  function onStep() { doStep(); }\n  function onAuto() {\n    if (running) { clearInterval(autoId); running = false; btnAuto.setText(\"⏩  Auto\"); return; }\n    running = true; btnAuto.setText(\"⏸  Stop\");\n    autoId = setInterval(() =&gt; { if (stepIdx &gt;= grid.length) { clearInterval(autoId); running = false; btnAuto.setText(\"⏩  Auto\"); return; } doStep(); }, 250);\n  }\n  function onNorm() { doNormalise(); }\n  function onReset() { clearInterval(autoId); running = false; btnAuto.setText(\"⏩  Auto\"); buildGrid(); renderAll(); }\n\n  btnStep.el.addEventListener(\"click\", onStep);\n  btnAuto.el.addEventListener(\"click\", onAuto);\n  btnNorm.el.addEventListener(\"click\", onNorm);\n  btnReset.el.addEventListener(\"click\", onReset);\n\n  function onParam() {\n    SL.alpha.sync(); SL.beta.sync(); SL.n.sync(); SL.k.sync(); SL.grid.sync();\n    if (SL.k.val() &gt; SL.n.val()) { SL.k.input.value = SL.n.val(); SL.k.sync(); }\n    if (!running) onReset();\n  }\n  SL.alpha.input.addEventListener(\"input\", onParam);\n  SL.beta.input.addEventListener(\"input\", onParam);\n  SL.n.input.addEventListener(\"input\", onParam);\n  SL.k.input.addEventListener(\"input\", onParam);\n  SL.grid.input.addEventListener(\"input\", onParam);\n\n  buildGrid(); renderAll();\n\n  invalidation.then(() =&gt; {\n    clearInterval(autoId);\n    btnStep.el.removeEventListener(\"click\", onStep);\n    btnAuto.el.removeEventListener(\"click\", onAuto);\n    btnNorm.el.removeEventListener(\"click\", onNorm);\n    btnReset.el.removeEventListener(\"click\", onReset);\n    SL.alpha.input.removeEventListener(\"input\", onParam);\n    SL.beta.input.removeEventListener(\"input\", onParam);\n    SL.n.input.removeEventListener(\"input\", onParam);\n    SL.k.input.removeEventListener(\"input\", onParam);\n    SL.grid.input.removeEventListener(\"input\", onParam);\n    grid = [];\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#markov-chain-monte-carlo",
    "href": "bayes.html#markov-chain-monte-carlo",
    "title": "10  Bayesian",
    "section": "10.6 Markov chain Monte Carlo",
    "text": "10.6 Markov chain Monte Carlo\n\nviewof grid_vs_mcmc = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. TARGET DISTRIBUTIONS\n  // ══════════════════════════════════════════════════════\n  function logPostNormal(x, y) {\n    const mx = 0.5, my = 0.4, sx = 0.15, sy = 0.12, rho = 0.6;\n    const z = ((x - mx) / sx) ** 2 - 2 * rho * ((x - mx) / sx) * ((y - my) / sy) + ((y - my) / sy) ** 2;\n    return -z / (2 * (1 - rho * rho));\n  }\n  function logPostBanana(x, y) {\n    return -0.5 * ((1 - x * 4) ** 2 + 8 * (y * 4 - (x * 4) ** 2) ** 2) * 0.3;\n  }\n  function logPostBimodal(x, y) {\n    const g1 = Math.exp(-((x - 0.3) ** 2 + (y - 0.3) ** 2) / (2 * 0.08 ** 2));\n    const g2 = Math.exp(-((x - 0.7) ** 2 + (y - 0.7) ** 2) / (2 * 0.1 ** 2));\n    return Math.log(g1 + g2 + 1e-30);\n  }\n  const targets = { \"Correlated Normal\": logPostNormal, \"Banana-shaped\": logPostBanana, \"Bimodal\": logPostBimodal };\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:960px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  const extra = document.createElement(\"style\");\n  extra.textContent = `\n    .gm-select{padding:7px 12px;border-radius:8px;border:1px solid #d1d5db;background:#fff;color:#334155;font-size:13px;font-weight:600;font-family:inherit;cursor:pointer;width:100%;appearance:auto;}\n    .gm-select:focus{outline:2px solid #3b82f6;outline-offset:1px;}\n    .gm-select-label{font-size:11px;font-weight:600;color:#64748b;letter-spacing:0.3px;text-transform:uppercase;margin-bottom:5px;display:block;}\n    .gm-prog-track{height:10px;background:#e2e8f0;border-radius:5px;overflow:hidden;flex:1;}\n    .gm-prog-fill{height:100%;border-radius:5px;transition:width 0.05s;}\n  `;\n  wrapper.appendChild(extra);\n\n  // ══════════════════════════════════════════════════════\n  // 3. CONTROLS\n  // ══════════════════════════════════════════════════════\n  const selCol = document.createElement(\"div\");\n  selCol.style.cssText = \"display:flex;flex-direction:column;flex:1;min-width:160px;\";\n  const selLbl = document.createElement(\"label\"); selLbl.className = \"gm-select-label\"; selLbl.textContent = \"Target Distribution\";\n  const selDist = document.createElement(\"select\"); selDist.className = \"gm-select\";\n  for (const name of Object.keys(targets)) { const o = document.createElement(\"option\"); o.value = name; o.textContent = name; selDist.appendChild(o); }\n  selCol.appendChild(selLbl); selCol.appendChild(selDist);\n\n  const SL = {};\n  SL.gridN = createSlider(\"Grid per axis\", 5, 40, 1, 15, \"#3b82f6\", \"blue\");\n  SL.mcmcN = createSlider(\"MCMC samples\", 100, 2000, 50, 500, \"#dc2626\", \"red\");\n  SL.speed = createSlider(\"Evals per frame\", 1, 30, 1, 8, \"#1e293b\", \"dark\");\n  SL.dim   = createSlider(\"Dimensions\", 2, 8, 1, 2, \"#1e293b\", \"dark\");\n\n  const r1 = document.createElement(\"div\"); r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;align-items:flex-end;\";\n  r1.appendChild(selCol); r1.appendChild(SL.dim.el);\n  wrapper.appendChild(r1);\n  const r2 = document.createElement(\"div\"); r2.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:10px;\";\n  r2.appendChild(SL.gridN.el); r2.appendChild(SL.mcmcN.el);\n  wrapper.appendChild(r2);\n  const r2b = document.createElement(\"div\"); r2b.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:12px;\";\n  r2b.appendChild(SL.speed.el);\n  const sp2 = document.createElement(\"div\"); sp2.style.cssText = \"flex:1;min-width:120px;\";\n  r2b.appendChild(sp2);\n  wrapper.appendChild(r2b);\n\n  const btnRun = createButton(\"▶  Run Both\", \"step\");\n  const btnReset = createButton(\"↺  Reset\", \"reset\");\n  const r3 = document.createElement(\"div\"); r3.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:14px;padding-bottom:14px;border-bottom:1px solid #e2e8f0;\";\n  r3.appendChild(btnRun.el); r3.appendChild(btnReset.el);\n  wrapper.appendChild(r3);\n\n  // ══════════════════════════════════════════════════════\n  // 4. PROGRESS BARS\n  // ══════════════════════════════════════════════════════\n  const progRow = document.createElement(\"div\"); progRow.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:14px;\";\n\n  function makeProgBar(label, color) {\n    const col = document.createElement(\"div\"); col.style.cssText = \"flex:1;display:flex;flex-direction:column;gap:4px;\";\n    const head = document.createElement(\"div\"); head.style.cssText = \"display:flex;justify-content:space-between;align-items:baseline;\";\n    const lbl = document.createElement(\"span\"); lbl.style.cssText = `font-size:11px;font-weight:700;color:${color};text-transform:uppercase;letter-spacing:0.3px;`;\n    lbl.textContent = label;\n    const status = document.createElement(\"span\"); status.style.cssText = `font-size:12px;font-weight:700;color:${color};font-family:\"SF Mono\",monospace;`;\n    head.appendChild(lbl); head.appendChild(status);\n    const track = document.createElement(\"div\"); track.className = \"gm-prog-track\";\n    const fill = document.createElement(\"div\"); fill.className = \"gm-prog-fill\"; fill.style.background = color; fill.style.width = \"0%\";\n    track.appendChild(fill);\n    // Total label\n    const total = document.createElement(\"div\"); total.style.cssText = `font-size:11px;color:#94a3b8;font-family:\"SF Mono\",monospace;`;\n    col.appendChild(head); col.appendChild(track); col.appendChild(total);\n    return { el: col, fill, status, total };\n  }\n\n  const progGrid = makeProgBar(\"Grid\", \"#3b82f6\");\n  const progMCMC = makeProgBar(\"MCMC\", \"#dc2626\");\n  progRow.appendChild(progGrid.el); progRow.appendChild(progMCMC.el);\n  wrapper.appendChild(progRow);\n\n  // ══════════════════════════════════════════════════════\n  // 5. TWO CANVASES\n  // ══════════════════════════════════════════════════════\n  const CW = 380, CH = 380;\n\n  function makeCanvas(label, color) {\n    const col = document.createElement(\"div\"); col.style.cssText = \"flex:1;min-width:0;display:flex;flex-direction:column;align-items:center;position:relative;\";\n    const lbl = document.createElement(\"div\"); lbl.style.cssText = `font-size:14px;font-weight:700;color:${color};margin-bottom:6px;text-align:center;`;\n    lbl.textContent = label;\n    const cvs = document.createElement(\"canvas\"); cvs.width = CW; cvs.height = CH;\n    cvs.style.cssText = \"width:100%;border-radius:10px;border:1px solid #e2e8f0;\";\n    // Done overlay\n    const badge = document.createElement(\"div\");\n    badge.style.cssText = `\n      position:absolute;top:34px;left:50%;transform:translateX(-50%);\n      padding:4px 14px;border-radius:20px;font-size:13px;font-weight:700;\n      font-family:\"SF Mono\",monospace;display:none;z-index:1;\n    `;\n    col.appendChild(lbl); col.appendChild(cvs); col.appendChild(badge);\n    return { col, cvs, lbl, ctx: cvs.getContext(\"2d\"), badge };\n  }\n\n  const canvasRow = document.createElement(\"div\"); canvasRow.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:14px;\";\n  const cGrid = makeCanvas(\"Grid Approximation\", \"#3b82f6\");\n  const cMCMC = makeCanvas(\"MCMC (Metropolis-Hastings)\", \"#dc2626\");\n  canvasRow.appendChild(cGrid.col); canvasRow.appendChild(cMCMC.col);\n  wrapper.appendChild(canvasRow);\n\n  // Dimension box\n  const dimBox = document.createElement(\"div\");\n  dimBox.style.cssText = `\n    width:100%;padding:10px 16px;border-radius:8px;\n    background:#f8fafc;border:1px solid #e2e8f0;\n    font-size:14px;color:#334155;line-height:1.7;\n    font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;\n    text-align:center;\n  `;\n  wrapper.appendChild(dimBox);\n\n  // ══════════════════════════════════════════════════════\n  // 6. CONTOUR + DATA\n  // ══════════════════════════════════════════════════════\n  let contourImg = null;\n\n  function buildContour(logPost) {\n    const R = 100, data = new Float64Array(R * R);\n    let maxV = -Infinity;\n    for (let yi = 0; yi &lt; R; yi++) for (let xi = 0; xi &lt; R; xi++) {\n      const v = logPost((xi + 0.5) / R, 1 - (yi + 0.5) / R);\n      data[yi * R + xi] = v; if (v &gt; maxV) maxV = v;\n    }\n    const img = new ImageData(R, R);\n    for (let i = 0; i &lt; R * R; i++) {\n      const t = Math.exp(data[i] - maxV);\n      img.data[i * 4] = Math.round(250 - t * 110);\n      img.data[i * 4 + 1] = Math.round(250 - t * 170);\n      img.data[i * 4 + 2] = Math.round(255 - t * 50);\n      img.data[i * 4 + 3] = 255;\n    }\n    contourImg = img;\n  }\n\n  function drawContour(ctx) {\n    if (!contourImg) return;\n    const tmp = document.createElement(\"canvas\"); tmp.width = 100; tmp.height = 100;\n    tmp.getContext(\"2d\").putImageData(contourImg, 0, 0);\n    ctx.imageSmoothingEnabled = true; ctx.drawImage(tmp, 0, 0, CW, CH);\n  }\n\n  let allGridPts = [], allMcmcPts = [], mcmcAcc = 0;\n\n  function precompute() {\n    const logPost = targets[selDist.value];\n    const gN = SL.gridN.val();\n    const dim = SL.dim.val();\n    buildContour(logPost);\n\n    // Grid: n^dim total, but we only visualise the 2D slice\n    // For the animation we simulate n^dim eval count but only have n^2 visual points\n    allGridPts = [];\n    let maxLP = -Infinity;\n    for (let yi = 0; yi &lt; gN; yi++) for (let xi = 0; xi &lt; gN; xi++) {\n      const x = (xi + 0.5) / gN, y = (yi + 0.5) / gN;\n      const lp = logPost(x, y);\n      allGridPts.push({ x, y, lp }); if (lp &gt; maxLP) maxLP = lp;\n    }\n    allGridPts.forEach(p =&gt; p.w = Math.exp(p.lp - maxLP));\n    const sumW = allGridPts.reduce((s, p) =&gt; s + p.w, 0);\n    allGridPts.forEach(p =&gt; p.w /= sumW);\n\n    // MCMC\n    const nSamp = SL.mcmcN.val();\n    const propSD = 0.05;\n    allMcmcPts = []; mcmcAcc = 0;\n    let cx = 0.5, cy = 0.5, clp = logPost(cx, cy);\n    for (let i = 0; i &lt; 200; i++) {\n      const nx = cx + (Math.random() - 0.5) * 2 * propSD;\n      const ny = cy + (Math.random() - 0.5) * 2 * propSD;\n      if (nx &gt;= 0 && nx &lt;= 1 && ny &gt;= 0 && ny &lt;= 1) {\n        const nlp = logPost(nx, ny);\n        if (Math.log(Math.random()) &lt; nlp - clp) { cx = nx; cy = ny; clp = nlp; }\n      }\n    }\n    for (let i = 0; i &lt; nSamp; i++) {\n      const nx = cx + (Math.random() - 0.5) * 2 * propSD;\n      const ny = cy + (Math.random() - 0.5) * 2 * propSD;\n      if (nx &gt;= 0 && nx &lt;= 1 && ny &gt;= 0 && ny &lt;= 1) {\n        const nlp = logPost(nx, ny);\n        if (Math.log(Math.random()) &lt; nlp - clp) { cx = nx; cy = ny; clp = nlp; mcmcAcc++; }\n      }\n      allMcmcPts.push({ x: cx, y: cy });\n    }\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 7. DRAW\n  // ══════════════════════════════════════════════════════\n  function drawGridUpTo(ctx, nVisual) {\n    drawContour(ctx);\n    const gN = SL.gridN.val();\n    const maxW = Math.max(...allGridPts.map(p =&gt; p.w));\n    ctx.strokeStyle = \"rgba(59,130,246,0.12)\"; ctx.lineWidth = 0.5;\n    for (let i = 0; i &lt;= gN; i++) {\n      const v = i / gN * CW;\n      ctx.beginPath(); ctx.moveTo(v, 0); ctx.lineTo(v, CH); ctx.stroke();\n      ctx.beginPath(); ctx.moveTo(0, v); ctx.lineTo(CW, v); ctx.stroke();\n    }\n    const n = Math.min(nVisual, allGridPts.length);\n    for (let i = 0; i &lt; n; i++) {\n      const p = allGridPts[i], px = p.x * CW, py = (1 - p.y) * CH;\n      const r = 1.5 + (p.w / maxW) * 6, alpha = 0.2 + (p.w / maxW) * 0.8;\n      ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(59,130,246,${alpha.toFixed(2)})`; ctx.fill();\n    }\n    if (n &gt; 0 && n &lt; allGridPts.length) {\n      const p = allGridPts[n - 1];\n      ctx.beginPath(); ctx.arc(p.x * CW, (1 - p.y) * CH, 6, 0, Math.PI * 2);\n      ctx.fillStyle = \"#3b82f6\"; ctx.fill(); ctx.strokeStyle = \"#fff\"; ctx.lineWidth = 2; ctx.stroke();\n    }\n  }\n\n  function drawMcmcUpTo(ctx, n) {\n    drawContour(ctx);\n    if (n &lt; 1) return;\n    ctx.strokeStyle = \"rgba(220,38,38,0.07)\"; ctx.lineWidth = 0.8;\n    ctx.beginPath(); ctx.moveTo(allMcmcPts[0].x * CW, (1 - allMcmcPts[0].y) * CH);\n    for (let i = 1; i &lt; n; i++) ctx.lineTo(allMcmcPts[i].x * CW, (1 - allMcmcPts[i].y) * CH);\n    ctx.stroke();\n    ctx.fillStyle = \"rgba(220,38,38,0.3)\"; ctx.beginPath();\n    for (let i = 0; i &lt; n; i++) { const px = allMcmcPts[i].x * CW, py = (1 - allMcmcPts[i].y) * CH; ctx.moveTo(px + 2, py); ctx.arc(px, py, 2, 0, Math.PI * 2); }\n    ctx.fill();\n    const last = allMcmcPts[n - 1];\n    ctx.beginPath(); ctx.arc(last.x * CW, (1 - last.y) * CH, 5, 0, Math.PI * 2);\n    ctx.fillStyle = \"#dc2626\"; ctx.fill(); ctx.strokeStyle = \"#fff\"; ctx.lineWidth = 2; ctx.stroke();\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 8. ANIMATION — same eval/sec rate, different totals\n  // ══════════════════════════════════════════════════════\n  let animId = 0, animating = false;\n  let gridEvals = 0, mcmcEvals = 0;\n  let gridTotal = 0, mcmcTotal = 0;\n\n  function fmtN(v) {\n    if (v &gt;= 1e12) return v.toExponential(1);\n    if (v &gt;= 1e6) return (v / 1e6).toFixed(1) + \"M\";\n    if (v &gt;= 1e3) return (v / 1e3).toFixed(1) + \"K\";\n    return String(v);\n  }\n\n  function updateUI() {\n    const gPct = Math.min(100, gridEvals / gridTotal * 100);\n    const mPct = Math.min(100, mcmcEvals / mcmcTotal * 100);\n    progGrid.fill.style.width = gPct.toFixed(1) + \"%\";\n    progMCMC.fill.style.width = mPct.toFixed(1) + \"%\";\n\n    const gDone = gridEvals &gt;= gridTotal;\n    const mDone = mcmcEvals &gt;= mcmcTotal;\n\n    progGrid.status.textContent = gDone ? \"\\u2713 Done\" : `${fmtN(gridEvals)} / ${fmtN(gridTotal)}`;\n    progGrid.status.style.color = gDone ? \"#16a34a\" : \"#3b82f6\";\n    progGrid.total.textContent = `Need ${fmtN(gridTotal)} evals (${SL.gridN.val()}^${SL.dim.val()})`;\n\n    progMCMC.status.textContent = mDone ? \"\\u2713 Done\" : `${mcmcEvals} / ${mcmcTotal}`;\n    progMCMC.status.style.color = mDone ? \"#16a34a\" : \"#dc2626\";\n    progMCMC.total.textContent = `Need ${fmtN(mcmcTotal)} evals (same in any dimension)`;\n\n    // Badges\n    if (mDone && !gDone) {\n      cMCMC.badge.textContent = \"\\u2713 MCMC finished!\";\n      cMCMC.badge.style.cssText += \"display:block;background:rgba(22,163,74,0.9);color:#fff;\";\n      cGrid.badge.textContent = `Still computing... ${gPct.toFixed(0)}%`;\n      cGrid.badge.style.cssText += \"display:block;background:rgba(59,130,246,0.85);color:#fff;\";\n    } else if (gDone && mDone) {\n      cGrid.badge.textContent = \"\\u2713 Done\";\n      cGrid.badge.style.cssText += \"display:block;background:rgba(22,163,74,0.9);color:#fff;\";\n      cMCMC.badge.textContent = \"\\u2713 Done\";\n      cMCMC.badge.style.cssText += \"display:block;background:rgba(22,163,74,0.9);color:#fff;\";\n    }\n\n    // Dimension box\n    const ratio = gridTotal / mcmcTotal;\n    dimBox.innerHTML =\n      `&lt;b style=\"color:#3b82f6\"&gt;Grid&lt;/b&gt; needs &lt;b&gt;${fmtN(gridTotal)}&lt;/b&gt; evals` +\n      ` &ensp;vs&ensp; &lt;b style=\"color:#dc2626\"&gt;MCMC&lt;/b&gt; needs &lt;b&gt;${fmtN(mcmcTotal)}&lt;/b&gt; evals` +\n      (ratio &gt; 2 ? ` &ensp;\\u2014&ensp; &lt;b&gt;Grid is ${ratio &gt;= 100 ? fmtN(Math.round(ratio)) : ratio.toFixed(1)}\\u00D7 slower!&lt;/b&gt;` : \"\");\n  }\n\n  function animate() {\n    const speed = SL.speed.val();\n\n    // Both advance by same number of evaluations per frame\n    gridEvals = Math.min(gridEvals + speed, gridTotal);\n    mcmcEvals = Math.min(mcmcEvals + speed, mcmcTotal);\n\n    // Map grid evals to visual points (grid has n^d evals but only n^2 visual points)\n    const n2 = allGridPts.length;\n    const gridVisual = Math.min(n2, Math.floor(gridEvals / gridTotal * n2));\n    const mcmcVisual = Math.min(allMcmcPts.length, mcmcEvals);\n\n    drawGridUpTo(cGrid.ctx, gridVisual);\n    drawMcmcUpTo(cMCMC.ctx, mcmcVisual);\n    updateUI();\n\n    if (gridEvals &lt; gridTotal || mcmcEvals &lt; mcmcTotal) {\n      animId = requestAnimationFrame(animate);\n    } else {\n      animating = false; btnRun.setText(\"▶  Run Both\");\n    }\n  }\n\n  function run() {\n    if (animating) { cancelAnimationFrame(animId); animating = false; btnRun.setText(\"▶  Run Both\"); return; }\n    precompute();\n\n    gridTotal = Math.pow(SL.gridN.val(), SL.dim.val());\n    mcmcTotal = SL.mcmcN.val();\n    gridEvals = 0; mcmcEvals = 0;\n\n    cGrid.badge.style.display = \"none\";\n    cMCMC.badge.style.display = \"none\";\n\n    animating = true; btnRun.setText(\"⏸  Pause\");\n    animId = requestAnimationFrame(animate);\n  }\n\n  function reset() {\n    cancelAnimationFrame(animId); animating = false; btnRun.setText(\"▶  Run Both\");\n    gridEvals = 0; mcmcEvals = 0;\n    allGridPts = []; allMcmcPts = [];\n\n    const logPost = targets[selDist.value];\n    buildContour(logPost);\n    drawContour(cGrid.ctx); drawContour(cMCMC.ctx);\n\n    cGrid.badge.style.display = \"none\"; cMCMC.badge.style.display = \"none\";\n    progGrid.fill.style.width = \"0%\"; progMCMC.fill.style.width = \"0%\";\n    progGrid.status.textContent = \"—\"; progMCMC.status.textContent = \"—\";\n\n    gridTotal = Math.pow(SL.gridN.val(), SL.dim.val());\n    mcmcTotal = SL.mcmcN.val();\n    progGrid.total.textContent = `Need ${fmtN(gridTotal)} evals (${SL.gridN.val()}^${SL.dim.val()})`;\n    progMCMC.total.textContent = `Need ${fmtN(mcmcTotal)} evals (same in any dimension)`;\n\n    const ratio = gridTotal / mcmcTotal;\n    dimBox.innerHTML =\n      `&lt;b style=\"color:#3b82f6\"&gt;Grid&lt;/b&gt; needs &lt;b&gt;${fmtN(gridTotal)}&lt;/b&gt; evals` +\n      ` &ensp;vs&ensp; &lt;b style=\"color:#dc2626\"&gt;MCMC&lt;/b&gt; needs &lt;b&gt;${fmtN(mcmcTotal)}&lt;/b&gt; evals` +\n      (ratio &gt; 2 ? ` &ensp;\\u2014&ensp; &lt;b&gt;Grid is ${ratio &gt;= 100 ? fmtN(Math.round(ratio)) : ratio.toFixed(1)}\\u00D7 slower!&lt;/b&gt;` : \"\");\n  }\n\n  btnRun.el.addEventListener(\"click\", run);\n  btnReset.el.addEventListener(\"click\", reset);\n\n  function onParam() { SL.gridN.sync(); SL.mcmcN.sync(); SL.speed.sync(); SL.dim.sync(); if (!animating) reset(); }\n  SL.gridN.input.addEventListener(\"input\", onParam);\n  SL.mcmcN.input.addEventListener(\"input\", onParam);\n  SL.speed.input.addEventListener(\"input\", onParam);\n  SL.dim.input.addEventListener(\"input\", onParam);\n  selDist.addEventListener(\"change\", () =&gt; { if (!animating) reset(); });\n\n  reset();\n\n  invalidation.then(() =&gt; {\n    cancelAnimationFrame(animId);\n    btnRun.el.removeEventListener(\"click\", run);\n    btnReset.el.removeEventListener(\"click\", reset);\n    SL.gridN.input.removeEventListener(\"input\", onParam);\n    SL.mcmcN.input.removeEventListener(\"input\", onParam);\n    SL.speed.input.removeEventListener(\"input\", onParam);\n    SL.dim.input.removeEventListener(\"input\", onParam);\n    allGridPts = []; allMcmcPts = []; contourImg = null;\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()\n\n\n\n\n\n\n\nviewof mcmc_steps = (() =&gt; {\n  // ══════════════════════════════════════════════════════\n  // 1. TARGET DISTRIBUTIONS (1D, unnormalised)\n  // ══════════════════════════════════════════════════════\n  function gaussPDF(x, mu, sig) {\n    return Math.exp(-0.5 * ((x - mu) / sig) ** 2);\n  }\n\n  const targetFns = {\n    \"Normal(0.5, 0.15)\": x =&gt; gaussPDF(x, 0.5, 0.15),\n    \"Bimodal\": x =&gt; 0.6 * gaussPDF(x, 0.3, 0.08) + 0.4 * gaussPDF(x, 0.75, 0.1),\n    \"Skewed\": x =&gt; gaussPDF(x, 0.35, 0.1) * (1 + 2 * x),\n    \"Uniform-ish\": x =&gt; (x &gt; 0.15 && x &lt; 0.85) ? 1 : 0.05,\n  };\n\n  // ══════════════════════════════════════════════════════\n  // 2. WRAPPER\n  // ══════════════════════════════════════════════════════\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `display:flex;flex-direction:column;align-items:center;\n    font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,sans-serif;\n    width:100%;max-width:960px;margin:0 auto;`;\n  wrapper.appendChild(injectStyle());\n\n  const extra = document.createElement(\"style\");\n  extra.textContent = `\n    .mc-select{padding:7px 12px;border-radius:8px;border:1px solid #d1d5db;background:#fff;color:#334155;font-size:13px;font-weight:600;font-family:inherit;cursor:pointer;width:100%;appearance:auto;}\n    .mc-select:focus{outline:2px solid #3b82f6;outline-offset:1px;}\n    .mc-select-label{font-size:11px;font-weight:600;color:#64748b;letter-spacing:0.3px;text-transform:uppercase;margin-bottom:5px;display:block;}\n    .mc-step-box{width:100%;border-radius:10px;overflow:hidden;margin-bottom:14px;border:2px solid #e2e8f0;}\n    .mc-step-header{display:flex;gap:0;}\n    .mc-step-tab{flex:1;padding:8px 4px;text-align:center;font-size:12px;font-weight:700;\n      font-family:\"SF Mono\",monospace;cursor:default;transition:all 0.15s;color:#94a3b8;background:#f8fafc;}\n    .mc-step-tab.active{color:#fff;}\n    .mc-step-tab.done{opacity:0.6;}\n    .mc-step-body{padding:12px 16px;font-size:14px;line-height:1.7;\n      font-family:\"SF Mono\",SFMono-Regular,Menlo,Consolas,monospace;\n      background:#fff;min-height:60px;color:#334155;}\n  `;\n  wrapper.appendChild(extra);\n\n  // ══════════════════════════════════════════════════════\n  // 3. CONTROLS\n  // ══════════════════════════════════════════════════════\n  const selCol = document.createElement(\"div\");\n  selCol.style.cssText = \"display:flex;flex-direction:column;flex:1;min-width:160px;\";\n  const selLbl = document.createElement(\"label\"); selLbl.className = \"mc-select-label\"; selLbl.textContent = \"Target Distribution\";\n  const selDist = document.createElement(\"select\"); selDist.className = \"mc-select\";\n  for (const name of Object.keys(targetFns)) { const o = document.createElement(\"option\"); o.value = name; o.textContent = name; selDist.appendChild(o); }\n  selCol.appendChild(selLbl); selCol.appendChild(selDist);\n\n  const SL = {};\n  SL.propSD = createSlider(\"Proposal width (\\u03C3)\", 0.02, 0.30, 0.01, 0.10, \"#7c3aed\", \"purple\");\n\n  const r1 = document.createElement(\"div\"); r1.style.cssText = \"display:flex;gap:20px;width:100%;margin-bottom:12px;align-items:flex-end;\";\n  r1.appendChild(selCol); r1.appendChild(SL.propSD.el);\n  wrapper.appendChild(r1);\n\n  // Buttons\n  const btnNext = createButton(\"▶  Next Sub-step\", \"step\");\n  const btnFull = createButton(\"⏩  Full Step\", \"auto\");\n  const btnAuto = createButton(\"🔄  Auto (×50)\", \"go\");\n  const btnReset = createButton(\"↺  Reset\", \"reset\");\n\n  const r2 = document.createElement(\"div\"); r2.style.cssText = \"display:flex;gap:10px;width:100%;margin-bottom:14px;padding-bottom:14px;border-bottom:1px solid #e2e8f0;\";\n  r2.appendChild(btnNext.el); r2.appendChild(btnFull.el); r2.appendChild(btnAuto.el); r2.appendChild(btnReset.el);\n  wrapper.appendChild(r2);\n\n  // ══════════════════════════════════════════════════════\n  // 4. STEP INDICATOR (5 tabs)\n  // ══════════════════════════════════════════════════════\n  const stepNames = [\"① Position\", \"② Propose\", \"③ Evaluate\", \"④ Accept?\", \"⑤ Record\"];\n  const stepColors = [\"#3b82f6\", \"#7c3aed\", \"#d97706\", \"#dc2626\", \"#16a34a\"];\n\n  const stepBox = document.createElement(\"div\"); stepBox.className = \"mc-step-box\";\n  const stepHeader = document.createElement(\"div\"); stepHeader.className = \"mc-step-header\";\n  const tabs = [];\n  for (let i = 0; i &lt; 5; i++) {\n    const t = document.createElement(\"div\"); t.className = \"mc-step-tab\"; t.textContent = stepNames[i];\n    stepHeader.appendChild(t); tabs.push(t);\n  }\n  const stepBody = document.createElement(\"div\"); stepBody.className = \"mc-step-body\";\n  stepBox.appendChild(stepHeader); stepBox.appendChild(stepBody);\n  wrapper.appendChild(stepBox);\n\n  // ══════════════════════════════════════════════════════\n  // 5. SVG — TARGET + PROPOSAL + MARKERS\n  // ══════════════════════════════════════════════════════\n  const NS = \"http://www.w3.org/2000/svg\";\n  const SW = 920, SH = 300;\n  const mg = { t: 20, r: 20, b: 40, l: 50 };\n  const sw = SW - mg.l - mg.r, sh = SH - mg.t - mg.b;\n\n  function mkEl(tag, a) {\n    const e = document.createElementNS(NS, tag);\n    if (a) for (const [k, v] of Object.entries(a)) e.setAttribute(k, v);\n    return e;\n  }\n\n  const svg = document.createElementNS(NS, \"svg\");\n  svg.setAttribute(\"viewBox\", `0 0 ${SW} ${SH}`);\n  svg.style.cssText = `width:100%;max-width:${SW}px;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;margin-bottom:10px;`;\n\n  // Target curve (filled)\n  const targetFill = mkEl(\"path\", { fill: \"#e0e7ff\", opacity: \"0.5\", stroke: \"none\" });\n  svg.appendChild(targetFill);\n  const targetPath = mkEl(\"path\", { fill: \"none\", stroke: \"#475569\", \"stroke-width\": \"2.5\" });\n  svg.appendChild(targetPath);\n\n  // Proposal distribution (dashed bell curve)\n  const propFill = mkEl(\"path\", { fill: \"#f3e8ff\", opacity: \"0.4\", stroke: \"none\" });\n  propFill.style.display = \"none\"; svg.appendChild(propFill);\n  const propPath = mkEl(\"path\", { fill: \"none\", stroke: \"#7c3aed\", \"stroke-width\": \"2\", \"stroke-dasharray\": \"6,4\" });\n  propPath.style.display = \"none\"; svg.appendChild(propPath);\n\n  // Grid + axes\n  const gridLines = [];\n  for (let i = 0; i &lt;= 4; i++) { const l = mkEl(\"line\", { stroke: \"#e2e8f0\", \"stroke-width\": \"0.7\" }); svg.appendChild(l); gridLines.push(l); }\n  const yLbls = [];\n  for (let i = 0; i &lt;= 4; i++) { const t = mkEl(\"text\", { \"text-anchor\": \"end\", fill: \"#94a3b8\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\" }); svg.appendChild(t); yLbls.push(t); }\n\n  svg.appendChild(mkEl(\"line\", { x1: String(mg.l), x2: String(mg.l), y1: String(mg.t), y2: String(mg.t + sh), stroke: \"#94a3b8\" }));\n  const xAx = mkEl(\"line\", { stroke: \"#94a3b8\" }); svg.appendChild(xAx);\n  const xTicks = [];\n  for (let i = 0; i &lt; 11; i++) {\n    const ln = mkEl(\"line\", { stroke: \"#94a3b8\", y2: \"4\" }); svg.appendChild(ln);\n    const t = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\", dy: \"15\" }); svg.appendChild(t);\n    xTicks.push({ ln, t });\n  }\n\n  // Current position marker (blue dot + vertical line)\n  const curLine = mkEl(\"line\", { stroke: \"#3b82f6\", \"stroke-width\": \"2\", \"stroke-dasharray\": \"4,3\", opacity: \"0.7\" });\n  curLine.style.display = \"none\"; svg.appendChild(curLine);\n  const curDot = mkEl(\"circle\", { r: \"8\", fill: \"#3b82f6\", stroke: \"#fff\", \"stroke-width\": \"2.5\" });\n  curDot.style.display = \"none\"; svg.appendChild(curDot);\n  const curLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#3b82f6\", \"font-size\": \"12\", \"font-weight\": \"700\", \"font-family\": \"'SF Mono',monospace\" });\n  curLabel.style.display = \"none\"; svg.appendChild(curLabel);\n\n  // Proposed position marker (purple dot + vertical line)\n  const propLine = mkEl(\"line\", { stroke: \"#7c3aed\", \"stroke-width\": \"2\", \"stroke-dasharray\": \"4,3\", opacity: \"0.7\" });\n  propLine.style.display = \"none\"; svg.appendChild(propLine);\n  const propDot = mkEl(\"circle\", { r: \"8\", fill: \"#7c3aed\", stroke: \"#fff\", \"stroke-width\": \"2.5\" });\n  propDot.style.display = \"none\"; svg.appendChild(propDot);\n  const propLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#7c3aed\", \"font-size\": \"12\", \"font-weight\": \"700\", \"font-family\": \"'SF Mono',monospace\" });\n  propLabel.style.display = \"none\"; svg.appendChild(propLabel);\n\n  // Accept/reject marker\n  const decisionText = mkEl(\"text\", { \"text-anchor\": \"middle\", \"font-size\": \"18\", \"font-weight\": \"700\" });\n  decisionText.style.display = \"none\"; svg.appendChild(decisionText);\n\n  // Arrow from current to proposed\n  const arrow = mkEl(\"line\", { \"stroke-width\": \"2\", \"marker-end\": \"url(#arrowhead)\" });\n  arrow.style.display = \"none\"; svg.appendChild(arrow);\n  // Arrowhead marker\n  const defs = mkEl(\"defs\");\n  const marker = mkEl(\"marker\", { id: \"arrowhead\", markerWidth: \"10\", markerHeight: \"7\", refX: \"10\", refY: \"3.5\", orient: \"auto\" });\n  const arrowPoly = mkEl(\"polygon\", { points: \"0 0, 10 3.5, 0 7\", fill: \"#7c3aed\" });\n  marker.appendChild(arrowPoly); defs.appendChild(marker); svg.appendChild(defs);\n\n  // Y-axis label\n  const yLabel = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"12\", x: \"16\", y: String(mg.t + sh / 2), transform: `rotate(-90,16,${mg.t + sh / 2})` });\n  yLabel.textContent = \"p(\\u03B8)\"; svg.appendChild(yLabel);\n\n  wrapper.appendChild(svg);\n\n  // ══════════════════════════════════════════════════════\n  // 6. HISTOGRAM SVG\n  // ══════════════════════════════════════════════════════\n  const HW = 920, HH = 180;\n  const hm = { t: 20, r: 20, b: 36, l: 50 };\n  const hw = HW - hm.l - hm.r, hh = HH - hm.t - hm.b;\n\n  const hSvg = document.createElementNS(NS, \"svg\");\n  hSvg.setAttribute(\"viewBox\", `0 0 ${HW} ${HH}`);\n  hSvg.style.cssText = `width:100%;max-width:${HW}px;background:#fafbfc;border-radius:10px;border:1px solid #e2e8f0;`;\n\n  const hTtl = mkEl(\"text\", { x: String(HW / 2), y: \"15\", \"text-anchor\": \"middle\", fill: \"#16a34a\", \"font-size\": \"13\", \"font-weight\": \"700\" });\n  hTtl.textContent = \"Collected Samples\"; hSvg.appendChild(hTtl);\n\n  // Bars\n  const NBINS = 40;\n  const hBars = [];\n  for (let i = 0; i &lt; NBINS; i++) {\n    const r = mkEl(\"rect\", { rx: \"1\", fill: \"#16a34a\", opacity: \"0.5\", stroke: \"#15803d\", \"stroke-width\": \"0.5\" });\n    r.style.display = \"none\"; hSvg.appendChild(r); hBars.push(r);\n  }\n  // Overlay target line on histogram\n  const hTargetPath = mkEl(\"path\", { fill: \"none\", stroke: \"#475569\", \"stroke-width\": \"1.5\", \"stroke-dasharray\": \"4,3\", opacity: \"0.5\" });\n  hSvg.appendChild(hTargetPath);\n  // Hist x-axis\n  const hXAx = mkEl(\"line\", { stroke: \"#94a3b8\" }); hSvg.appendChild(hXAx);\n  const hXTicks = [];\n  for (let i = 0; i &lt; 11; i++) {\n    const ln = mkEl(\"line\", { stroke: \"#94a3b8\", y2: \"4\" }); hSvg.appendChild(ln);\n    const t = mkEl(\"text\", { \"text-anchor\": \"middle\", fill: \"#64748b\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\", dy: \"15\" }); hSvg.appendChild(t);\n    hXTicks.push({ ln, t });\n  }\n  // Stats\n  const hStats = mkEl(\"text\", { x: String(HW - 10), y: String(hm.t + 10), \"text-anchor\": \"end\", fill: \"#64748b\", \"font-size\": \"11\", \"font-family\": \"'SF Mono',monospace\" });\n  hSvg.appendChild(hStats);\n\n  wrapper.appendChild(hSvg);\n\n  // ══════════════════════════════════════════════════════\n  // 7. STATE\n  // ══════════════════════════════════════════════════════\n  let currentX = 0.5;\n  let proposedX = 0;\n  let pCurrent = 0, pProposed = 0;\n  let alpha = 0, u = 0, accepted = false;\n  let subStep = 0; // 0..4 (position, propose, evaluate, accept?, record)\n  let samples = [];\n  let totalProposed = 0, totalAccepted = 0;\n  let autoId = 0, autoRunning = false;\n\n  function targetFn() { return targetFns[selDist.value]; }\n\n  // ══════════════════════════════════════════════════════\n  // 8. DRAW TARGET CURVE\n  // ══════════════════════════════════════════════════════\n  let targetMaxY = 1;\n\n  function drawTarget() {\n    const fn = targetFn();\n    // Compute max for scaling\n    targetMaxY = 0;\n    for (let i = 0; i &lt;= 200; i++) {\n      const x = i / 200;\n      const v = fn(x);\n      if (v &gt; targetMaxY) targetMaxY = v;\n    }\n    targetMaxY *= 1.2;\n\n    const sx = x =&gt; mg.l + x * sw;\n    const sy = y =&gt; mg.t + sh - (y / targetMaxY) * sh;\n    const baseline = mg.t + sh;\n\n    // Target filled area\n    let dFill = `M${sx(0)},${baseline}`;\n    let dLine = \"\";\n    for (let i = 0; i &lt;= 200; i++) {\n      const x = i / 200, y = fn(x);\n      const px = sx(x), py = sy(y);\n      dFill += `L${px.toFixed(1)},${py.toFixed(1)}`;\n      dLine += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n    }\n    dFill += `L${sx(1)},${baseline}Z`;\n    targetFill.setAttribute(\"d\", dFill);\n    targetPath.setAttribute(\"d\", dLine);\n\n    // Grid\n    for (let i = 0; i &lt;= 4; i++) {\n      const v = (targetMaxY / 4) * i, yy = sy(v);\n      gridLines[i].setAttribute(\"x1\", mg.l); gridLines[i].setAttribute(\"x2\", SW - mg.r);\n      gridLines[i].setAttribute(\"y1\", yy); gridLines[i].setAttribute(\"y2\", yy);\n      yLbls[i].setAttribute(\"x\", mg.l - 6); yLbls[i].setAttribute(\"y\", yy + 4);\n      yLbls[i].textContent = v.toFixed(2);\n    }\n\n    // X axis\n    xAx.setAttribute(\"x1\", mg.l); xAx.setAttribute(\"x2\", SW - mg.r);\n    xAx.setAttribute(\"y1\", baseline); xAx.setAttribute(\"y2\", baseline);\n    for (let i = 0; i &lt;= 10; i++) {\n      const x = i / 10, px = sx(x);\n      xTicks[i].ln.setAttribute(\"x1\", px); xTicks[i].ln.setAttribute(\"x2\", px);\n      xTicks[i].ln.setAttribute(\"y1\", baseline); xTicks[i].ln.setAttribute(\"y2\", baseline + 4);\n      xTicks[i].t.setAttribute(\"x\", px); xTicks[i].t.setAttribute(\"y\", baseline + 4);\n      xTicks[i].t.textContent = x.toFixed(1);\n    }\n\n    // Histogram x-axis\n    const hBaseline = hm.t + hh;\n    hXAx.setAttribute(\"x1\", hm.l); hXAx.setAttribute(\"x2\", HW - hm.r);\n    hXAx.setAttribute(\"y1\", hBaseline); hXAx.setAttribute(\"y2\", hBaseline);\n    for (let i = 0; i &lt;= 10; i++) {\n      const x = i / 10, px = hm.l + x * hw;\n      hXTicks[i].ln.setAttribute(\"x1\", px); hXTicks[i].ln.setAttribute(\"x2\", px);\n      hXTicks[i].ln.setAttribute(\"y1\", hBaseline); hXTicks[i].ln.setAttribute(\"y2\", hBaseline + 4);\n      hXTicks[i].t.setAttribute(\"x\", px); hXTicks[i].t.setAttribute(\"y\", hBaseline + 4);\n      hXTicks[i].t.textContent = x.toFixed(1);\n    }\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 9. DRAW MARKERS\n  // ══════════════════════════════════════════════════════\n  function drawMarkers() {\n    const fn = targetFn();\n    const sx = x =&gt; mg.l + x * sw;\n    const sy = y =&gt; mg.t + sh - (y / targetMaxY) * sh;\n    const baseline = mg.t + sh;\n\n    // Current position\n    if (subStep &gt;= 0) {\n      const px = sx(currentX), py = sy(fn(currentX));\n      curLine.setAttribute(\"x1\", px); curLine.setAttribute(\"x2\", px);\n      curLine.setAttribute(\"y1\", py); curLine.setAttribute(\"y2\", baseline);\n      curLine.style.display = \"\";\n      curDot.setAttribute(\"cx\", px); curDot.setAttribute(\"cy\", py);\n      curDot.style.display = \"\";\n      curLabel.setAttribute(\"x\", px); curLabel.setAttribute(\"y\", py - 14);\n      curLabel.textContent = `current = ${currentX.toFixed(3)}`;\n      curLabel.style.display = \"\";\n    }\n\n    // Proposal distribution bell\n    if (subStep &gt;= 1) {\n      const propSig = SL.propSD.val();\n      // Draw proposal gaussian centered at currentX\n      let pFill = `M${sx(0)},${baseline}`;\n      let pLine = \"\";\n      const propScale = targetMaxY * 0.35; // scale proposal to ~35% of target height\n      for (let i = 0; i &lt;= 200; i++) {\n        const x = i / 200;\n        const y = gaussPDF(x, currentX, propSig) * propScale;\n        const px = sx(x), py = sy(y);\n        pFill += `L${px.toFixed(1)},${py.toFixed(1)}`;\n        pLine += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n      }\n      pFill += `L${sx(1)},${baseline}Z`;\n      propFill.setAttribute(\"d\", pFill); propFill.style.display = \"\";\n      propPath.setAttribute(\"d\", pLine); propPath.style.display = \"\";\n    } else {\n      propFill.style.display = \"none\"; propPath.style.display = \"none\";\n    }\n\n    // Proposed point\n    if (subStep &gt;= 1) {\n      const px = sx(proposedX), py = sy(fn(proposedX));\n      propLine.setAttribute(\"x1\", px); propLine.setAttribute(\"x2\", px);\n      propLine.setAttribute(\"y1\", py); propLine.setAttribute(\"y2\", baseline);\n      propLine.style.display = \"\";\n      propDot.setAttribute(\"cx\", px); propDot.setAttribute(\"cy\", py);\n      propDot.style.display = \"\";\n      propLabel.setAttribute(\"x\", px); propLabel.setAttribute(\"y\", py - 14);\n      propLabel.textContent = `proposed = ${proposedX.toFixed(3)}`;\n      propLabel.style.display = \"\";\n\n      // Arrow\n      const cpx = sx(currentX), cpy = sy(fn(currentX));\n      arrow.setAttribute(\"x1\", cpx); arrow.setAttribute(\"y1\", cpy);\n      arrow.setAttribute(\"x2\", px); arrow.setAttribute(\"y2\", py);\n      arrow.setAttribute(\"stroke\", \"#7c3aed\");\n      arrow.style.display = \"\";\n      arrowPoly.setAttribute(\"fill\", \"#7c3aed\");\n    } else {\n      propLine.style.display = \"none\"; propDot.style.display = \"none\";\n      propLabel.style.display = \"none\"; arrow.style.display = \"none\";\n    }\n\n    // Decision text\n    if (subStep &gt;= 3) {\n      const px = sx((currentX + proposedX) / 2);\n      decisionText.setAttribute(\"x\", px);\n      decisionText.setAttribute(\"y\", mg.t + 16);\n      if (subStep === 3) {\n        decisionText.textContent = `\\u03B1 = ${alpha.toFixed(3)}, u = ${u.toFixed(3)} → ${accepted ? \"u &lt; \\u03B1\" : \"u \\u2265 \\u03B1\"}`;\n        decisionText.setAttribute(\"fill\", accepted ? \"#16a34a\" : \"#dc2626\");\n      } else {\n        decisionText.textContent = accepted ? \"\\u2713 Accepted — move!\" : \"\\u2717 Rejected — stay\";\n        decisionText.setAttribute(\"fill\", accepted ? \"#16a34a\" : \"#dc2626\");\n      }\n      decisionText.style.display = \"\";\n    } else {\n      decisionText.style.display = \"none\";\n    }\n\n    // After record step, color the dots\n    if (subStep === 4) {\n      if (accepted) {\n        propDot.setAttribute(\"fill\", \"#16a34a\"); propDot.setAttribute(\"r\", \"10\");\n        curDot.setAttribute(\"fill\", \"#94a3b8\"); curDot.setAttribute(\"opacity\", \"0.4\");\n      } else {\n        curDot.setAttribute(\"fill\", \"#16a34a\"); curDot.setAttribute(\"r\", \"10\");\n        propDot.setAttribute(\"fill\", \"#94a3b8\"); propDot.setAttribute(\"opacity\", \"0.4\");\n      }\n    } else {\n      curDot.setAttribute(\"fill\", \"#3b82f6\"); curDot.setAttribute(\"r\", \"8\"); curDot.setAttribute(\"opacity\", \"1\");\n      propDot.setAttribute(\"fill\", \"#7c3aed\"); propDot.setAttribute(\"r\", \"8\"); propDot.setAttribute(\"opacity\", \"1\");\n    }\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 10. DRAW HISTOGRAM\n  // ══════════════════════════════════════════════════════\n  function drawHistogram() {\n    const hBaseline = hm.t + hh;\n    if (samples.length === 0) {\n      for (let i = 0; i &lt; NBINS; i++) hBars[i].style.display = \"none\";\n      hTargetPath.style.display = \"none\";\n      hStats.textContent = \"\";\n      hTtl.textContent = \"Collected Samples (0)\";\n      return;\n    }\n\n    const bins = new Int32Array(NBINS);\n    for (const s of samples) {\n      const bi = Math.min(NBINS - 1, Math.max(0, Math.floor(s * NBINS)));\n      bins[bi]++;\n    }\n    const maxBin = Math.max(...bins) * 1.2 || 1;\n    const barW = hw / NBINS;\n\n    for (let i = 0; i &lt; NBINS; i++) {\n      if (bins[i] &gt; 0) {\n        const bx = hm.l + i * barW;\n        const bh = (bins[i] / maxBin) * hh;\n        hBars[i].setAttribute(\"x\", bx); hBars[i].setAttribute(\"y\", hBaseline - bh);\n        hBars[i].setAttribute(\"width\", Math.max(1, barW - 1)); hBars[i].setAttribute(\"height\", bh);\n        hBars[i].style.display = \"\";\n      } else { hBars[i].style.display = \"none\"; }\n    }\n\n    // Overlay target (scaled to match histogram)\n    const fn = targetFn();\n    let tMax = 0;\n    for (let i = 0; i &lt; NBINS; i++) { const x = (i + 0.5) / NBINS; const v = fn(x); if (v &gt; tMax) tMax = v; }\n    const scale = (maxBin &gt; 0 && tMax &gt; 0) ? (Math.max(...bins) / tMax) : 1;\n\n    let d = \"\";\n    for (let i = 0; i &lt;= 200; i++) {\n      const x = i / 200, v = fn(x) * scale;\n      const px = hm.l + x * hw, py = hBaseline - (v / maxBin) * hh;\n      d += (i === 0 ? \"M\" : \"L\") + px.toFixed(1) + \",\" + py.toFixed(1);\n    }\n    hTargetPath.setAttribute(\"d\", d); hTargetPath.style.display = \"\";\n\n    const rate = totalProposed &gt; 0 ? (totalAccepted / totalProposed * 100).toFixed(0) : \"—\";\n    hStats.textContent = `Acceptance: ${rate}%`;\n    hTtl.textContent = `Collected Samples (${samples.length})`;\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 11. STEP TABS\n  // ══════════════════════════════════════════════════════\n  function updateTabs() {\n    for (let i = 0; i &lt; 5; i++) {\n      tabs[i].className = \"mc-step-tab\";\n      tabs[i].style.background = \"#f8fafc\";\n      tabs[i].style.color = \"#94a3b8\";\n      if (i &lt; subStep) {\n        tabs[i].className = \"mc-step-tab done\";\n        tabs[i].style.background = stepColors[i]; tabs[i].style.color = \"#fff\"; tabs[i].style.opacity = \"0.4\";\n      } else if (i === subStep) {\n        tabs[i].className = \"mc-step-tab active\";\n        tabs[i].style.background = stepColors[i]; tabs[i].style.color = \"#fff\"; tabs[i].style.opacity = \"1\";\n      }\n    }\n\n    const fn = targetFn();\n    const fmtP = v =&gt; v &lt; 0.001 ? v.toExponential(2) : v.toFixed(4);\n\n    if (subStep === 0) {\n      stepBody.innerHTML =\n        `We are at &lt;b style=\"color:#3b82f6\"&gt;\\u03B8 = ${currentX.toFixed(3)}&lt;/b&gt; ` +\n        `where the target density is &lt;b&gt;p(\\u03B8) = ${fmtP(fn(currentX))}&lt;/b&gt;.`;\n    } else if (subStep === 1) {\n      stepBody.innerHTML =\n        `Propose a new value from &lt;b style=\"color:#7c3aed\"&gt;Normal(\\u03B8, \\u03C3\\u00B2)&lt;/b&gt; = Normal(${currentX.toFixed(3)}, ${SL.propSD.val().toFixed(2)}\\u00B2).&lt;br&gt;` +\n        `Drew &lt;b style=\"color:#7c3aed\"&gt;\\u03B8* = ${proposedX.toFixed(3)}&lt;/b&gt;. ` +\n        `The dashed purple curve shows the proposal distribution.`;\n    } else if (subStep === 2) {\n      stepBody.innerHTML =\n        `Evaluate the target at both points:&lt;br&gt;` +\n        `&lt;b style=\"color:#3b82f6\"&gt;p(\\u03B8) = ${fmtP(pCurrent)}&lt;/b&gt; &ensp;(current) &ensp;&ensp; ` +\n        `&lt;b style=\"color:#7c3aed\"&gt;p(\\u03B8*) = ${fmtP(pProposed)}&lt;/b&gt; &ensp;(proposed)&lt;br&gt;` +\n        `Acceptance ratio: &lt;b&gt;\\u03B1 = min(1, p(\\u03B8*)/p(\\u03B8)) = min(1, ${(pProposed / pCurrent).toFixed(4)}) = ${alpha.toFixed(4)}&lt;/b&gt;`;\n    } else if (subStep === 3) {\n      stepBody.innerHTML =\n        `Draw &lt;b&gt;u ~ Uniform(0,1)&lt;/b&gt; = &lt;b&gt;${u.toFixed(4)}&lt;/b&gt;.&lt;br&gt;` +\n        (accepted\n          ? `&lt;b style=\"color:#16a34a\"&gt;u = ${u.toFixed(4)} &lt; \\u03B1 = ${alpha.toFixed(4)} → Accept!&lt;/b&gt; Move to \\u03B8* = ${proposedX.toFixed(3)}.`\n          : `&lt;b style=\"color:#dc2626\"&gt;u = ${u.toFixed(4)} \\u2265 \\u03B1 = ${alpha.toFixed(4)} → Reject.&lt;/b&gt; Stay at \\u03B8 = ${currentX.toFixed(3)}.`);\n    } else if (subStep === 4) {\n      const recorded = accepted ? proposedX : currentX;\n      stepBody.innerHTML =\n        `Record &lt;b style=\"color:#16a34a\"&gt;\\u03B8 = ${recorded.toFixed(3)}&lt;/b&gt; as sample #${samples.length}. ` +\n        (accepted ? \"Moved to the proposed point.\" : \"Stayed at the current point (recorded again).\") +\n        `&lt;br&gt;Click &lt;b&gt;Next&lt;/b&gt; to start the next iteration.`;\n    }\n  }\n\n  // ══════════════════════════════════════════════════════\n  // 12. ACTIONS\n  // ══════════════════════════════════════════════════════\n  function doSubStep() {\n    const fn = targetFn();\n    const propSig = SL.propSD.val();\n\n    if (subStep === 0) {\n      // Position: already set, move to propose\n      subStep = 1;\n      // Generate proposal\n      proposedX = currentX + (Math.random() - 0.5) * 2 * propSig * 2.5; // ~Normal approx\n      // Better: Box-Muller\n      const u1 = Math.random(), u2 = Math.random();\n      proposedX = currentX + propSig * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n      proposedX = Math.max(0.001, Math.min(0.999, proposedX));\n    } else if (subStep === 1) {\n      // Evaluate\n      subStep = 2;\n      pCurrent = fn(currentX);\n      pProposed = fn(proposedX);\n      alpha = Math.min(1, pProposed / Math.max(pCurrent, 1e-30));\n    } else if (subStep === 2) {\n      // Accept/reject decision\n      subStep = 3;\n      u = Math.random();\n      accepted = u &lt; alpha;\n      totalProposed++;\n      if (accepted) totalAccepted++;\n    } else if (subStep === 3) {\n      // Record\n      subStep = 4;\n      const recorded = accepted ? proposedX : currentX;\n      samples.push(recorded);\n      if (accepted) currentX = proposedX;\n    } else if (subStep === 4) {\n      // Start next iteration\n      subStep = 0;\n    }\n\n    drawMarkers();\n    updateTabs();\n    drawHistogram();\n  }\n\n  function doFullStep() {\n    // Run through remaining sub-steps of current iteration + if at start, do full\n    if (subStep === 4) doSubStep(); // advance to next iter\n    while (subStep !== 4) doSubStep();\n  }\n\n  function doAuto50() {\n    if (autoRunning) { clearInterval(autoId); autoRunning = false; btnAuto.setText(\"🔄  Auto (×50)\"); return; }\n    autoRunning = true; btnAuto.setText(\"⏸  Stop\");\n    let count = 0;\n    autoId = setInterval(() =&gt; {\n      doFullStep();\n      if (subStep === 4) doSubStep(); // advance\n      count++;\n      if (count &gt;= 50) { clearInterval(autoId); autoRunning = false; btnAuto.setText(\"🔄  Auto (×50)\"); }\n    }, 80);\n  }\n\n  function doReset() {\n    clearInterval(autoId); autoRunning = false; btnAuto.setText(\"🔄  Auto (×50)\");\n    currentX = 0.5; subStep = 0; samples = [];\n    totalProposed = 0; totalAccepted = 0;\n    drawTarget(); drawMarkers(); updateTabs(); drawHistogram();\n  }\n\n  btnNext.el.addEventListener(\"click\", doSubStep);\n  btnFull.el.addEventListener(\"click\", () =&gt; { doFullStep(); });\n  btnAuto.el.addEventListener(\"click\", doAuto50);\n  btnReset.el.addEventListener(\"click\", doReset);\n\n  function onParam() { SL.propSD.sync(); }\n  SL.propSD.input.addEventListener(\"input\", onParam);\n  selDist.addEventListener(\"change\", doReset);\n\n  // Init\n  doReset();\n\n  invalidation.then(() =&gt; {\n    clearInterval(autoId);\n    btnNext.el.removeEventListener(\"click\", doSubStep);\n    btnFull.el.removeEventListener(\"click\", doFullStep);\n    btnAuto.el.removeEventListener(\"click\", doAuto50);\n    btnReset.el.removeEventListener(\"click\", doReset);\n    SL.propSD.input.removeEventListener(\"input\", onParam);\n    samples = [];\n  });\n\n  wrapper.value = {};\n  return wrapper;\n})()",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "thanks.html",
    "href": "thanks.html",
    "title": "Lời cảm ơn",
    "section": "",
    "text": "Em Thịnh xin gửi lời cảm ơn chân thành đến:\n\nTS. Marc Choisy, GS. Louise Thwaites, GS. Ronald Geskus (mặc dù các thầy cô không hiểu tiếng Việt). Cảm ơn các thầy cô đã kiên nhẫn hướng dẫn, chia sẻ tài liệu và định hình sự nghiệp của em. Sự dẫn dắt này đã thực sự thay đổi cuộc đời em từ khi bắt đầu làm NCS\nTS. Lưu Phúc Lợi. Cảm ơn thầy đã dạy em những bước đầu tiên về thống kê và lập trình, giúp em hết sợ code và công thức toán, giới thiệu giáo trình “STATS 210: Statistical Theory” và luôn hỗ trợ em từ chuyện chuyên môn đến những vấn đề cá nhân",
    "crumbs": [
      "Lời cảm ơn"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Tài liệu tham khảo",
    "section": "",
    "text": "Bolker, Benjamin M. 2008. Ecological Models and Data in R.\nPrinceton University Press. https://doi.org/10.1515/9781400840908.\n\n\nClauset, Aaron, Cosma Rohilla Shalizi, and M. E. J. Newman. 2009.\n“Power-Law Distributions in Empirical Data.” SIAM\nReview 51 (4): 661–703. https://doi.org/10.1137/070710111.\n\n\nDaniel, Wayne W., and Chad L. Cross. 2018. Biostatistics: A\nFoundation for Analysis in the Health Sciences. John Wiley &\nSons.\n\n\nKoch, Arthur L. 1966. “The Logarithm in Biology 1. Mechanisms\nGenerating the Log-Normal Distribution Exactly.” Journal of\nTheoretical Biology 12 (2): 276–90. https://doi.org/10.1016/0022-5193(66)90119-6.\n\n\nMotulsky, Harvey J., Trajen Head, and Paul B. S. Clarke. 2025.\n“Analyzing Lognormal Data: A Nonmathematical Practical\nGuide.” Pharmacological Reviews 77 (3): 100049. https://doi.org/10.1016/j.pharmr.2025.100049.\n\n\nRaue, A., V. Becker, U. Klingmüller, and J. Timmer. 2010.\n“Identifiability and Observability Analysis for Experimental\nDesign in Nonlinear Dynamical Models.” Chaos: An\nInterdisciplinary Journal of Nonlinear Science 20 (4): 045105. https://doi.org/10.1063/1.3528102.\n\n\nStevens, S. S. 1946. “On the Theory of Scales of\nMeasurement.” Science 103 (2684): 677–80. https://doi.org/10.1126/science.103.2684.677.",
    "crumbs": [
      "Tài liệu tham khảo"
    ]
  },
  {
    "objectID": "distr-c.html#phân-loại",
    "href": "distr-c.html#phân-loại",
    "title": "Phân phối liên tục",
    "section": "",
    "text": "Phép tính cơ bản trên biến ngẫu nhiên\nPhép cộng: Normal\nPhép nhân: Log-normal\n\n\nThời gian chờ\ngiá trị từ \\((0, +\\infty)\\)\n\nPhân phối mũ (Exponential)\nGamma: là tổng k exponential\nWeibull\n\n\n\nKhoảng giới hạn\ngiá trị từ \\([0, 1]\\)\n\nUniform\nBeta",
    "crumbs": [
      "Phân phối liên tục"
    ]
  }
]