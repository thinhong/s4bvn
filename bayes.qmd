---
title: "Bayesian"
format: html
---

## Xác suất có điều kiện

Xác suất có điều kiện thực chất là thu nhỏ không gian mẫu.

Ví dụ, tại một ngôi trường có 3 lớp A, B, C với số lượng học sinh như sau:

|       | Nam | Nữ  | Tổng |
|-------|-----|-----|------|
| Lớp A | 30  | 10  | 40   |
| Lớp B | 20  | 20  | 40   |
| Lớp C | 15  | 25  | 40   |
| Tổng  | 65  | 55  | 120  |

Chọn ngẫu nhiên 1 học sinh trong trường.

**1. Xác suất không điều kiện**

Tính xác suất học sinh này là Nữ?

Lúc này không gian mẫu là toàn bộ ngôi trường.

$$\mathbb{P}(\text{Nữ}) = \frac{\overbrace{55}^{\text{Tổng số Nữ toàn trường}}}{\underbrace{120}_{\text{Tổng số học sinh toàn trường}}} \approx 45.8\%$$

**2. Xác suất có điều kiện**

Biết rằng học sinh được chọn ở Lớp A. Tính xác suất học sinh này là Nữ?

Thông tin "Học sinh Lớp A" đã làm thu nhỏ không gian mẫu. Không gian mẫu lúc này chỉ là Học sinh lớp A thôi.

$$\mathbb{P}(\text{Nữ} | \text{Lớp A}) = \frac{\overbrace{10}^{\text{Số Nữ trong Lớp A}}}{\underbrace{40}_{\text{Tổng sĩ số Lớp A}}} = 25.0\%$$

```{ojs}
//| echo: false
viewof classroom_prob_sharp = (() => {
  // --- 1. SETUP ---
  const wrapper = document.createElement("div");
  wrapper.style.cssText = `
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    margin-top: 20px;
    width: 100%;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
  `;

  // --- 2. DATA ---
  const CLASSES = {
    A: { boys: 30, girls: 10, color: "#ef4444" }, 
    B: { boys: 20, girls: 20, color: "#3b82f6" }, 
    C: { boys: 15, girls: 25, color: "#10b981" } 
  };
  
  const students = [];
  Object.keys(CLASSES).forEach(cls => {
    const data = CLASSES[cls];
    for(let i=0; i<data.boys; i++) students.push({ id: `b-${cls}-${i}`, cls: cls, gender: "Nam", color: data.color });
    for(let i=0; i<data.girls; i++) students.push({ id: `g-${cls}-${i}`, cls: cls, gender: "Nữ", color: data.color });
  });

  // --- 3. CONTROLS ---
  const controlPanel = document.createElement("div");
  controlPanel.style.cssText = `
    background: #ffffff;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 24px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    gap: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    width: 100%;
    box-sizing: border-box;
  `;

  function createSelect(options) {
    const sel = document.createElement("select");
    sel.style.cssText = `
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background-color: #f9fafb;
      font-size: 14px;
      font-weight: 600;
      color: #1e293b;
      cursor: pointer;
    `;
    options.forEach(opt => {
      const el = document.createElement("option");
      el.value = opt.val;
      el.textContent = opt.label;
      sel.appendChild(el);
    });
    return sel;
  }

  const targetOpts = [
    {val: "Nam", label: "Học sinh Nam"},
    {val: "Nữ", label: "Học sinh Nữ"},
    {val: "A", label: "Học sinh Lớp A"},
    {val: "B", label: "Học sinh Lớp B"},
    {val: "C", label: "Học sinh Lớp C"}
  ];

  const givenOpts = [
    {val: "Universe", label: "Toàn trường"},
    {val: "A", label: "Học sinh Lớp A"},
    {val: "B", label: "Học sinh Lớp B"},
    {val: "C", label: "Học sinh Lớp C"},
    {val: "Nam", label: "Đó là Nam"},
    {val: "Nữ", label: "Đó là Nữ"}
  ];

  const selTarget = createSelect(targetOpts);
  const selGiven = createSelect(givenOpts);
  selTarget.value = "Nữ";
  selGiven.value = "A";

  const t1 = document.createElement("span"); t1.textContent = "Tính xác suất chọn"; t1.style.color = "#334155";
  const t2 = document.createElement("span"); t2.textContent = "biết rằng"; t2.style.color = "#334155";

  controlPanel.appendChild(t1);
  controlPanel.appendChild(selTarget);
  controlPanel.appendChild(t2);
  controlPanel.appendChild(selGiven);
  wrapper.appendChild(controlPanel);

  // --- 4. CANVAS (High Resolution) ---
  const canvas = document.createElement("canvas");
  const logicalW = 800;
  const logicalH = 340; 
  
  // Set Display Size (CSS)
  canvas.style.width = `${logicalW}px`;
  canvas.style.height = `${logicalH}px`;
  // Responsive Max Width
  canvas.style.maxWidth = "100%";
  canvas.style.height = "auto";
  
  // Set Actual Pixel Size (High DPI)
  const dpr = window.devicePixelRatio || 1;
  canvas.width = logicalW * dpr;
  canvas.height = logicalH * dpr;
  
  const ctx = canvas.getContext("2d");
  // Scale drawing operations so we can use logical coordinates
  ctx.scale(dpr, dpr);
  wrapper.appendChild(canvas);

  // --- 5. MATH PANEL ---
  const mathDiv = document.createElement("div");
  mathDiv.style.cssText = `
    font-size: 18px;
    margin-top: 20px; 
    margin-bottom: 10px;
    text-align: center;
    line-height: 1.6;
    width: 100%;
  `;
  wrapper.appendChild(mathDiv);

  // --- 6. GEOMETRY PRE-CALCULATION ---
  const boxW = 180;
  const boxH = 300; 
  const gap = 24;   
  const startX = (logicalW - (3 * boxW + 2 * gap)) / 2;
  const startY = 10;

  const dotCols = 5;
  const dotDiam = 13;   
  const dotGap = 13;    
  const gridWidth = (dotCols * dotDiam) + ((dotCols - 1) * dotGap);
  const dotRad = dotDiam / 2;

  const posMap = {}; 
  ['A', 'B', 'C'].forEach((cls, i) => {
     const clsStudents = students.filter(s => s.cls === cls);
     const bx = startX + i * (boxW + gap);
     const by = startY;
     const gridStartX = bx + (boxW - gridWidth) / 2 + dotRad;
     const gridStartY = by + 80; 
     
     clsStudents.forEach((s, idx) => {
        const c = idx % dotCols;
        const r = Math.floor(idx / dotCols);
        posMap[s.id] = {
            x: gridStartX + c * (dotDiam + dotGap),
            y: gridStartY + r * (dotDiam + dotGap),
            bx: bx, by: by 
        };
     });
  });

  // --- 7. LOGIC ---
  function check(student, condition) {
    if (condition === "Universe") return true;
    if (condition === "A" || condition === "B" || condition === "C") return student.cls === condition;
    if (condition === "Nam" || condition === "Nữ") return student.gender === condition;
    return false;
  }

  function update() {
    const targetCond = selTarget.value;
    const givenCond = selGiven.value;
    const validUniverse = students.filter(s => check(s, givenCond));
    const validTarget = validUniverse.filter(s => check(s, targetCond));
    const num = validTarget.length;
    const den = validUniverse.length;
    const prob = den === 0 ? 0 : ((num / den) * 100).toFixed(1);

    const dict = {
        "Nam": "Nam", "Nữ": "Nữ",
        "A": "Lớp A", "B": "Lớp B", "C": "Lớp C",
        "Universe": "Toàn trường"
    };

    // Cleaned up text, 18px base size
    mathDiv.innerHTML = `
      <div style="display:inline-block; padding: 15px 30px; background:#f8fafc; border-radius:12px; border:1px solid #e2e8f0;">
        <div style="font-size: 18px; color:#0f172a; line-height: 1.4;">
          P(${dict[targetCond] || targetCond} | ${dict[givenCond] || givenCond}) = 
          <span style="color: #be185d; font-weight: bold;">${num}</span> 
          / 
          <span style="color: #0f172a; font-weight: bold;">${den}</span> 
          = <b>${prob}%</b>
        </div>
      </div>
    `;

    drawScene(givenCond, targetCond, validUniverse, validTarget);
  }

  function drawScene(given, target, universeSet, targetSet) {
    ctx.clearRect(0, 0, logicalW, logicalH);
    
    // Draw Boxes
    ['A', 'B', 'C'].forEach((cls, i) => {
       const bx = startX + i * (boxW + gap);
       const by = startY;
       const boxHasUniverse = universeSet.some(s => s.cls === cls);
       
       if (given === cls) {
           ctx.fillStyle = "#eff6ff"; ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 3;
           ctx.shadowColor = "rgba(59, 130, 246, 0.15)"; ctx.shadowBlur = 15; ctx.shadowOffsetY = 4;
       } else if (boxHasUniverse) {
           ctx.fillStyle = "#ffffff"; ctx.strokeStyle = "#cbd5e1"; ctx.lineWidth = 1.5;
           ctx.shadowColor = "rgba(0,0,0,0)";
       } else {
           ctx.fillStyle = "#f8fafc"; ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
           ctx.shadowColor = "rgba(0,0,0,0)";
       }

       ctx.beginPath();
       ctx.roundRect(bx, by, boxW, boxH, 16);
       ctx.fill();
       ctx.stroke();
       ctx.shadowColor = "rgba(0,0,0,0)";

       // Text
       ctx.textAlign = "center";
       ctx.fillStyle = boxHasUniverse ? "#1e293b" : "#cbd5e1";
       ctx.font = "bold 20px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
       ctx.fillText(`Lớp ${cls}`, bx + boxW/2, by + 35);
       
       const count = CLASSES[cls];
       ctx.font = "500 13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
       ctx.fillStyle = boxHasUniverse ? "#64748b" : "#e2e8f0";
       ctx.fillText(`${count.boys} Nam • ${count.girls} Nữ`, bx + boxW/2, by + 56);
       
       if (boxHasUniverse) {
         ctx.beginPath(); ctx.strokeStyle = "#f1f5f9"; ctx.lineWidth = 1;
         ctx.moveTo(bx + 30, by + 68); ctx.lineTo(bx + boxW - 30, by + 68); ctx.stroke();
       }
    });

    // Draw Students
    students.forEach(s => {
        const pos = posMap[s.id];
        const isUniverse = universeSet.includes(s);
        const isTarget = targetSet.includes(s);

        let alpha = 0.1;
        let radius = 6;
        let color = "#e5e7eb"; 

        if (isUniverse) {
            alpha = 0.4;
            color = s.gender === "Nam" ? "#60a5fa" : "#f472b6"; 
        }
        
        if (isTarget) {
            alpha = 1.0; 
            radius = 7.5;
            color = s.gender === "Nam" ? "#2563eb" : "#db2777";
        } else if (!isUniverse) {
             color = "#f1f5f9"; 
        }

        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI*2);
        ctx.fill();

        if (isTarget) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffffff";
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius + 1.5, 0, Math.PI*2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.4;
            ctx.stroke();
        }
    });
    ctx.globalAlpha = 1.0;
  }

  selTarget.addEventListener("change", update);
  selGiven.addEventListener("change", update);
  
  update();

  return wrapper;
})();
```

## Định lý Bayes

Trong ví dụ chọn ngẫu nhiên 1 học sinh trong trường, chúng ta có hai câu hỏi trái ngược nhau:

- Nếu đã biết là học sinh Lớp A, xác suất đó là Nữ là bao nhiêu?

$$\begin{aligned}
\mathbb{P}(\text{Nữ} | \text{Lớp A}) &= \frac{\text{Số Nữ trong Lớp A}}{\text{Tổng sĩ số Lớp A}} \\[10pt]
\Leftrightarrow \text{Số Nữ trong Lớp A} &= \mathbb{P}(\text{Nữ} | \text{Lớp A}) \times \text{Tổng sĩ số Lớp A} \quad (1)
\end{aligned}$$

- Nếu đã biết là Nữ, xác suất đó là học sinh Lớp A là bao nhiêu?

$$\begin{aligned}
\mathbb{P}(\text{Lớp A} | \text{Nữ}) &= \frac{\text{Số Nữ trong Lớp A}}{\text{Tổng số Nữ toàn trường}} \\[10pt]
\Leftrightarrow \text{Số Nữ trong Lớp A} &= \mathbb{P}(\text{Lớp A} | \text{Nữ}) \times \text{Tổng số Nữ toàn trường} \quad (2)
\end{aligned}$$

Từ $(1)$ và $(2)$ ta thấy vế trái đều là $\text{Số Nữ trong Lớp A}$, vậy:

$$\begin{aligned}
\mathbb{P}(\text{Lớp A} | \text{Nữ}) \times \text{Tổng Nữ} &= \mathbb{P}(\text{Nữ} | \text{Lớp A}) \times \text{Tổng Lớp A} \\[10pt]
\Leftrightarrow \mathbb{P}(\text{Lớp A} | \text{Nữ}) &= \frac{\mathbb{P}(\text{Nữ} | \text{Lớp A}) \times \text{Tổng Lớp A}}{\text{Tổng Nữ}}
\end{aligned}$$

Chia cả Tử số và Mẫu số cho Tổng số học sinh toàn trường:

$$\begin{aligned}
\mathbb{P}(\text{Lớp A} | \text{Nữ}) &= \frac{\mathbb{P}(\text{Nữ} | \text{Lớp A}) \times \text{Tổng Lớp A}}{\text{Tổng Nữ}} \\
&= \frac{\mathbb{P}(\text{Nữ} | \text{Lớp A}) \times \frac{\text{Tổng Lớp A}}{\text{Tổng HS}}}{\frac{\text{Tổng Nữ}}{\text{Tổng HS}}} \\
&= \frac{\mathbb{P}(\text{Nữ} | \text{Lớp A}) \times \mathbb{P}(\text{Lớp A})}{\mathbb{P}(\text{Nữ})} \quad (3)
\end{aligned}$$

Đặt $A = \text{Lớp A}$, $B = \text{Nữ}$. Thay vào $(3)$, ta có **Định lý Bayes**:

$$\mathbb{P}(A | B) = \frac{\mathbb{P}(B | A) \times \mathbb{P}(A)}{\mathbb{P}(B)}$$

## Ví dụ

Bạn đang muốn tìm một đối tượng để hẹn hò nghiêm túc. Bạn có 2 ứng viên mập mờ tiềm năng: A và B. Bạn cần quyết định chọn ai trong 2 người để thực sự nghiêm túc.

Trước khi đi hẹn hò, bạn đã có sẵn một thiên kiến ban đầu. Có thể bạn hơi nghiêng về A vì cả hai có nhiều sở thích chung hơn, hoặc có thể bạn hoàn toàn trung lập.

-   Hãy hình dung một hình vuông lớn đại diện cho 100% niềm tin của bạn
-   Hình vuông này được chia làm 2 phần, bên trái dành cho A bên phải dành cho B
-   Chiều rộng của mỗi ô là thiên kiến ban đầu, trong thống kê Bayesian gọi là Xác suất tiên nghiệm (Prior) của bạn đối với mỗi người

Bạn quyết định đi date với từng người để thu thập dữ liệu thực tế. Sau khi đi date, bạn chấm điểm buổi date đó.

-   Phần được tô màu là điểm buổi date của từng người, trong thống kê Bayesian gọi là Hàm khả năng (Likelihood)

Sau khi đã đi date với từng người, bạn muốn tính xác suất mình nên chọn A $\mathbb{P}(A|Date)$

-   Tư duy Bayes: Chúng ta so sánh **Diện tích tô màu** của A so với B. Đây là Xác suất hậu nghiệm (Posterior).

Biểu đồ này được tạo theo phương pháp trong video [Bayes theorem, the geometry of changing beliefs](https://www.youtube.com/watch?v=HZGCoVF3YvM) của kênh 3Blue1Brown.

```{ojs}
//| echo: false

viewof prior = Inputs.range([0, 1], {
  label: "Prior A", 
  value: 0.5, 
  step: 0.05
})

viewof like_alex = Inputs.range([0, 1], {
  label: "Likelihood A", 
  value: 0.8, 
  step: 0.05
})

viewof like_ben = Inputs.range([0, 1], {
  label: "Likelihood B", 
  value: 0.15, 
  step: 0.05
})

// 2. THE CALCULATIONS
rect_data = [
  // --- COLUMN 1: ALEX (Left Side) ---
  {
    label: "Thích A",
    x1: 0, x2: prior, y1: 0, y2: like_alex,
    color: "#6ecae1" 
  },
  {
    label: "Không thích A",
    x1: 0, x2: prior, y1: like_alex, y2: 1,
    color: "#1a1a1a" 
  },
  // --- COLUMN 2: BEN (Right Side) ---
  {
    label: "Thích B",
    x1: prior, x2: 1, y1: 0, y2: like_ben,
    color: "#2f7e9b" 
  },
  {
    label: "Không thích B",
    x1: prior, x2: 1, y1: like_ben, y2: 1,
    color: "#0f0f0f" 
  }
]

Plot.plot({
  width: 550, height: 450,
  marginTop: 50,
  marginLeft: 60,
  marginRight: 60,
  marginBottom: 20,

  style: {
    background: "black",
    color: "white",
    fontSize: "16px" 
  },
  
  x: { axis: null, domain: [0, 1] },
  y: { axis: null, domain: [0, 1] },

  marks: [
    // --- PART 1: THE ANNOTATIONS ---
    // Fix: Use [1] as dummy data, and arrow functions `() =>` for text strings.

    // A. TOP ANNOTATION: Prior P(H)
    Plot.ruleY([1], { 
      y: 1.03,           
      x1: 0, x2: prior,  
      stroke: "#000", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: prior / 2,      
      y: 1.03, dy: -10,
      text: () => `P(A) = ${prior.toFixed(2)}`, // <--- Arrow function required
      fill: "#000", fontWeight: "bold", fontSize: 16,
      clip: false
    }),

    // B. LEFT ANNOTATION: P(E|H)
    Plot.ruleX([1], {
      x: -0.03,          
      y1: 0, y2: like_alex, 
      stroke: "#6ecae1", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: -0.03,          
      y: like_alex / 2, 
      dx: -15, // Push slightly left away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `P(Date|A) = ${like_alex.toFixed(2)}`, // Removed \n for cleaner vertical look
      fill: "#6ecae1", 
      textAnchor: "middle", // Centers text on the bar height
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // C. RIGHT ANNOTATION: P(E|¬H)
    Plot.ruleX([1], {
      x: 1.03,           
      y1: 0, y2: like_ben, 
      stroke: "#2f7e9b", strokeWidth: 2, clip: false
    }),
    Plot.text([1], {
      x: 1.03,           
      y: like_ben / 2, 
      dx: 15, // Push slightly right away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `P(Date|B) = ${like_ben.toFixed(2)}`, 
      fill: "#2f7e9b", 
      textAnchor: "middle", 
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // --- PART 2: THE MOSAIC ---
    Plot.rect(rect_data, {
      x1: "x1", x2: "x2", y1: "y1", y2: "y2", 
      fill: "color", stroke: "white", strokeWidth: 1,
      tip: {
        fill: "#222", stroke: "white",
        maxRadius: 100,
        title: "label",
        channels: {
          "Diện tích": d => ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)
        },
        format: {
          "Diện tích": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false
        }
      }
    }),
    
    // Labels inside boxes
    Plot.text(rect_data, {
      x: d => (d.x1 + d.x2) / 2, 
      y: d => (d.y1 + d.y2) / 2, 
      text: d => (d.y2 - d.y1) > 0.1 && (d.x2 - d.x1) > 0.1 ? d.label : "", 
      fill: "white", fontWeight: "bold", pointerEvents: "none" 
    })
  ]
})
```

```{ojs}
//| echo: false

area_alex = prior * like_alex
area_ben  = (1 - prior) * like_ben
total_area = area_alex + area_ben
posterior_alex = area_alex / total_area

html`
  <div style="display: flex; align-items: center; flex-wrap: wrap;">
    <div style="font-weight: bold; margin-right: 5px;">
      P(A | Date) = 
    </div>

    <div style="display: flex; flex-direction: column; align-items: center; margin: 0 5px;">
      
      <div style="border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;">
        <span style="color: #6ecae1;">${area_alex.toFixed(3)}</span>
      </div>
      
      <div style="padding-top: 5px; text-align: center;">
        <span style="color: #6ecae1;">${area_alex.toFixed(3)}</span> + 
        <span style="color: #2f7e9b;">${area_ben.toFixed(3)}</span>
      </div>
      
    </div>

    <div style="font-weight: bold; color: #6ecae1; margin-left: 5px;">
      = ${(posterior_alex * 100).toFixed(1)}%
    </div>
  </div>
`
```

## Ứng dụng

Giả sử một bệnh nhân nhận kết quả xét nghiệm dương tính với một căn bệnh. Các thông số của xét nghiệm như sau:

-   Độ nhạy (Sensitivity): 95%
-   Độ đặc hiệu (Specificity): 90%
-   Tỉ lệ hiện mắc: Căn bệnh này chiếm 10% dân số

Xác suất thực sự người đó bị bệnh khi cầm kết quả dương tính $\mathbb{P}(B|D)$ là bao nhiêu?

Cách khác để đặt câu hỏi này là: Trong số những người cầm tờ giấy xét nghiệm Dương tính, có bao nhiêu phần trăm là Dương tính thật? Để trả lời, ta cần tìm Tổng diện tích Dương tính, rồi lấy Diện tích Dương tính thật chia cho tổng số đó.

Chúng ta sẽ áp dụng phương pháp "Hình vuông niềm tin" để giải quyết:

-   Hãy hình dung một hình vuông lớn đại diện cho 100% dân số
-   Hình vuông này được chia làm 2 phần, bên trái là tỉ lệ người bệnh trong dân số, bên phải là tỉ lệ người không bệnh
-   Trong cột người bệnh, độ nhạy là 95%, tô màu 95% chiều cao của cột này, đây là phần dương tính thật, diện tích là $0.10 \times 0.95 = 0.095$
-   Trong cột người không bệnh, độ đặc hiệu là 90%, tô màu 10% chiều cao của cột này, đây là phần dương tính giả, diện tích là $0.90 \times 0.10 = 0.09$

Bây giờ, hãy nhìn vào toàn bộ phần được tô màu trên hình vuông.

-   Tổng diện tích màu (tổng dương tính) là $0.095 \text{ (Thật)} + 0.09 \text{ (Giả)} = 0.185$
-   Phần bị chiếm bởi dương tính thật chính là xác suất thực sự mắc bệnh khi có kết quả dương tính

```{ojs}
//| echo: false

viewof prev = Inputs.range([0, 1], {
  label: "Tỉ lệ bệnh", 
  value: 0.1, 
  step: 0.01
})

viewof sens = Inputs.range([0, 1], {
  label: "Độ nhạy", 
  value: 0.95, 
  step: 0.01
})

viewof spec = Inputs.range([0, 1], {
  label: "Độ đặc hiệu", 
  value: 0.9, 
  step: 0.01
})

// 2. THE CALCULATIONS (Reactive Data)
// This array automatically updates whenever the sliders above move.
// We define the 4 quadrants of the mosaic.

rect_data2 = [
  // --- COLUMN 1: ALEX (Left Side) ---
  // The Width is determined by the 'prior'
  
  // 1. The "Evidence" Box (The bottom colored part)
  {
    label: "Dương thật",
    x1: 0, 
    x2: prev, 
    y1: 0, 
    y2: sens, 
    color: "#6ecae1" // Light Blue (Strong Evidence)
  },
  
  // 2. The "Void" Box (The top dark part)
  {
    label: "Âm giả",
    x1: 0, 
    x2: prev, 
    y1: sens, 
    y2: 1, 
    color: "#1a1a1a" // Dark Grey
  },

  // --- COLUMN 2: BEN (Right Side) ---
  // The Width starts where Alex ends ('prior') and goes to 1
  
  // 3. The "Evidence" Box (The bottom colored part)
  {
    label: "Dương giả",
    x1: prev, 
    x2: 1, 
    y1: 0, 
    y2: 1 - spec, 
    color: "#2f7e9b" // Teal (Competing Evidence)
  },
  
  // 4. The "Void" Box (The top dark part)
  {
    label: "Âm thật",
    x1: prev, 
    x2: 1, 
    y1: 1 - spec, 
    y2: 1, 
    color: "#0f0f0f" // Black
  }
]

Plot.plot({
  width: 550, height: 450,
  marginTop: 50,
  marginLeft: 60,
  marginRight: 60,
  marginBottom: 20,

  style: {
    background: "black",
    color: "white",
    fontSize: "16px" 
  },
  
  x: { axis: null, domain: [0, 1] },
  y: { axis: null, domain: [0, 1] },

  marks: [
    // --- PART 1: THE ANNOTATIONS ---
    // Fix: Use [1] as dummy data, and arrow functions `() =>` for text strings.

    // A. TOP ANNOTATION: Prior P(H)
    Plot.ruleY([1], { 
      y: 1.03,           
      x1: 0, x2: prev,  
      stroke: "#000", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: prev / 2,      
      y: 1.03, dy: -10,
      text: () => `Tỉ lệ bệnh = ${prev.toFixed(2)}`, // <--- Arrow function required
      fill: "#000", fontWeight: "bold", fontSize: 16,
      clip: false
    }),

    // B. LEFT ANNOTATION: P(E|H)
    Plot.ruleX([1], {
      x: -0.03,          
      y1: 0, y2: sens, 
      stroke: "#6ecae1", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: -0.03,          
      y: sens / 2, 
      dx: -15, // Push slightly left away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `Độ nhạy = ${sens.toFixed(2)}`, // Removed \n for cleaner vertical look
      fill: "#6ecae1", 
      textAnchor: "middle", // Centers text on the bar height
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // C. RIGHT ANNOTATION: P(E|¬H)
    Plot.ruleX([1], {
      x: 1.03,           
      y1: 1 - spec, y2: 1, 
      stroke: "#000", strokeWidth: 2, clip: false
    }),
    Plot.text([1], {
      x: 1.03,           
      y: 1 - spec / 2, 
      dx: 15, // Push slightly right away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `Độ đặc hiệu = ${spec.toFixed(2)}`, 
      fill: "#000", 
      textAnchor: "middle", 
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // --- PART 2: THE MOSAIC ---
    Plot.rect(rect_data2, {
      x1: "x1", x2: "x2", y1: "y1", y2: "y2", 
      fill: "color", stroke: "white", strokeWidth: 1,
      tip: {
        fill: "#222", stroke: "white",
        maxRadius: 100,
        title: "label",
        channels: {
          "Diện tích": d => ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)
        },
        format: {
          "Diện tích": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false
        }
      }
    }),
    
    // Labels inside boxes
    Plot.text(rect_data2, {
      x: d => (d.x1 + d.x2) / 2, 
      y: d => (d.y1 + d.y2) / 2, 
      text: d => (d.y2 - d.y1) > 0.1 && (d.x2 - d.x1) > 0.1 ? d.label : "", 
      fill: "white", fontWeight: "bold", pointerEvents: "none" 
    })
  ]
})
```

```{ojs}
//| echo: false

area_tpr = prev * sens
area_fpr  = (1 - prev) * (1 - spec)
total_area_risk = area_tpr + area_fpr
posterior_risk = area_tpr / total_area_risk

html`
  <div style="display: flex; align-items: center; flex-wrap: wrap;">
    <div style="font-weight: bold; margin-right: 5px;">
      P(B | D) = 
    </div>

    <div style="display: flex; flex-direction: column; align-items: center; margin: 0 5px;">
      
      <div style="border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;">
        <span style="color: #6ecae1;">${area_tpr.toFixed(3)}</span>
      </div>
      
      <div style="padding-top: 5px; text-align: center;">
        <span style="color: #6ecae1;">${area_tpr.toFixed(3)}</span> + 
        <span style="color: #2f7e9b;">${area_fpr.toFixed(3)}</span>
      </div>
      
    </div>

    <div style="font-weight: bold; color: #6ecae1; margin-left: 5px;">
      = ${(posterior_risk * 100).toFixed(1)}%
    </div>
  </div>
`
```

## Xấp xỉ lưới


