---
title: "Phân phối rời rạc"
format: html
---

## Phép thử Bernoulli (Bernoulli trial, hay binomial trial)

Là một lần thử nghiệm duy nhất, không gian mẫu chỉ có đúng 2 kết quả: Thành công (Success) hoặc Thất bại (Failure)

Ví dụ: tung đồng xu (mặt sấp, mặt ngửa), xét nghiệm một ca nghi ngờ (dương tính, âm tính)

Khi ta thực hiện phép thử Bernoulli nhiều lần liên tiếp (ví dụ: tung một đồng xu nhiều lần, dùng một loại xét nghiệm để test nhiều người), ta đang thực hiện 1 chuỗi Bernoulli (Bernoulli process). Chuỗi Bernoulli chuẩn cần thỏa 2 điều kiện:

-   Độc lập (Independent): Kết quả của lần thử này không ảnh hưởng đến lần thử khác.
-   Xác suất không đổi: Xác suất thành công ($p$) phải giống hệt nhau ở mọi lần thử.

Hầu hết các phân phối rời rạc đều xuất phát từ chuỗi Bernoulli với các mục tiêu khác nhau.

## Đếm số lần thành công

Chúng ta quyết định trước sẽ bỏ ra bao nhiêu công sức ($n$ lần thử), và đếm xem thu được bao nhiêu phần thưởng ($k$ thành công).

### Phân phối Nhị thức (Binomial distribution)

Đếm số lần thành công ($k$) trong một số lượng cố định các phép thử Bernoulli độc lập ($n$).

Xác suất để đạt được đúng $k$ lần thành công là:

$$\mathbb{P}(X = k) = \binom{n}{k} p^k (1-p)^{n-k}$$

Với:

- $n$: Tổng số lần thực hiện phép thử
- $p$: Xác suất thành công của mỗi lần thử (không đổi)

::: {.callout-note}
## Giải thích

$$\underbrace{\binom{n}{k}}_{\text{Số cách chọn}} \cdot \underbrace{p^k}_{k \text{ lần thành công}} \cdot \underbrace{(1-p)^{n-k}}_{n-k \text{ lần thất bại}}$$
:::

#### Ví dụ

Tung 1 đồng xu 10 lần, khả năng đếm được 1, 2, 3... mặt ngửa là bao nhiêu?

- Tổng số lần thực hiện phép thử: $n = 10$
- Xác suất ra mặt ngửa mỗi lần: $p = 0.5$

```{ojs}
//| echo: false
viewof coin_sim_manual = (() => {
  // --- 1. SETUP DOM & STYLES ---
  const container = document.createElement("div");
  // Rigid container size: 400px width, 340px height (40px controls + 300px canvas)
  container.style.cssText = `
    width: 400px;
    height: 340px; 
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid transparent;
  `;

  // Inject UI HTML directly (Total Control, Zero Shift)
  container.innerHTML = `
    <style>
      .coin-controls-row {
        width: 100%;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 12px;
        margin-bottom: 0px;
      }
      .coin-btn {
        padding: 6px 14px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        background-color: white;
        color: #374151;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        line-height: 1.2;
      }
      .coin-btn:hover { background-color: #f3f4f6; }
      
      .coin-btn-primary {
        background-color: #3b82f6; 
        color: white; 
        border-color: #2563eb;
      }
      .coin-btn-primary:hover { background-color: #2563eb; color: white; }
      
      .coin-toggle {
        display: flex; align-items: center; gap: 6px;
        font-size: 14px; font-weight: 500; color: #4b5563;
        cursor: pointer; user-select: none;
      }
      .coin-toggle input { width: 16px; height: 16px; accent-color: #10b981; cursor: pointer; }
      
      canvas { display: block; } /* Removes ghost margin */
    </style>

    <div class="coin-controls-row">
      <button id="btn-flip" class="coin-btn coin-btn-primary">Tung đồng xu</button>
      <label class="coin-toggle">
        <input type="checkbox" id="chk-auto">
        Tự động chạy
      </label>
      <button id="btn-reset" class="coin-btn">Làm lại</button>
    </div>
  `;

  // --- 2. CANVAS SETUP ---
  const width = 400;
  const height = 300;
  const canvas = document.createElement("canvas");
  const dpr = window.devicePixelRatio || 1;
  
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.scale(dpr, dpr);
  container.appendChild(canvas);

  // --- 3. STATE & CONSTANTS ---
  const N = 10;
  const P = 0.5;
  
  // Colors
  const BG_COLOR="#fff", TEXT_COLOR="#2c3e50";
  const HEAD_COLOR="#f1c40f", HEAD_BORDER="#d4ac0d";
  const TAIL_COLOR="#bdc3c7", TAIL_BORDER="#95a5a6";
  const CHART_BAR="#3498db", CHART_ACTIVE="#2980b9", CHART_THEO="rgba(44, 62, 80, 0.1)";

  // Math Helper
  function binomial(k, n, p) {
    function nCr(n, r) {
        if (r < 0 || r > n) return 0;
        let res = 1;
        for(let i=0; i<r; i++) res = res * (n - i) / (i + 1);
        return res;
    }
    return nCr(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  }

  // Simulation State
  const S = {
     history: [], 
     counts: {},  
     totalFlips: 0,
     currentResult: [], 
     animation: 0, 
     cooldown: 0,
     isAuto: false
  };
  for(let i=0; i<=N; i++) S.counts[i] = 0;

  // --- 4. LOGIC ---
  function runFlip() {
     let heads = 0;
     const res = [];
     for(let i=0; i<N; i++) {
        const isHead = Math.random() < P;
        res.push(isHead ? 1 : 0);
        if (isHead) heads++;
     }
     
     const coinSize = 28;
     const gap = 6;
     const totalW = N * coinSize + (N-1)*gap;
     const startX = (width - totalW) / 2 + coinSize/2;

     S.currentResult = res.map((val, i) => ({
        val: val,
        x: width/2, 
        y: 50,
        targetX: startX + i * (coinSize + gap), 
        targetY: 85,
        r: coinSize / 2,
        t: 0
     }));

     S.history.push(heads);
     S.counts[heads] = (S.counts[heads] || 0) + 1;
     S.totalFlips++;
     S.animation = 1;
     S.cooldown = 0;
  }

  function reset() {
     S.history = [];
     for(let i=0; i<=N; i++) S.counts[i] = 0;
     S.totalFlips = 0;
     S.currentResult = [];
     S.animation = 0;
  }

  // --- 5. LOOP ---
  function update() {
     // Auto Run Logic
     if (S.isAuto && S.animation === 0) {
        S.cooldown++;
        if (S.cooldown > 20) runFlip(); // Speed: ~0.3s
     }

     // Animation Logic
     if (S.animation === 1) {
       let done = true;
       for (let c of S.currentResult) {
          if (c.t < 1) {
             c.t += 0.2; 
             if (c.t > 1) c.t = 1;
             const ease = 1 - Math.pow(1 - c.t, 3);
             c.x = width/2 + (c.targetX - width/2) * ease;
             c.y = c.targetY - Math.sin(c.t * Math.PI) * 20;
             done = false;
          }
       }
       if (done) S.animation = 0;
    }
  }

  function draw() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    ctx.font = "bold 14px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fontVariantNumeric = "tabular-nums";
    
    // 1. Text Info
    // Left: Count
    ctx.textAlign = "left"; ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(`Lần chạy: ${S.totalFlips}`, 20, 30);
    
    // Center: Status
    if (S.isAuto) {
       ctx.textAlign = "center"; ctx.fillStyle = "#27ae60";
       ctx.fillText("● Đang chạy...", 170, 30); // Adjusted center for visual balance
    }
    
    // Right: Result
    if (S.currentResult.length > 0) {
       const hCount = S.currentResult.filter(c => c.val===1).length;
       ctx.textAlign = "right"; ctx.fillStyle = "#d35400";
       ctx.fillText(`Mặt Ngửa: ${hCount} / ${N}`, width - 20, 30);
    }
    ctx.restore();

    // 2. Coins
    for (let c of S.currentResult) {
       ctx.beginPath();
       ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
       ctx.fillStyle = c.val === 1 ? HEAD_COLOR : TAIL_COLOR;
       ctx.fill();
       ctx.lineWidth = 2;
       ctx.strokeStyle = c.val === 1 ? HEAD_BORDER : TAIL_BORDER;
       ctx.stroke();
       ctx.fillStyle = "white";
       ctx.textAlign = "center"; ctx.textBaseline = "middle";
       ctx.font = `bold ${c.r}px sans-serif`;
       ctx.fillText(c.val === 1 ? "N" : "S", c.x, c.y + 1);
    }

    // 3. Chart
    const chartY = 280; 
    const chartH = 140; 
    const chartX = 40;
    const chartW = width - 60;
    
    ctx.beginPath();
    ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 1;
    ctx.moveTo(chartX, chartY); ctx.lineTo(chartX + chartW, chartY); ctx.stroke();

    const barW = chartW / (N + 1);
    const MAX_PROB = 0.246; 
    const Y_SCALE_MAX = MAX_PROB * 1.2; 
    const activeHeads = S.currentResult.filter(c => c.val===1).length;

    for (let k = 0; k <= N; k++) {
       const cx = chartX + k * barW + barW/2;
       
       // Theoretical
       const prob = binomial(k, N, P);
       const theoH = (prob / Y_SCALE_MAX) * chartH;
       ctx.fillStyle = CHART_THEO;
       ctx.fillRect(cx - barW*0.3, chartY - theoH, barW*0.6, theoH);
       
       // Actual
       let observedProb = 0;
       if (S.totalFlips > 0) observedProb = S.counts[k] / S.totalFlips;
       let barH = (observedProb / Y_SCALE_MAX) * chartH;
       if (barH > chartH + 10) barH = chartH + 10;

       const isActive = (S.animation === 0 && k === activeHeads && S.totalFlips > 0);
       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_BAR;
       ctx.fillRect(cx - barW*0.3, chartY - barH, barW*0.6, barH);
       
       // Labels
       ctx.save();
       ctx.fontVariantNumeric = "tabular-nums";
       ctx.fillStyle = TEXT_COLOR;
       ctx.font = "10px sans-serif";
       ctx.textAlign = "center";
       ctx.fillText(k, cx, chartY + 15);
       ctx.restore();
    }
    
    // Y-Axis Label
    ctx.save();
    ctx.translate(12, chartY - chartH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#7f8c8d";
    ctx.fillText("Tần suất", 0, 0);
    ctx.restore();
  }

  // --- 6. BINDINGS ---
  const btnFlip = container.querySelector("#btn-flip");
  const btnReset = container.querySelector("#btn-reset");
  const chkAuto = container.querySelector("#chk-auto");

  btnFlip.onclick = () => runFlip();
  btnReset.onclick = () => reset();
  chkAuto.onchange = (e) => { S.isAuto = e.target.checked; };

  let frameId;
  function tick() {
    update();
    draw();
    frameId = requestAnimationFrame(tick);
  }
  tick();

  if (this && this.invalidation) this.invalidation.then(() => cancelAnimationFrame(frameId));

  return container;
})();
```

#### Bảng Galton

Bảng Galton (Galton board) là một tấm bảng dựng đứng, được đóng các hàng đinh so le nhau theo hình tam giác. Ta thả những viên bi nhỏ từ đỉnh tháp. Khi một viên bi chạm vào một chiếc đinh, nó sẽ nảy sang trái hoặc sang phải. Sau khi đi hết các hàng đinh, viên bi sẽ rơi vào các ô chứa để hứng bi. Số lượng bi trong các ô chứa này tuân theo phân phối Nhị thức.

```{ojs}
//| echo: false
viewof galton_sharp = Inputs.form({
  rows: Inputs.range([8, 20], {value: 10, step: 1, label: "Số hàng đinh"}),
  speed: Inputs.range([0.5, 3], {value: 2, step: 0.1, label: "Tốc độ"}),
  total: Inputs.range([50, 800], {value: 200, step: 10, label: "Số viên bi"})
})

viewof galton_sim_dense = (() => {
  // --- 1. CONFIGURATION ---
  const config = {
      rows: galton_sharp.rows,
      speed: galton_sharp.speed,
      maxBalls: galton_sharp.total
  };

  // --- 2. SETUP CONTAINER (Centered) ---
  const outerWrapper = document.createElement("div");
  outerWrapper.style.cssText = `
    width: 100%;
    display: flex;
    justify-content: center;
    margin-top: 20px;
  `;

  const container = document.createElement("div");
  container.style.cssText = `
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 380px; 
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  `;
  outerWrapper.appendChild(container);

  // --- 3. INJECT UI ---
  container.innerHTML = `
    <style>
      .galton-ctrl-row {
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-bottom: 10px;
      }
      .galton-btn {
        padding: 6px 16px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        background-color: white;
        color: #374151;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.1s ease;
      }
      .galton-btn:hover { background-color: #f3f4f6; }
      
      .galton-btn-primary {
        background-color: #3b82f6; 
        color: white; 
        border-color: #2563eb;
      }
      .galton-btn-primary:hover { background-color: #2563eb; color: white; }

      canvas {
        border-radius: 4px;
      }
    </style>

    <div class="galton-ctrl-row">
      <button id="btn-start" class="galton-btn galton-btn-primary">Bắt đầu</button>
      <button id="btn-stop" class="galton-btn">Dừng</button>
    </div>
  `;

  // --- 4. CANVAS SETUP ---
  // INCREASED HEIGHT from 500 -> 600
  const logicalWidth = 380;
  const logicalHeight = 600; 
  const dpr = window.devicePixelRatio || 1;

  const canvas = document.createElement("canvas");
  canvas.width = logicalWidth * dpr;
  canvas.height = logicalHeight * dpr;
  canvas.style.width = `${logicalWidth}px`;
  canvas.style.height = `${logicalHeight}px`;
  
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.scale(dpr, dpr);
  container.appendChild(canvas);

  // --- 5. GEOMETRY & STATE ---
  const pegSpacing = logicalWidth / (config.rows + 3);
  const startY = 60;
  const pegRadius = pegSpacing * 0.12; 
  const ballRadius = pegSpacing * 0.23; 
  const rowHeight = pegSpacing * 0.85;

  // Bin Geometry
  const floorY = logicalHeight - 10;
  const binWidth = pegSpacing;
  const totalBinWidth = (config.rows + 1) * binWidth;
  const binsStartX = (logicalWidth - totalBinWidth) / 2;
  const wallsTopY = startY + (config.rows) * rowHeight + 15;

  // DENSE PACKING FACTOR
  // 70% Overlap means the vertical step is small.
  // Normal Diameter = 2*r.
  // We use step = 0.6 * r. This is very dense.
  const stackStep = ballRadius * 0.6; 

  // Pre-calculate Peg Positions
  const pegGrid = []; 
  for (let r = 0; r < config.rows; r++) {
    const rowPegs = [];
    const pegsInThisRow = r + 1;
    const rowWidth = (pegsInThisRow - 1) * pegSpacing;
    const rowStartX = (logicalWidth - rowWidth) / 2;
    for (let p = 0; p < pegsInThisRow; p++) {
      rowPegs.push({
        x: rowStartX + p * pegSpacing,
        y: startY + r * rowHeight
      });
    }
    pegGrid.push(rowPegs);
  }

  // Simulation State
  const S = {
    balls: [],
    bins: new Array(config.rows + 1).fill(0),
    spawned: 0,
    running: false
  };

  // --- 6. LOGIC ---
  function createBall() {
    let currentInd = 0; 
    let path = [];
    path.push({ x: logicalWidth / 2, y: startY - 20 }); 

    for (let r = 0; r < config.rows; r++) {
       const peg = pegGrid[r][currentInd];
       path.push({ x: peg.x, y: peg.y - pegRadius - ballRadius });
       if (Math.random() > 0.5) currentInd++; 
    }

    const binX = binsStartX + currentInd * binWidth + binWidth/2;
    path.push({ x: binX, y: wallsTopY });
    path.push({ x: binX, y: floorY, isFloor: true, binIndex: currentInd });

    return {
      path: path,
      segment: 0, t: 0, active: true,
      x: path[0].x, y: path[0].y
    };
  }

  function spawn() {
     if (S.spawned >= config.maxBalls) return;
     
     // Check capacity using new DENSE packing logic
     // Available height = floorY - wallsTopY
     // Height consumed = count * stackStep
     const centerBin = Math.floor(config.rows/2);
     const currentHeight = S.bins[centerBin] * stackStep;
     
     if (currentHeight > (floorY - wallsTopY - 20)) return; // -20 buffer
     
     S.balls.push(createBall());
     S.spawned++;
  }

  function update(dt) {
    if (S.running) {
        const spawnChance = 0.25 * config.speed; 
        if (Math.random() < spawnChance) spawn();
    }

    for (let i = 0; i < S.balls.length; i++) {
        const b = S.balls[i];
        if (!b.active) continue;
        if (!S.running) continue;

        const moveSpeed = 3.0 * config.speed * dt;
        b.t += moveSpeed;

        if (b.t >= 1) {
            b.t = 0;
            b.segment++;
            if (b.segment >= b.path.length - 1) {
                b.active = false;
                const finalPt = b.path[b.path.length - 1];
                S.bins[finalPt.binIndex]++;
                continue;
            }
        }

        const p0 = b.path[b.segment];
        const p1 = b.path[b.segment + 1];
        const t = b.t;
        const ease = t * t; 
        
        b.x = p0.x + (p1.x - p0.x) * t;
        b.y = p0.y + (p1.y - p0.y) * (p1.isFloor ? ease : ease);
    }
    
    if (S.balls.length > config.maxBalls + 50) {
        S.balls = S.balls.filter(b => b.active);
    }
  }

  // --- 7. DRAW LOOP ---
  function draw() {
    // Clear
    ctx.fillStyle = "#f8f9fa";
    ctx.fillRect(0, 0, logicalWidth, logicalHeight);

    // Pegs
    ctx.fillStyle = "#9ca3af";
    ctx.beginPath();
    for (let r = 0; r < pegGrid.length; r++) {
      for (let p = 0; p < pegGrid[r].length; p++) {
         const peg = pegGrid[r][p];
         ctx.moveTo(peg.x + pegRadius, peg.y);
         ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI*2);
      }
    }
    ctx.fill(); 

    // Active Balls
    ctx.fillStyle = "#3b82f6";
    ctx.beginPath();
    for (let i = 0; i < S.balls.length; i++) {
       const b = S.balls[i];
       if (b.active) {
         ctx.moveTo(b.x + ballRadius, b.y);
         ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2);
       }
    }
    ctx.fill(); 

    // BINS (Dense Stacking)
    ctx.fillStyle = "#3b82f6";
    ctx.strokeStyle = "#1d4ed8"; // Darker border for definition
    ctx.lineWidth = 1;
    
    for (let i = 0; i < S.bins.length; i++) {
       const count = S.bins[i];
       if (count === 0) continue;
       
       const cx = binsStartX + i * binWidth + binWidth/2;
       
       ctx.beginPath();
       for (let j = 0; j < count; j++) {
          // DENSE LOGIC: stackStep = 0.6 * r
          const cy = floorY - ballRadius - (j * stackStep);
          
          if (cy < wallsTopY) break; 
          ctx.moveTo(cx + ballRadius, cy);
          ctx.arc(cx, cy, ballRadius, 0, Math.PI*2);
       }
       ctx.fill();
       ctx.stroke();
    }

    // Walls/Floor
    ctx.strokeStyle = "#d1d5db";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(binsStartX, floorY);
    ctx.lineTo(binsStartX + totalBinWidth, floorY);
    for (let i = 0; i <= config.rows + 1; i++) {
       const x = binsStartX + i * binWidth;
       ctx.moveTo(x, wallsTopY);
       ctx.lineTo(x, floorY);
    }
    ctx.stroke();

    // Text
    ctx.fillStyle = "#374151";
    ctx.font = "bold 14px sans-serif";
    ctx.fillText(`Số bi: ${S.spawned} / ${config.maxBalls}`, 10, 25);
  }

  // --- 8. RUNTIME ---
  let lastTime = performance.now();
  let frameId;
  
  function tick(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.1); 
    lastTime = now;
    
    update(dt);
    draw();
    frameId = requestAnimationFrame(tick);
  }

  // Bind Buttons
  const btnStart = container.querySelector("#btn-start");
  const btnStop = container.querySelector("#btn-stop");

  btnStart.onclick = () => {
     if (!S.running && S.spawned === 0) {
         S.running = true;
     } else {
         S.running = true;
         if (S.spawned >= config.maxBalls) {
             S.balls = [];
             S.bins.fill(0);
             S.spawned = 0;
         }
     }
  };
  
  btnStop.onclick = () => {
      S.running = false;
  };

  tick(performance.now());
  invalidation.then(() => cancelAnimationFrame(frameId));

  return outerWrapper;
})();
```

**Tại sao lại là phân phối Nhị thức?**

- Mỗi lần viên bi chạm vào chiếc đinh, có hai trường hợp xảy ra: viên bi sẽ nảy sang trái hoặc sang phải, xác suất nảy sang mỗi bên là $p = 0.5$, giống như tung đồng xu. Đây là một phép thử Bernoulli.
- Nếu bảng có 10 hàng đinh, viên bi sẽ thực hiện chuỗi Bernoulli có 10 phép thử liên tiếp.
- Các ô chứa tương ứng với số lần viên bi nảy về bên phải. Để vào ô giữa, viên bi phải nảy sang bên phải 5 lần (và bên trái 5 lần), để vào ô cuối cùng, viên bi phải nảy sang bên phải 10 lần (và bên trái 0 lần).

#### Hồi quy logistic

```{r}
#| eval: false
glm(formula, data, family = binomial(link = "logit"))
glm(formula, data, family = "binomial")
```

**Tại sao trong hồi quy logistic lại ghi `family = "binomial"`?**

Ví dụ: Hút thuốc lá có làm tăng nguy cơ ung thư phổi không?

- Biến độc lập: Số điếu thuốc hút mỗi ngày
- Biến phụ thuộc: Tình trạng ung thư phổi (1 = Có bệnh, 0 = Không bệnh)

Khi xây dựng mô hình, chúng ta xem xét từng cá nhân trong dữ liệu như một phép thử ngẫu nhiên:

- Với một người cụ thể (ví dụ: anh A, hút 1 gói/ngày), việc anh ta có bị ung thư hay không giống như việc tung một đồng xu: mặt ngửa (1) là bị ung thư, mặt sấp (0) là không bị ung thư. **Nhưng** xác suất tung ra mặt ngửa của đồng xu này không phải là 0.5, mà phụ thuộc vào việc anh ta hút bao nhiêu thuốc.
- Khi chúng ta tiến hành nghiên cứu trên $n$ người, đây là 1 chuỗi Bernoulli, vì vậy có thể chọn phân phối Binomial để mô hình nó.

Khai báo `family = "binomial"` nghĩa là: "Biến kết quả ($Y$) là đếm số lần thành công (hoặc thất bại) từ các phép thử nhị phân, hãy dùng công thức xác suất của phân phối Nhị thức để ước lượng."

#### Xấp xỉ phân phối Chuẩn

Định lý Moivre-Laplace (một dạng đặc biệt của Định lý Giới hạn Trung tâm): Khi số lượng phép thử $n$ đủ lớn, hình dáng của phân phối Nhị thức sẽ tiệm cận về phân phối Chuẩn.

```{ojs}
//| echo: false
viewof normal_approx_fixed_axis = (() => {
  // --- 1. SETUP CONTAINER ---
  const wrapper = document.createElement("div");
  wrapper.style.cssText = `
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    margin-top: 20px;
    width: 100%;
    min-height: 500px;
  `;

  // --- 2. INPUT CREATION ---
  function createInput(id, label, min, max, step, val) {
    const container = document.createElement("div");
    container.style.cssText = "display: flex; flex-direction: column; width: 220px;";
    
    const labelEl = document.createElement("label");
    labelEl.htmlFor = id;
    labelEl.style.cssText = "font-size: 14px; font-weight: 600; color: #374151; margin-bottom: 6px;";
    labelEl.innerHTML = `${label} <span style="color: #be185d;">${val}</span>`;
    
    const input = document.createElement("input");
    input.type = "range";
    input.id = id;
    input.min = min;
    input.max = max;
    input.step = step;
    input.value = val;
    input.style.width = "100%";
    input.style.accentColor = "#be185d"; 
    
    container.appendChild(labelEl);
    container.appendChild(input);
    return { container, input, labelEl };
  }

  const nCtrl = createInput("n_val_fx", "Số phép thử (n):", 10, 500, 10, 50);
  const pCtrl = createInput("p_val_fx", "Xác suất (p):", 0.05, 0.95, 0.05, 0.5);

  const controlsDiv = document.createElement("div");
  controlsDiv.style.cssText = "display: flex; flex-wrap: wrap; gap: 30px; justify-content: center; margin-bottom: 20px; width: 100%;";
  controlsDiv.appendChild(nCtrl.container);
  controlsDiv.appendChild(pCtrl.container);
  wrapper.appendChild(controlsDiv);

  // Stats Display
  const statsDiv = document.createElement("div");
  statsDiv.style.cssText = "font-size: 16px; color: #374151; margin-bottom: 10px; font-weight: 500; font-family: monospace;";
  wrapper.appendChild(statsDiv);
  
  // Plot Container
  const plotContainer = document.createElement("div");
  wrapper.appendChild(plotContainer);

  // --- 3. MATH KERNEL ---
  function logFact(n) {
    if (n <= 1) return 0;
    return n * Math.log(n) - n + 0.5 * Math.log(2 * Math.PI * n);
  }

  function getBinomialProb(k, n, p) {
    if (k < 0 || k > n) return 0;
    if (p <= 0) return k === 0 ? 1 : 0;
    if (p >= 1) return k === n ? 1 : 0;
    
    const logP = logFact(n) - logFact(k) - logFact(n - k) + k * Math.log(p) + (n - k) * Math.log(1 - p);
    return Math.exp(logP);
  }

  function normalPDF(x, mu, sigma) {
    if (sigma <= 0) return 0;
    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));
  }

  // --- 4. RENDER LOGIC ---
  function update() {
    const n = parseFloat(nCtrl.input.value);
    const p = parseFloat(pCtrl.input.value);

    // Update Text
    nCtrl.labelEl.querySelector("span").textContent = n;
    pCtrl.labelEl.querySelector("span").textContent = p.toFixed(2);

    const mu = n * p;
    const sigma = Math.sqrt(n * p * (1 - p));

    // Stats
    statsDiv.innerHTML = `&mu; = <b>${mu.toFixed(2)}</b> &nbsp;|&nbsp; &sigma; = <b>${sigma.toFixed(2)}</b>`;

    // CALCULATION WINDOW: We still optimize calculation to +/- 4 sigma
    // to keep performance high, even though visual axis is 0-n.
    let startK = Math.floor(mu - 4 * sigma);
    let endK = Math.ceil(mu + 4 * sigma);
    if (startK < 0) startK = 0;
    if (endK > n) endK = n;

    // 1. Generate Binomial Data
    const binomData = [];
    for (let k = startK; k <= endK; k++) {
      binomData.push({ 
          k: k, 
          x1: k - 0.5, 
          x2: k + 0.5,
          prob: getBinomialProb(k, n, p) 
      });
    }

    // 2. Generate Normal Data
    const normalData = [];
    const step = (endK - startK) / 100;
    const safeStep = step > 0.1 ? step : 0.1;
    
    for (let x = startK; x <= endK; x += safeStep) {
      normalData.push({ x: x, y: normalPDF(x, mu, sigma) });
    }

    // 3. Plot
    const chart = Plot.plot({
      width: 600,
      height: 380,
      marginTop: 30,
      marginLeft: 40,
      marginBottom: 30,
      x: { 
        label: "Số lần thành công (k)",
        // FIX: Hard-code domain to full range [0, n] to prevent jumping
        domain: [0, n]
      },
      y: { 
        label: "Xác suất", 
        grid: true 
      },
      marks: [
        // Binomial
        Plot.rectY(binomData, {
          x1: "x1", 
          x2: "x2", 
          y: "prob", 
          fill: "#3b82f6", 
          fillOpacity: 0.5,
          title: d => `k: ${d.k}\nP: ${d.prob.toFixed(4)}`
        }),
        
        // Normal Curve
        Plot.line(normalData, {
          x: "x", 
          y: "y", 
          stroke: "#be185d", 
          strokeWidth: 3
        }),
        
        // Mean Line
        Plot.ruleX([mu], {
          stroke: "#374151", 
          strokeDasharray: "4,4", 
          strokeOpacity: 0.6
        })
      ]
    });

    plotContainer.innerHTML = "";
    plotContainer.appendChild(chart);
  }

  nCtrl.input.addEventListener("input", update);
  pCtrl.input.addEventListener("input", update);
  
  update();

  return wrapper;
})();
```

### Phân phối Siêu bội (Hypergeometric distribution)

Nếu phân phối Nhị thức là việc tung đồng xu, thì Phân phối Siêu bội giống như việc chia bài.

Tình huống: Bạn có bộ bài 52 lá, trong đó có 4 lá Át. Bạn rút 10 lá và hỏi "Tôi rút được bao nhiêu lá Át?".

Luật chơi:

-   Số lần thử cố định ($n$)
-   Các lần thử phụ thuộc nhau
-   Lấy mẫu không hoàn lại từ một quần thể hữu hạn ($N$)

Khi bạn rút được một lá Át ra khỏi bộ bài và giữ nó lại, **xác suất rút được lá Át tiếp theo sẽ thay đổi** (vì trong bộ bài giờ đây thiếu mất 1 lá Át và tổng số lá cũng giảm đi 1). Đây là đặc trưng của việc lấy mẫu không hoàn lại. 

Phân phối Siêu bội mô tả xác suất lấy được đúng $k$ phần tử thành công trong $n$ lần lấy mẫu từ một quần thể hữu hạn gồm $N$ phần tử, mà không có sự thay thế (không hoàn lại).

$$\mathbb{P}(X=k) = \frac{\binom{K}{k} \binom{N-K}{n-k}}{\binom{N}{n}}$$

- $N$: Tổng kích thước quần thể (Ví dụ: 52 lá bài)
- $n$: Kích thước mẫu lấy ra (Ví dụ: Rút 5 lá trên tay)
- $K$: Tổng số phần tử thành công có trong quần thể (Ví dụ: 4 lá Át)
- $k$: Số lượng thành công mong muốn trong mẫu (Ví dụ: Muốn có đúng 2 lá Át)
- $N-K$: Số lượng phần tử thất bại trong quần thể (Ví dụ: 48 lá bài còn lại)
- $n-k$: Số lượng thất bại phải lấy trong mẫu (Ví dụ: 3 lá còn lại trong tay phải là lá thường).

::: {.callout-note}
## Giải thích

$$\frac{ \overbrace{\binom{K}{k}}^{\text{Chọn } k \text{ thành công}} \cdot \overbrace{\binom{N-K}{n-k}}^{\text{Chọn } n-k \text{ thất bại}} }{ \underbrace{\binom{N}{n}}_{\text{Tổng số cách chọn ra } n \text{ mẫu}} }$$
:::

```{ojs}
//| echo: false
viewof ace_sim_manual = (() => {
  // --- 1. SETUP DOM & STYLES ---
  const container = document.createElement("div");
  container.style.cssText = `
    width: 400px;
    height: 440px; 
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid transparent; /* Prevents margin collapse */
  `;

  // Inject UI HTML directly (Total Control)
  container.innerHTML = `
    <style>
      .ace-controls-row {
        width: 100%;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 12px;
        margin-bottom: 5px;
      }
      .ace-btn {
        padding: 6px 14px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        background-color: white;
        color: #374151;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        line-height: 1.2;
      }
      .ace-btn:hover { background-color: #f3f4f6; }
      .ace-btn-primary {
        background-color: #3b82f6; 
        color: white; 
        border-color: #2563eb;
      }
      .ace-btn-primary:hover { background-color: #2563eb; color: white; }
      
      .ace-toggle {
        display: flex; align-items: center; gap: 6px;
        font-size: 14px; font-weight: 500; color: #4b5563;
        cursor: pointer; user-select: none;
      }
      .ace-toggle input { width: 16px; height: 16px; accent-color: #10b981; cursor: pointer; }
      
      canvas { display: block; } /* Removes ghost margin */
    </style>

    <div class="ace-controls-row">
      <button id="btn-draw" class="ace-btn ace-btn-primary">Rút 10 lá</button>
      <label class="ace-toggle">
        <input type="checkbox" id="chk-auto">
        Tự động chạy
      </label>
      <button id="btn-reset" class="ace-btn">Làm lại</button>
    </div>
  `;

  // --- 2. CANVAS SETUP ---
  const width = 400;
  const height = 380;
  const canvas = document.createElement("canvas");
  const dpr = window.devicePixelRatio || 1;
  
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.scale(dpr, dpr);
  container.appendChild(canvas);

  // --- 3. STATE & CONSTANTS ---
  const SUITS = ["♠", "♥", "♣", "♦"];
  const RANKS = ["2","3","4","5","6","7","8","9","10","J","Q","K","A"];
  const CARD_W = 30, CARD_H = 45;
  
  // Layout Constants
  const Y_HEADER = 45;
  const Y_CARDS = 85;
  const Y_CHART_BASE = 320;
  const CHART_H = 60;
  
  // Colors
  const BG_COLOR="#fff", TEXT_COLOR="#333333", ACE_COLOR="#d35400", ACE_BG="#fffbe6";
  const CARD_BG="#ffffff", CARD_BORDER="#cccccc", RED="#e74c3c", BLACK="#2c3e50";
  const CHART_THEO="rgba(44, 62, 80, 0.1)", CHART_ACT="#009688", CHART_ACTIVE="#00796b";
  const DECK_BACK="#c0392b";

  function hypergeom(k, N, K, n) {
     function nCr(n, r) {
        if (r < 0 || r > n) return 0;
        let res = 1;
        for(let i=0; i<r; i++) res = res * (n - i) / (i + 1);
        return res;
     }
     return (nCr(K, k) * nCr(N - K, n - k)) / nCr(N, n);
  }
  const THEORETICAL = [];
  for(let k=0; k<=4; k++) THEORETICAL[k] = hypergeom(k, 52, 4, 10);

  const S = {
     counts: [0, 0, 0, 0, 0], 
     totalDeals: 0,
     lastHand: [],
     animation: 0, 
     cooldown: 0,
     isAuto: false
  };

  // --- 4. LOGIC ---
  function runDeal() {
    let deck = [];
    for(let s of SUITS) {
      for(let r of RANKS) deck.push({ rank: r, suit: s, isAce: r === "A" });
    }
    for(let i=deck.length-1; i>0; i--) {
       const j = Math.floor(Math.random() * (i+1));
       [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    
    const hand = deck.slice(0, 10);
    const aceCount = hand.filter(c => c.isAce).length;
    S.counts[aceCount]++;
    S.totalDeals++;
    
    // Animation targets
    const startX = (width - (5 * (CARD_W + 8))) / 2 + 4;
    S.lastHand = hand.map((c, i) => {
       const row = Math.floor(i / 5);
       const col = i % 5;
       return {
         ...c,
         x: 30, y: 30,
         targetX: startX + col * (CARD_W + 8),
         targetY: Y_CARDS + row * (CARD_H + 12),
         t: 0
       };
    });
    S.animation = 1;
    S.cooldown = 0; 
  }

  function reset() {
     S.counts = [0,0,0,0,0];
     S.totalDeals = 0;
     S.lastHand = [];
     S.animation = 0;
  }

  // --- 5. LOOP ---
  function update() {
     if (S.isAuto && S.animation === 0) {
        S.cooldown++;
        if (S.cooldown > 40) runDeal();
     }

     if (S.animation === 1) {
       let done = true;
       for (let c of S.lastHand) {
          if (c.t < 1) {
             c.t += 0.1; 
             if (c.t > 1) c.t = 1;
             const ease = 1 - Math.pow(1 - c.t, 3);
             c.x = 30 + (c.targetX - 30) * ease;
             c.y = 30 + (c.targetY - 30) * ease;
             done = false;
          }
       }
       if (done) S.animation = 0;
    }
  }

  function draw() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, width, height);
    
    ctx.save();
    ctx.font = "bold 14px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fontVariantNumeric = "tabular-nums";

    // Header
    ctx.textAlign = "left"; ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(`Lần rút: ${S.totalDeals}`, 75, Y_HEADER); 
    
    if (S.isAuto) {
        ctx.textAlign = "center"; ctx.fillStyle = CHART_ACT;
        ctx.fillText("● Đang chạy...", width/2, Y_HEADER);
    }

    if (S.lastHand.length > 0) {
       const aces = S.lastHand.filter(c=>c.isAce).length;
       ctx.textAlign = "right"; ctx.fillStyle = ACE_COLOR;
       ctx.fillText(`Kết quả: ${aces} lá Át`, width - 30, Y_HEADER); 
    }
    ctx.restore();

    // Deck
    for(let i=0; i<3; i++) {
      ctx.fillStyle = "white"; ctx.strokeStyle = "#ccc";
      ctx.fillRect(30-i*2, 30-i*2, CARD_W, CARD_H);
      ctx.strokeRect(30-i*2, 30-i*2, CARD_W, CARD_H);
    }
    ctx.fillStyle = DECK_BACK; ctx.fillRect(30, 30, CARD_W, CARD_H);
    ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.strokeRect(34, 34, CARD_W-8, CARD_H-8);
    ctx.lineWidth = 1;

    // Hand
    for (let c of S.lastHand) {
        ctx.fillStyle = c.isAce ? ACE_BG : CARD_BG;
        ctx.fillRect(c.x, c.y, CARD_W, CARD_H);
        
        ctx.strokeStyle = c.isAce ? ACE_COLOR : CARD_BORDER;
        ctx.strokeRect(c.x, c.y, CARD_W, CARD_H);

        const isRed = (c.suit === "♥" || c.suit === "♦");
        ctx.fillStyle = c.isAce ? ACE_COLOR : (isRed ? RED : BLACK);
        ctx.textAlign = "left"; ctx.textBaseline = "top";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText(c.rank, c.x + 3, c.y + 4);
        ctx.font = "16px sans-serif";
        ctx.fillText(c.suit, c.x + 3, c.y + 20);
    }

    // Chart
    const chartX = 50, barW = 40, gap = 25;
    
    ctx.beginPath(); ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 1;
    ctx.moveTo(chartX - 10, Y_CHART_BASE); ctx.lineTo(width - 20, Y_CHART_BASE); ctx.stroke();
    
    ctx.save();
    ctx.fillStyle = TEXT_COLOR; ctx.font = "12px sans-serif"; ctx.textAlign = "center";
    ctx.fillText("Số lá Át rút được (k)", width/2 + 15, Y_CHART_BASE + 35);
    
    ctx.translate(20, Y_CHART_BASE - CHART_H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillStyle = "#7f8c8d";
    ctx.fillText("Tần suất", 0, 0);
    ctx.restore();

    const activeAces = S.lastHand.filter(c=>c.isAce).length;

    for (let k = 0; k <= 4; k++) {
       const x = chartX + k * (barW + gap);
       const Y_SCALE = 0.5;
       
       const theoH = (THEORETICAL[k] / Y_SCALE) * CHART_H;
       ctx.fillStyle = CHART_THEO;
       ctx.fillRect(x, Y_CHART_BASE - theoH, barW, theoH);
       
       let count = S.counts[k];
       let pct = S.totalDeals > 0 ? count / S.totalDeals : 0;
       let barH = (pct / Y_SCALE) * CHART_H;
       if (barH > CHART_H + 10) barH = CHART_H + 10;
       
       const isActive = (S.animation === 0 && S.totalDeals > 0 && k === activeAces);
       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_ACT;
       ctx.fillRect(x, Y_CHART_BASE - barH, barW, barH);
       
       ctx.save();
       ctx.fontVariantNumeric = "tabular-nums";
       ctx.fillStyle = TEXT_COLOR; ctx.font = "12px sans-serif"; ctx.textAlign = "center";
       ctx.fillText(k, x + barW/2, Y_CHART_BASE + 15);
       ctx.restore();
    }
  }

  // --- 6. BINDINGS ---
  const btnDraw = container.querySelector("#btn-draw");
  const btnReset = container.querySelector("#btn-reset");
  const chkAuto = container.querySelector("#chk-auto");

  btnDraw.onclick = () => runDeal();
  btnReset.onclick = () => reset();
  chkAuto.onchange = (e) => { S.isAuto = e.target.checked; };

  let frameId;
  function tick() {
    update();
    draw();
    frameId = requestAnimationFrame(tick);
  }
  tick();

  // Clean up
  if (this && this.invalidation) this.invalidation.then(() => cancelAnimationFrame(frameId));

  return container;
})();
```

## Đếm số lần thử

Chúng ta quyết định trước phần thưởng mình muốn đạt được ($k$ thành công), và đếm xem phải tốn bao nhiêu công sức ($n$ lần thử) để đạt được nó. Nhánh này mô hình hóa sự "kiên trì" hoặc "sức chịu đựng".

### Phân phối hình học (geometric distribution)

Tình huống: Một gia đình phong kiến trọng nam khinh nữ muốn có một đứa con trai, họ cứ sinh con cho đến khi có con trai thì thôi

Câu hỏi: Họ phải sinh bao nhiêu con cho đến khi có con trai?

Đặc tính: Không có bộ nhớ (Memoryless). Dù đã sinh 10 con gái liên tiếp, xác suất đứa tiếp theo là trai vẫn y như lúc bắt đầu.

### Phân phối Nhị thức âm (negative binomial distribution)

Tình huống: Gia đình phong kiến đã sinh được con trai nhưng vẫn muốn có con trai nữa, thầy bói nói nhà phải có 3 đứa con trai mới giàu được

Câu hỏi: Họ sẽ sinh bao nhiêu con trước khi có được đứa con trai thứ 3?

Về lý thuyết, đây là tổng của $k$ biến thuộc phân phối hình học.

Trong sinh học thực tế (ví dụ: đếm số ký sinh trùng, ấu trùng muỗi), phương sai thường lớn hơn trung bình rất nhiều (do hiện tượng tụ đám/clumping). Phân phối Nhị thức Âm khớp với kiểu dữ liệu này tốt hơn nhiều so với Poisson hay Nhị thức.

## Đếm sự kiện khi biết tốc độ trung bình

### Phân phối Poisson

Khác với những phân phối kể trên, phân phối Poisson không dựa trên chuỗi Bernoulli, mà dựa trên quá trình Poisson (Poisson process).

Quá trình Poisson là 1 cơ chế xảy ra biến cố với các điều kiện:

- Các biến cố xảy ra độc lập nhau (independent): biến cố này xảy ra không ảnh hưởng đến xác suất xảy ra của biến cố tiếp theo
- Các biến cố xảy ra với 1 **tốc độ trung bình không đổi**: Số lượng sự kiện trung bình trên một đơn vị thời gian là hằng số (ví dụ: trung bình có 5 chiếc xe chạy trên con đường này mỗi giờ)
- Các biến cố không xảy ra cùng 1 lúc

Phân phối Poisson dùng để đếm **số lượng** biến cố ngẫu nhiên xảy ra trong 1 khoảng thời gian cố định (với điều kiện $\lambda$ không thay đổi trong khoảng thời gian này) của quá trình Poisson.

$$P(X=k) = \frac{e^{-\lambda} \lambda^k}{k!}$$

Trong đó:

- $\lambda$: Tốc độ trung bình (kỳ vọng) số sự kiện trong khoảng thời gian đó.
- $k$: Số sự kiện muốn tính xác suất.

### Ví dụ

Tại một phòng cấp cứu, trung bình cứ 1 giờ lại có 3 bệnh nhân đến khám ($\lambda = 3$). Xác suất để trong 1 giờ tới có chính xác 5 ca đến khám là bao nhiêu?

Áp dụng công thức với $\lambda = 3$ và $k = 5$:

$$P(X=5) = \frac{e^{-3} \cdot 3^5}{5!} = \frac{0.0498 \times 243}{120} \approx 0.1008 \quad (\approx 10\%)$$

Poisson là giới hạn của Nhị thức khi $n \to \infty$ và xác suất thành công $p \to 0$, sao cho $np = \lambda$

Hãy tưởng tượng bạn đang ngồi đợi tin nhắn điện thoại trong 1 giờ. Dựa vào kinh nghiệm, trung bình bạn nhận được $\lambda = 5$ tin nhắn/giờ. Xác suất trong 1 giờ tới bạn chỉ nhận được 2 tin nhắn là bao nhiêu?

- Bạn chia 1 giờ thành 60 phút. Mỗi phút là một phép thử Bernoulli (có tin nhắn/không tin nhắn). Bạn có $n = 60$ phép thử liên tiếp.
- Bạn chia nhỏ thời gian ra nữa. Lúc này số phép thử $n$ trở nên vô cùng lớn, và xác suất có tin nhắn trong một khoảnh khắc siêu nhỏ ($p$) trở nên vô cùng nhỏ. Càng chia nhỏ, bạn sẽ thấy phân phối nhị thức càng gần với Poisson.

```{ojs}
//| echo: false
viewof poisson_visual_final = (() => {
  // --- 1. CONFIGURATION ---
  const lambda = 5; 
  
  // Input Slider (Width 400px to match binning bar)
  const form = Inputs.range([10, 360], {
    value: 10, 
    step: 5, 
    label: "Chia 1 giờ thành n khoảng (n)"
  });
  
  const wrapper = document.createElement("div");
  wrapper.style.cssText = `
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    margin-top: 20px;
  `;
  
  // --- 2. TIME BIN VISUALIZATION (Canvas) ---
  const timeCanvas = document.createElement("canvas");
  const timeW = 400; // REDUCED WIDTH
  const timeH = 50;
  const dpr = window.devicePixelRatio || 1;
  
  timeCanvas.width = timeW * dpr;
  timeCanvas.height = timeH * dpr;
  timeCanvas.style.width = `${timeW}px`;
  timeCanvas.style.height = `${timeH}px`;
  timeCanvas.style.marginTop = "10px"; 
  timeCanvas.style.marginBottom = "5px";
  
  const tCtx = timeCanvas.getContext("2d");
  tCtx.scale(dpr, dpr);

  // --- 3. STATS DISPLAY ---
  const statsDiv = document.createElement("div");
  statsDiv.style.cssText = `
    margin-bottom: 5px; 
    font-size: 16px; 
    color: #333;
    font-weight: 500;
  `;
  
  // --- 4. APPEND ELEMENTS (Order: Input -> Binning -> Stats -> Plot) ---
  wrapper.appendChild(form);       
  wrapper.appendChild(timeCanvas); 
  wrapper.appendChild(statsDiv);   
  const plotContainer = document.createElement("div");
  wrapper.appendChild(plotContainer); 

  // --- 5. MATH HELPERS ---
  function getBinomialData(n, p) {
    const data = [];
    let prob = Math.pow(1 - p, n); 
    for (let k = 0; k <= 16; k++) {
      data.push({k, type: "Binomial", prob});
      if (k < n) {
        prob = prob * ((n - k) / (k + 1)) * (p / (1 - p));
      } else {
        prob = 0;
      }
    }
    return data;
  }

  const poissonData = [];
  {
    let prob = Math.exp(-lambda); 
    for (let k = 0; k <= 16; k++) {
      poissonData.push({k, type: "Poisson", prob});
      prob = prob * lambda / (k + 1);
    }
  }

  // --- 6. RENDER LOOPS ---
  function drawTimeBins(n) {
    tCtx.clearRect(0, 0, timeW, timeH);
    
    const barX = 0; // Start at 0 since canvas is now exact width
    const barY = 15;
    const barW = timeW;
    const barH = 20;
    
    // Background
    tCtx.fillStyle = "#f3f4f6";
    tCtx.fillRect(barX, barY, barW, barH);
    tCtx.strokeStyle = "#9ca3af";
    tCtx.lineWidth = 1;
    tCtx.strokeRect(barX, barY, barW, barH);
    
    // Draw Dividers
    tCtx.beginPath();
    tCtx.strokeStyle = n > 150 ? "rgba(107, 114, 128, 0.5)" : "#6b7280";
    tCtx.lineWidth = n > 200 ? 0.5 : 1; 

    const binSize = barW / n;
    
    // Draw internal lines
    for (let i = 1; i < n; i++) {
        const x = Math.floor(barX + i * binSize) + 0.5;
        tCtx.moveTo(x, barY);
        tCtx.lineTo(x, barY + barH);
    }
    tCtx.stroke();
    
    // Labels
    tCtx.fillStyle = "#374151";
    tCtx.font = "bold 12px sans-serif";
    
    tCtx.textAlign = "left"; 
    tCtx.fillText("0", barX, barY + barH + 14);
    
    tCtx.textAlign = "right"; 
    tCtx.fillText("1h", barX + barW, barY + barH + 14);
    
    // Center Label (Changed Text)
    tCtx.textAlign = "center"; 
    tCtx.fillStyle = "#3b82f6";
    tCtx.fillText(`${n} phép thử liên tiếp`, timeW / 2, barY - 5);
  }

  function update() {
    const n = form.value;
    const p = lambda / n; 
    
    // Update Stats
    statsDiv.innerHTML = `n = ${n} &nbsp;|&nbsp; p = ${p.toFixed(4)} &nbsp;|&nbsp; np = ${(n*p).toFixed(1)}`;

    // Update Top Canvas
    drawTimeBins(n);

    // Update Plot
    const binomData = getBinomialData(n, p);
    const combinedData = poissonData.concat(binomData);
    const xDomain = Array.from({length: 17}, (_, i) => i);

    const chart = Plot.plot({
      width: 600,
      height: 320,
      marginTop: 20,
      x: { 
        type: "band", 
        domain: xDomain, 
        label: "Số tin nhắn (k)",
        padding: 0.1
      },
      y: { label: "Xác suất", domain: [0, 0.2] },
      marks: [
        // Binomial Bars
        Plot.barY(combinedData.filter(d => d.type === "Binomial"), {
          x: "k", 
          y: "prob", 
          fill: "#3b82f6", 
          fillOpacity: 0.6,
          title: d => `Binomial: ${d.prob.toFixed(4)}`
        }),
        // Poisson Line
        Plot.line(combinedData.filter(d => d.type === "Poisson"), {
          x: "k", 
          y: "prob", 
          stroke: "#be185d", 
          strokeWidth: 3,
          curve: "monotone-x"
        }),
        // Poisson Dots
        Plot.dot(combinedData.filter(d => d.type === "Poisson"), {
          x: "k", 
          y: "prob", 
          fill: "#be185d",
          r: 4
        }),
        Plot.ruleY([0])
      ]
    });

    plotContainer.innerHTML = "";
    plotContainer.appendChild(chart);
  }

  form.addEventListener("input", update);
  update();

  return wrapper;
})();
```

## Ứng dụng

Dữ liệu dạng đếm (ví dụ: số ca bệnh trong 1 tuần):

- Poisson
- Negative binomial

Dữ liệu là tỉ lệ:



Các phân phối phức tạp có thể được tạo ra bằng cách cộng các phân phối đơn giản:

| Nếu cộng | Sẽ có | Điều kiện |
|------------------------|------------------------|------------------------|
| Nhiều Bernoulli | Nhị thức | Cùng $p$. |
| Nhiều Nhị thức | Nhị thức | $X+Y \sim \text{Bin}(n+m, p)$ |
| Nhiều Hình học | Nhị thức âm | Chờ $k$ thành công thực chất là chờ 1 thành công, lặp lại $k$ lần |
| Nhiều Nhị thức âm | Nhị thức âm | $X+Y \sim \text{NB}(r_1+r_2, p)$ |
| Nhiều Poisson | Poisson | $X+Y \sim \text{Pois}(\lambda_1 + \lambda_2)$ |
