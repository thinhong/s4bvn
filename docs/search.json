[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistics for babies",
    "section": "",
    "text": "Preface\nSách được biên soạn dựa trên các tài liệu:\n\nGiáo trình “STATS 210: Statistical Theory” của Bộ môn Thống kê, Đại học Auckland\nSách “Ecological Models and Data in R” của Benjamin M. Bolker (2008)\n\nCách dịch các thuật ngữ tiếng Việt được tham khảo từ Wikipedia.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "prob.html",
    "href": "prob.html",
    "title": "1  Xác suất",
    "section": "",
    "text": "1.1 Nguồn gốc\nLý thuyết xác suất ra đời để giải quyết một vấn đề trong cờ bạc. Vấn đề cụ thể khai sinh ra lĩnh vực này được gọi là “Bài toán Chia điểm” (Problem of Points).\nNăm 1654, nhà văn kiêm tay cờ bạc Antoine Gombaud viết thư cho nhà toán học Blaise Pascal để hỏi cách giải quyết một ván bài dang dở:\nCâu hỏi: Làm sao chia 100$ cho công bằng?\nTại sao đây là một bài toán khó?\nVào thời đó, con người chưa biết cách xử lý “tương lai” bằng toán học. Có người đề nghị: “A được 2 điểm, B được 1 điểm. Vậy chia 100$ làm 3, A được 67$, B được 33$.” Cách này không công bằng vì chỉ nhìn vào quá khứ mà phớt lờ lợi thế của A: A chỉ cần thắng thêm đúng 1 ván là xong, trong khi B phải thắng liên tiếp 2 ván.\nPascal thấy bài toán này rất thú vị và gửi nó cho nhà toán học Pierre de Fermat. Họ giải quyết vấn đề bằng cách thay đổi góc nhìn. Thay vì nhìn vào quá khứ (những gì đã xảy ra trong ván bài), họ nhìn vào tương lai (các khả năng sẽ xảy ra của trò chơi).\nLời giải:\nFermat tưởng tượng xem trò chơi có thể diễn ra như thế nào nếu tiếp tục chơi cho đến cùng. Trò chơi sẽ kết thúc tối đa trong 2 ván nữa (vì A thắng 1 ván là xong, hoặc B thắng 2 ván là xong). Để cho công bằng, ta cho A và B chơi thêm 2 ván.\nCó 4 kịch bản của 2 ván này:\nKết quả:\nNếu tiếp tục chơi, chỉ có 4 kịch bản có thể xảy ra, trong đó A thắng 3 lần, B thắng 1 lần. Vậy khả năng A thắng là 3/4 trường hợp, và B thắng 1/4 trường hợp. Vậy A nên được chia 3/4 của 100$ là 75$, và B được chia 25$.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#nguồn-gốc",
    "href": "prob.html#nguồn-gốc",
    "title": "1  Xác suất",
    "section": "",
    "text": "Hai người A và B chơi một trò hoàn toàn may rủi (ví dụ tung đồng xu, kéo-búa-bao), ai thắng 3 ván trước sẽ là người chiến thắng cuối cùng\nMỗi người đặt 50$, tổng là 100$, ai thắng sẽ được toàn bộ tiền thưởng 100$\nTrò chơi phải dừng đột ngột khi A đang dẫn trước 2-1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVán 1\nVán 2\nChung cuộc\nTỉ số A:B\n\n\n\n\nA thắng\nA thắng\nA thắng\n4-1\n\n\nB thắng\nA thắng\n3-2\n\n\nB thắng\nA thắng\nA thắng\n3-2\n\n\nB thắng\nB thắng\n2-3",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#định-nghĩa",
    "href": "prob.html#định-nghĩa",
    "title": "1  Xác suất",
    "section": "1.2 Định nghĩa",
    "text": "1.2 Định nghĩa\nTrong bài toán trên, khả năng thắng cuộc chính là xác suất.\nXác suất (Probability): là một con số nằm trong khoảng từ 0 đến 1, dùng để đo lường khả năng xảy ra của một sự kiện.\n\n0 = chắc chắn không xảy ra\n1 = chắc chắn sẽ xảy ra\n\nCó 2 cách tiếp cận xác suất:\n\nTần suất (frequentist):\n\n\\[\\text{Xác suất} = \\frac{\\text{Số lần sự kiện xảy ra}}{\\text{Tổng số lần quan sát}}\\]\n\nNiềm tin (degree of belief, Bayesian): mức độ tin tưởng của người đánh giá về khả năng xảy ra của sự kiện.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "prob.html#các-khái-niệm-cơ-bản",
    "href": "prob.html#các-khái-niệm-cơ-bản",
    "title": "1  Xác suất",
    "section": "1.3 Các khái niệm cơ bản",
    "text": "1.3 Các khái niệm cơ bản\n\n1.3.1 Phép thử ngẫu nhiên (random experiment)\nLà một thử nghiệm mà chúng ta không biết trước kết quả cho đến khi nó thực sự diễn ra.\nVí dụ: tung đồng xu (không biết sẽ ra mặt sấp hay mặt ngửa), làm xét nghiệm cho một người (không biết là âm tính hay dương tính)\n\n\n1.3.2 Không gian mẫu (sample space \\(\\Omega\\))\nLà tập hợp chứa tất cả các kết quả có thể xảy ra của một phép thử ngẫu nhiên, mỗi kết quả liệt kê đúng một lần duy nhất.\nVí dụ: không gian mẫu của tung đồng xu là \\(\\Omega = \\{ \\text{sấp}, \\text{ngửa} \\}\\)\nKhông gian mẫu là 1 tập hợp, nên có thể sử dụng các phép toán của tập hợp cho không gian mẫu (\\(\\cup\\) hay \\(\\cap\\)).\n\n\n1.3.3 Điểm mẫu (sample point)\nLà một phần tử của không gian mẫu.\nVí dụ: không gian mẫu của tung đồng xu là \\(\\Omega = \\{ \\text{sấp}, \\text{ngửa} \\}\\) thì \\(\\{ \\text{sấp} \\}\\) hoặc \\(\\{ \\text{ngửa} \\}\\) là một điểm mẫu.\n\n\n1.3.4 Kết quả (outcome)\nLà điểm mẫu quan sát được, khi chúng ta cho thực hiện phép thử ngẫu nhiên.\n\n\n1.3.5 Biến cố/Sự kiện (event)\nLà một tập hợp con của không gian mẫu. Bất kỳ tập hợp nào chứa các kết quả đều tạo thành một biến cố.\nVí dụ: Tung một đồng xu hai lần. Không gian mẫu: \\(\\Omega = \\{ SS, SN, NS, NN \\}\\).\nGọi biến cố \\(A\\) là “có đúng một mặt ngửa”, \\(A = \\{ SN, NS \\}\\).\n\\(A\\) là một tập con của \\(\\Omega\\) (\\(A \\subset \\Omega\\)).\nBiến cố \\(A\\) được gọi là xảy ra (occurs) nếu chúng ta quan sát được một kết quả là phần tử của tập hợp \\(A\\).\n\n\n1.3.6 Ví dụ\n\nPhép thử ngẫu nhiên: “Tung một đồng xu hai lần”\nKhông gian mẫu: \\(\\Omega = \\{ SS, SN, NS, NN \\}\\)\nBiến cố “có đúng một mặt ngửa”: \\(A = \\{ SN, NS \\}\\)\nChúng ta thực sự tiến hành phép thử ngẫu nhiên:\n\n\nset.seed(27)\ncoin &lt;- c(\"S\", \"N\")\n\nsample(coin, size = 2, replace = TRUE)\n\n[1] \"S\" \"N\"\n\n\n\nKết quả thu được là \\(SN\\), là phần tử của \\(A = \\{ SN, NS \\}\\), vậy ta nói lần thử này biến cố \\(A\\) có xảy ra\nXác suất là con số thể hiện khả năng xảy ra của từng điểm mẫu hay biến cố trong \\(\\Omega\\)\n\nXác suất luôn gắn liền với không gian mẫu. Xác suất sẽ thay đổi trong các không gian mẫu khác nhau.\n\n\n\n\n\n\nNoteBài tập\n\n\n\nTìm một ví dụ phép thử ngẫu nhiên khác và mô tả lại các định nghĩa này.\n\n\n\n\n1.3.7 Rời rạc (discrete)\nLà khi có “khoảng trống” giữa các giá trị.\nVí dụ: 1, 2, 3…\n\nviewof prob_radial_flood = Inputs.range([0, 1], {\n  label: \"Xác suất\", \n  step: 0.01, \n  value: 0.3\n})\n\n// 1. CONFIGURATION\nradial_config_flood = ({\n  center: {x: 0.5, y: 0.2}, \n  n: 100\n})\n\n// 2. GENERATE STATIC PEOPLE\npeople_radial_flood = {\n  const rng = d3.randomLcg(42); \n  return Array.from({length: radial_config_flood.n}, (_, i) =&gt; ({\n    id: i,\n    x: rng(), \n    y: rng() * 0.4 \n  }));\n}\n\n// 3. REACTIVE SELECTION\ncurrentData_radial_flood = {\n  const cutoff = Math.round(prob_radial_flood * 100);\n  \n  const cx = radial_config_flood.center.x;\n  const cy = radial_config_flood.center.y;\n  \n  const withDist = people_radial_flood.map(p =&gt; {\n    const dx = p.x - cx;\n    const dy = p.y - cy;\n    return { ...p, dist: dx*dx + dy*dy }; \n  });\n  \n  const sorted = withDist.slice().sort((a, b) =&gt; a.dist - b.dist);\n  const selectedSet = new Set(sorted.slice(0, cutoff).map(d =&gt; d.id));\n\n  return people_radial_flood.map(p =&gt; ({\n    ...p,\n    status: selectedSet.has(p.id) ? \"Selected\" : \"Not selected\"\n  }));\n}\n\n// 4. PLOT\nPlot.plot({\n  width: 800,\n  height: 320,\n  x: { axis: null },\n  y: { axis: null },\n  \n  marks: [\n    Plot.frame({stroke: \"#ccc\"}),\n\n    // --- DENSITY (The Flood) ---\n    Plot.density(currentData_radial_flood, {\n      filter: d =&gt; d.status === \"Selected\",\n      x: \"x\",\n      y: \"y\",\n      fill: \"#4e79a7\",\n      fillOpacity: 0.3,\n      \n      // KEY CHANGES HERE:\n      bandwidth: 50,    // High bandwidth = Very smooth, merging clusters\n      thresholds: [0.005] // Low threshold = Draws even faint outer edges\n    }),\n\n    // --- DOTS ---\n    Plot.dot(currentData_radial_flood, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.status === \"Selected\" ? \"#4e79a7\" : \"#e0e0e0\",\n      r: 4,\n      fillOpacity: 0.9\n    }),\n    \n    // --- LABELS ---\n    Plot.text([prob_radial_flood], {\n      frameAnchor: \"bottom-left\",\n      dx: 10, dy: -10,\n      text: d =&gt; `Số người: ${Math.round(d * 100)}/100`, \n      fill: \"black\", stroke: \"white\", strokeWidth: 3,\n      fontSize: 16, fontWeight: \"bold\"\n    }),\n\n    Plot.text([\"Ω\"], {\n      frameAnchor: \"top-right\", dx: -15, dy: 15, \n      fontSize: 30, fontWeight: \"bold\", fill: \"#999\"\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.3.8 Liên tục (continuous)\nLà khi không có khoảng trống giữa các giá trị.\nVí dụ: \\([0,1]\\)\n\n\n1.3.9 Xung khắc (mutually exclusive)\nHai biến cố \\(A\\) và \\(B\\) được gọi là xung khắc (mutually exclusive) nếu giao của chúng là tập rỗng:\n\\[A \\cap B = \\emptyset\\]\nNghĩa là biến cố \\(A\\) và \\(B\\) không thể cùng xảy ra. Nếu \\(A\\) xảy ra thì \\(B\\) không thể xảy ra, và ngược lại.\n\nviewof input_a_me = Inputs.range([0, 1], {\n  value: 0.05,\n  step: 0.01,\n  label: \"P(A)\"\n})\n\nviewof input_b_me = Inputs.range([0, 1], {\n  value: 0.05,\n  step: 0.01,\n  label: \"P(B)\"\n})\n\n// 2. LOGIC (Clamp the values here)\n// This calculates the \"Actual\" probability used in the plot.\n// If A+B &gt; 1, we squeeze B to fit the remaining space.\nprob_a_safe = input_a_me\nprob_b_safe = Math.min(input_b_me, 1 - input_a_me)\n\n// 1. CONFIGURATION\nsim_config_me2 = ({\n  N: 1500,                    \n  centerA: {x: 0.3, y: 0.5}, \n  centerB: {x: 0.7, y: 0.5}  \n})\n\n// 2. GENERATE POINTS (Static)\nsubstratePoints_me2 = {\n  const rng = d3.randomLcg(42); \n  const points = [];\n  for(let i = 0; i &lt; sim_config_me2.N; i++) {\n    const px = rng();\n    const py = rng();\n    const dA = (px - sim_config_me2.centerA.x)**2 + (py - sim_config_me2.centerA.y)**2;\n    const dB = (px - sim_config_me2.centerB.x)**2 + (py - sim_config_me2.centerB.y)**2;\n    points.push({id: i, x: px, y: py, distA: dA, distB: dB});\n  }\n  return points;\n}\n\n// 3. CLASSIFY LOGIC (Uses Safe/Clamped Probabilities)\nclassifiedPoints_me2 = {\n  const targetCountA = Math.round(sim_config_me2.N * prob_a_safe);\n  const targetCountB = Math.round(sim_config_me2.N * prob_b_safe);\n\n  // --- SELECT A ---\n  const sortedByA = substratePoints_me2.slice().sort((a, b) =&gt; a.distA - b.distA);\n  const idsA = new Set(sortedByA.slice(0, targetCountA).map(d =&gt; d.id));\n\n  // --- SELECT B (Mutually Exclusive) ---\n  const availableForB = substratePoints_me2.filter(p =&gt; !idsA.has(p.id));\n  availableForB.sort((a, b) =&gt; a.distB - b.distB);\n  const idsB = new Set(availableForB.slice(0, targetCountB).map(d =&gt; d.id));\n\n  // --- ASSIGN STATUS ---\n  return substratePoints_me2.map(p =&gt; {\n    let status = \"Ω\";\n    if (idsA.has(p.id)) status = \"A\";\n    else if (idsB.has(p.id)) status = \"B\";\n\n    return { \n      ...p, \n      status,\n      isA: status === \"A\",\n      isB: status === \"B\"\n    };\n  });\n}\n\n// 4. THE PLOT\nPlot.plot({\n  width: 500,\n  height: 500,\n  x: {axis: null, domain: [0,1]},\n  y: {axis: null, domain: [0,1]},\n  \n  marks: [\n    Plot.frame({stroke: \"#ccc\"}),\n\n    // --- DENSITY LAYER A ---\n    Plot.density(classifiedPoints_me2, {\n      x: \"x\", y: \"y\",\n      fill: \"#6ecae1\",\n      fillOpacity: 0.3,\n      thresholds: [0.1],\n      bandwidth: 15,\n      weight: d =&gt; d.isA ? 1 : (d.isB ? -1 : 0)\n    }),\n\n    // --- DENSITY LAYER B ---\n    Plot.density(classifiedPoints_me2, {\n      x: \"x\", y: \"y\",\n      fill: \"#f7941d\",\n      fillOpacity: 0.3,\n      thresholds: [0.1],\n      bandwidth: 15,\n      weight: d =&gt; d.isB ? 1 : (d.isA ? -1 : 0)\n    }),\n    \n    // Use 'prob_a_safe' for the label so it matches the plot\n    Plot.text([sim_config_me2.centerA], {\n      x: \"x\", y: \"y\", text: [`P(A) = ${prob_a_safe.toFixed(2)}`], \n      fill: \"black\", fontWeight: \"bold\", fontSize: 16, stroke: \"white\", strokeWidth: 3\n    }),\n    Plot.text([sim_config_me2.centerB], {\n      x: \"x\", y: \"y\", text: [`P(B) = ${prob_b_safe.toFixed(2)}`], \n      fill: \"black\", fontWeight: \"bold\", fontSize: 16, stroke: \"white\", strokeWidth: 3\n    }),\n\n    Plot.text([\"Ω\"], {frameAnchor: \"top-right\", dx: -10, dy: 10, fill: \"#999\", fontSize: 20, fontWeight: \"bold\"}),\n    \n    // Total & Warning Label\n    Plot.text([prob_a_safe + prob_b_safe], {\n       frameAnchor: \"bottom\", dy: -10,\n       text: d =&gt; {\n         const isCapped = (input_a_me + input_b_me &gt; 1.001);\n         return `P(A ⋃ B) = ${d.toFixed(2)} ${isCapped ? \"(Capped!)\" : \"\"}`\n       },\n       fontSize: 16, \n       fontWeight: \"bold\", \n       fill: (input_a_me + input_b_me &gt; 1.001) ? \"#d32f2f\" : \"#555\", // Red if capped\n       stroke: \"white\", \n       strokeWidth: 4\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof prob_a_ov = Inputs.range([0, 1], {\n  value: 0.30,\n  step: 0.01,\n  label: \"P(A)\"\n})\n\nviewof prob_b_ov = Inputs.range([0, 1], {\n  value: 0.20,\n  step: 0.01,\n  label: \"P(B)\"\n})\n\n// 1. CONFIGURATION (Same as before)\nsim_config_dens = ({\n  N: 5000,                    \n  centerA: {x: 0.3, y: 0.5}, \n  centerB: {x: 0.7, y: 0.5}  \n})\n\n// 2. GENERATE POINTS (Same as before)\nsubstratePoints_dens = {\n  const rng = d3.randomLcg(42); \n  const points = [];\n  for(let i = 0; i &lt; sim_config_dens.N; i++) {\n    const px = rng();\n    const py = rng();\n    const dA = (px - sim_config_dens.centerA.x)**2 + (py - sim_config_dens.centerA.y)**2;\n    const dB = (px - sim_config_dens.centerB.x)**2 + (py - sim_config_dens.centerB.y)**2;\n    points.push({id: i, x: px, y: py, distA: dA, distB: dB});\n  }\n  return points;\n}\n\n// 3. CLASSIFY LOGIC (Same \"Overlap\" Logic)\nclassifiedPoints_dens = {\n  const targetCountA = Math.round(sim_config_dens.N * prob_a_ov);\n  const targetCountB = Math.round(sim_config_dens.N * prob_b_ov);\n\n  // A Selection\n  const sortedByA = substratePoints_dens.slice().sort((a, b) =&gt; a.distA - b.distA);\n  const idsA = new Set(sortedByA.slice(0, targetCountA).map(d =&gt; d.id));\n\n  // B Selection\n  const sortedByB = substratePoints_dens.slice().sort((a, b) =&gt; a.distB - b.distB);\n  const idsB = new Set(sortedByB.slice(0, targetCountB).map(d =&gt; d.id));\n\n  // --- FIX: Count Total Overlap FIRST ---\n  let totalOverlapCount = 0;\n  substratePoints_dens.forEach(p =&gt; {\n    if (idsA.has(p.id) && idsB.has(p.id)) totalOverlapCount++;\n  });\n  \n  // Calculate the probability once\n  const finalOverlapProb = totalOverlapCount / sim_config_dens.N;\n\n  // Now create the array for the plot\n  const finalPoints = substratePoints_dens.map(p =&gt; {\n    const inA = idsA.has(p.id);\n    const inB = idsB.has(p.id);\n    \n    let status = \"Ω\";\n    if (inA && inB) status = \"A & B\";\n    else if (inA) status = \"A Only\";\n    else if (inB) status = \"B Only\";\n    \n    return { ...p, inA, inB, status };\n  });\n\n  // Attach the calculated probability to the array itself so the Plot can read it\n  finalPoints.overlapProb = finalOverlapProb;\n  \n  return finalPoints;\n}\n\n// 4. THE PLOT (New Density Style)\nPlot.plot({\n  width: 500,\n  height: 500,\n  x: {axis: null, domain: [0,1]},\n  y: {axis: null, domain: [0,1]},\n  \n  marks: [\n    Plot.frame({stroke: \"#ccc\"}),\n\n    // --- DENSITY LAYER A (Blue) ---\n    Plot.density(classifiedPoints_dens, {\n      x: \"x\", y: \"y\",\n      fill: \"#6ecae1\",\n      fillOpacity: 0.3, \n      thresholds: [0.1], \n      bandwidth: 15,      \n      // Points in A are +1, Points ONLY in B are -1 (Repulsive)\n      weight: d =&gt; d.inA ? 1 : (d.inB ? -1 : 0)\n    }),\n\n    // --- DENSITY LAYER B (Orange) ---\n    Plot.density(classifiedPoints_dens, {\n      x: \"x\", y: \"y\",\n      fill: \"#f7941d\",\n      fillOpacity: 0.3,\n      thresholds: [0.1],\n      bandwidth: 15,\n      // Points in B are +1, Points ONLY in A are -1\n      weight: d =&gt; d.inB ? 1 : (d.inA ? -1 : 0)\n    }),\n    \n    Plot.text([sim_config_dens.centerA], {\n      x: \"x\", y: \"y\", text: [`P(A) = ${prob_a_ov.toFixed(2)}`], \n      fill: \"black\", fontWeight: \"bold\", fontSize: 16, stroke: \"white\", strokeWidth: 3\n    }),\n    Plot.text([sim_config_dens.centerB], {\n      x: \"x\", y: \"y\", text: [`P(B) = ${prob_b_ov.toFixed(2)}`], \n      fill: \"black\", fontWeight: \"bold\", fontSize: 16, stroke: \"white\", strokeWidth: 3\n    }),\n\n    Plot.text([\"Ω\"], {frameAnchor: \"top-right\", dx: -10, dy: 10, fill: \"#999\", fontSize: 20, fontWeight: \"bold\"}),\n    \n    // --- FIX: Read the attached property from the data array ---\n    Plot.text([0.5], {\n       frameAnchor: \"bottom\", dy: -10,\n       text: [`P(A ⋂ B) = ${classifiedPoints_dens.overlapProb.toFixed(3)}`],\n       fontSize: 16, fontWeight: \"bold\", fill: \"#5D4037\", stroke: \"white\", strokeWidth: 4\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.3.10 Phân phối xác suất (probability distribution)\nLà một hàm số (function) thể hiện xác suất của mọi tập hợp con của không gian mẫu \\(\\Omega\\).\nPhân phối xác suất bắt buộc phải thỏa 3 điều kiện sau:\n\n\\(\\mathbb{P}(\\Omega) = 1\\)\n\\(0 \\leq \\mathbb{P}(A) \\leq 1\\) với mọi biến cố \\(A\\)\nNếu các biến số \\(A_1\\), \\(A_2\\), …, \\(A_n\\) xung khắc, thì:\n\n\\[\\mathbb{P}(A_1 \\cup A_2 \\cup \\cdots \\cup A_n) = \\mathbb{P}(A_1) + \\mathbb{P}(A_2) + \\cdots + \\mathbb{P}(A_n)\\]\n\n\n1.3.11 Biến ngẫu nhiên (random variable)\nmột biến thực có thể nhận các giá trị khác nhau với các xác suất khác nhau\nLà một hàm số (function) gán một số thực cho mỗi điểm mẫu trong không gian mẫu của một phép thử ngẫu nhiên.\n\\[X: \\Omega \\rightarrow \\mathbb{R}\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Xác suất</span>"
    ]
  },
  {
    "objectID": "bayes.html",
    "href": "bayes.html",
    "title": "2  Bayesian",
    "section": "",
    "text": "2.1 Xác suất có điều kiện\nXác suất có điều kiện thực chất là thu nhỏ không gian mẫu.\nVí dụ, tại một ngôi trường có 3 lớp A, B, C với số lượng học sinh như sau:\nChọn ngẫu nhiên 1 học sinh trong trường.\n1. Xác suất không điều kiện\nTính xác suất học sinh này là Nữ?\nLúc này không gian mẫu là toàn bộ ngôi trường.\n\\[\\mathbb{P}(\\text{Nữ}) = \\frac{\\overbrace{55}^{\\text{Tổng số Nữ toàn trường}}}{\\underbrace{120}_{\\text{Tổng số học sinh toàn trường}}} \\approx 45.8\\%\\]\n2. Xác suất có điều kiện\nBiết rằng học sinh được chọn ở Lớp A. Tính xác suất học sinh này là Nữ?\nThông tin “Học sinh Lớp A” đã làm thu nhỏ không gian mẫu. Không gian mẫu lúc này chỉ là Học sinh lớp A thôi.\n\\[\\mathbb{P}(\\text{Nữ} | \\text{Lớp A}) = \\frac{\\overbrace{10}^{\\text{Số Nữ trong Lớp C}}}{\\underbrace{40}_{\\text{Tổng sĩ số Lớp A}}} = 25.0\\%\\]\nviewof classroom_prob_sharp = (() =&gt; {\n  // --- 1. SETUP ---\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    margin-top: 20px;\n    width: 100%;\n    max-width: 800px;\n    margin-left: auto;\n    margin-right: auto;\n  `;\n\n  // --- 2. DATA ---\n  const CLASSES = {\n    A: { boys: 30, girls: 10, color: \"#ef4444\" }, \n    B: { boys: 20, girls: 20, color: \"#3b82f6\" }, \n    C: { boys: 15, girls: 25, color: \"#10b981\" } \n  };\n  \n  const students = [];\n  Object.keys(CLASSES).forEach(cls =&gt; {\n    const data = CLASSES[cls];\n    for(let i=0; i&lt;data.boys; i++) students.push({ id: `b-${cls}-${i}`, cls: cls, gender: \"Nam\", color: data.color });\n    for(let i=0; i&lt;data.girls; i++) students.push({ id: `g-${cls}-${i}`, cls: cls, gender: \"Nữ\", color: data.color });\n  });\n\n  // --- 3. CONTROLS ---\n  const controlPanel = document.createElement(\"div\");\n  controlPanel.style.cssText = `\n    background: #ffffff;\n    border: 1px solid #e2e8f0;\n    border-radius: 12px;\n    padding: 16px;\n    margin-bottom: 24px;\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n    gap: 12px;\n    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);\n    width: 100%;\n    box-sizing: border-box;\n  `;\n\n  function createSelect(options) {\n    const sel = document.createElement(\"select\");\n    sel.style.cssText = `\n      padding: 8px 12px;\n      border-radius: 8px;\n      border: 1px solid #d1d5db;\n      background-color: #f9fafb;\n      font-size: 14px;\n      font-weight: 600;\n      color: #1e293b;\n      cursor: pointer;\n    `;\n    options.forEach(opt =&gt; {\n      const el = document.createElement(\"option\");\n      el.value = opt.val;\n      el.textContent = opt.label;\n      sel.appendChild(el);\n    });\n    return sel;\n  }\n\n  const targetOpts = [\n    {val: \"Nam\", label: \"Học sinh Nam\"},\n    {val: \"Nữ\", label: \"Học sinh Nữ\"},\n    {val: \"A\", label: \"Học sinh Lớp A\"},\n    {val: \"B\", label: \"Học sinh Lớp B\"},\n    {val: \"C\", label: \"Học sinh Lớp C\"}\n  ];\n\n  const givenOpts = [\n    {val: \"Universe\", label: \"Toàn trường\"},\n    {val: \"A\", label: \"Học sinh Lớp A\"},\n    {val: \"B\", label: \"Học sinh Lớp B\"},\n    {val: \"C\", label: \"Học sinh Lớp C\"},\n    {val: \"Nam\", label: \"Đó là Nam\"},\n    {val: \"Nữ\", label: \"Đó là Nữ\"}\n  ];\n\n  const selTarget = createSelect(targetOpts);\n  const selGiven = createSelect(givenOpts);\n  selTarget.value = \"Nữ\";\n  selGiven.value = \"A\";\n\n  const t1 = document.createElement(\"span\"); t1.textContent = \"Tính xác suất chọn\"; t1.style.color = \"#334155\";\n  const t2 = document.createElement(\"span\"); t2.textContent = \"biết rằng\"; t2.style.color = \"#334155\";\n\n  controlPanel.appendChild(t1);\n  controlPanel.appendChild(selTarget);\n  controlPanel.appendChild(t2);\n  controlPanel.appendChild(selGiven);\n  wrapper.appendChild(controlPanel);\n\n  // --- 4. CANVAS (High Resolution) ---\n  const canvas = document.createElement(\"canvas\");\n  const logicalW = 800;\n  const logicalH = 340; \n  \n  // Set Display Size (CSS)\n  canvas.style.width = `${logicalW}px`;\n  canvas.style.height = `${logicalH}px`;\n  // Responsive Max Width\n  canvas.style.maxWidth = \"100%\";\n  canvas.style.height = \"auto\";\n  \n  // Set Actual Pixel Size (High DPI)\n  const dpr = window.devicePixelRatio || 1;\n  canvas.width = logicalW * dpr;\n  canvas.height = logicalH * dpr;\n  \n  const ctx = canvas.getContext(\"2d\");\n  // Scale drawing operations so we can use logical coordinates\n  ctx.scale(dpr, dpr);\n  wrapper.appendChild(canvas);\n\n  // --- 5. MATH PANEL ---\n  const mathDiv = document.createElement(\"div\");\n  mathDiv.style.cssText = `\n    font-size: 18px;\n    margin-top: 20px; \n    margin-bottom: 10px;\n    text-align: center;\n    line-height: 1.6;\n    width: 100%;\n  `;\n  wrapper.appendChild(mathDiv);\n\n  // --- 6. GEOMETRY PRE-CALCULATION ---\n  const boxW = 180;\n  const boxH = 300; \n  const gap = 24;   \n  const startX = (logicalW - (3 * boxW + 2 * gap)) / 2;\n  const startY = 10;\n\n  const dotCols = 5;\n  const dotDiam = 13;   \n  const dotGap = 13;    \n  const gridWidth = (dotCols * dotDiam) + ((dotCols - 1) * dotGap);\n  const dotRad = dotDiam / 2;\n\n  const posMap = {}; \n  ['A', 'B', 'C'].forEach((cls, i) =&gt; {\n     const clsStudents = students.filter(s =&gt; s.cls === cls);\n     const bx = startX + i * (boxW + gap);\n     const by = startY;\n     const gridStartX = bx + (boxW - gridWidth) / 2 + dotRad;\n     const gridStartY = by + 80; \n     \n     clsStudents.forEach((s, idx) =&gt; {\n        const c = idx % dotCols;\n        const r = Math.floor(idx / dotCols);\n        posMap[s.id] = {\n            x: gridStartX + c * (dotDiam + dotGap),\n            y: gridStartY + r * (dotDiam + dotGap),\n            bx: bx, by: by \n        };\n     });\n  });\n\n  // --- 7. LOGIC ---\n  function check(student, condition) {\n    if (condition === \"Universe\") return true;\n    if (condition === \"A\" || condition === \"B\" || condition === \"C\") return student.cls === condition;\n    if (condition === \"Nam\" || condition === \"Nữ\") return student.gender === condition;\n    return false;\n  }\n\n  function update() {\n    const targetCond = selTarget.value;\n    const givenCond = selGiven.value;\n    const validUniverse = students.filter(s =&gt; check(s, givenCond));\n    const validTarget = validUniverse.filter(s =&gt; check(s, targetCond));\n    const num = validTarget.length;\n    const den = validUniverse.length;\n    const prob = den === 0 ? 0 : ((num / den) * 100).toFixed(1);\n\n    const dict = {\n        \"Nam\": \"Nam\", \"Nữ\": \"Nữ\",\n        \"A\": \"Lớp A\", \"B\": \"Lớp B\", \"C\": \"Lớp C\",\n        \"Universe\": \"Toàn trường\"\n    };\n\n    // Cleaned up text, 18px base size\n    mathDiv.innerHTML = `\n      &lt;div style=\"display:inline-block; padding: 15px 30px; background:#f8fafc; border-radius:12px; border:1px solid #e2e8f0;\"&gt;\n        &lt;div style=\"font-size: 18px; color:#0f172a; line-height: 1.4;\"&gt;\n          P(${dict[targetCond] || targetCond} | ${dict[givenCond] || givenCond}) = \n          &lt;span style=\"color: #be185d; font-weight: bold;\"&gt;${num}&lt;/span&gt; \n          / \n          &lt;span style=\"color: #0f172a; font-weight: bold;\"&gt;${den}&lt;/span&gt; \n          = &lt;b&gt;${prob}%&lt;/b&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `;\n\n    drawScene(givenCond, targetCond, validUniverse, validTarget);\n  }\n\n  function drawScene(given, target, universeSet, targetSet) {\n    ctx.clearRect(0, 0, logicalW, logicalH);\n    \n    // Draw Boxes\n    ['A', 'B', 'C'].forEach((cls, i) =&gt; {\n       const bx = startX + i * (boxW + gap);\n       const by = startY;\n       const boxHasUniverse = universeSet.some(s =&gt; s.cls === cls);\n       \n       if (given === cls) {\n           ctx.fillStyle = \"#eff6ff\"; ctx.strokeStyle = \"#3b82f6\"; ctx.lineWidth = 3;\n           ctx.shadowColor = \"rgba(59, 130, 246, 0.15)\"; ctx.shadowBlur = 15; ctx.shadowOffsetY = 4;\n       } else if (boxHasUniverse) {\n           ctx.fillStyle = \"#ffffff\"; ctx.strokeStyle = \"#cbd5e1\"; ctx.lineWidth = 1.5;\n           ctx.shadowColor = \"rgba(0,0,0,0)\";\n       } else {\n           ctx.fillStyle = \"#f8fafc\"; ctx.strokeStyle = \"#e2e8f0\"; ctx.lineWidth = 1;\n           ctx.shadowColor = \"rgba(0,0,0,0)\";\n       }\n\n       ctx.beginPath();\n       ctx.roundRect(bx, by, boxW, boxH, 16);\n       ctx.fill();\n       ctx.stroke();\n       ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n       // Text\n       ctx.textAlign = \"center\";\n       ctx.fillStyle = boxHasUniverse ? \"#1e293b\" : \"#cbd5e1\";\n       ctx.font = \"bold 20px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\";\n       ctx.fillText(`Lớp ${cls}`, bx + boxW/2, by + 35);\n       \n       const count = CLASSES[cls];\n       ctx.font = \"500 13px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif\";\n       ctx.fillStyle = boxHasUniverse ? \"#64748b\" : \"#e2e8f0\";\n       ctx.fillText(`${count.boys} Nam • ${count.girls} Nữ`, bx + boxW/2, by + 56);\n       \n       if (boxHasUniverse) {\n         ctx.beginPath(); ctx.strokeStyle = \"#f1f5f9\"; ctx.lineWidth = 1;\n         ctx.moveTo(bx + 30, by + 68); ctx.lineTo(bx + boxW - 30, by + 68); ctx.stroke();\n       }\n    });\n\n    // Draw Students\n    students.forEach(s =&gt; {\n        const pos = posMap[s.id];\n        const isUniverse = universeSet.includes(s);\n        const isTarget = targetSet.includes(s);\n\n        let alpha = 0.1;\n        let radius = 6;\n        let color = \"#e5e7eb\"; \n\n        if (isUniverse) {\n            alpha = 0.4;\n            color = s.gender === \"Nam\" ? \"#60a5fa\" : \"#f472b6\"; \n        }\n        \n        if (isTarget) {\n            alpha = 1.0; \n            radius = 7.5;\n            color = s.gender === \"Nam\" ? \"#2563eb\" : \"#db2777\";\n        } else if (!isUniverse) {\n             color = \"#f1f5f9\"; \n        }\n\n        ctx.globalAlpha = alpha;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(pos.x, pos.y, radius, 0, Math.PI*2);\n        ctx.fill();\n\n        if (isTarget) {\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = \"#ffffff\";\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.arc(pos.x, pos.y, radius + 1.5, 0, Math.PI*2);\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.4;\n            ctx.stroke();\n        }\n    });\n    ctx.globalAlpha = 1.0;\n  }\n\n  selTarget.addEventListener(\"change\", update);\n  selGiven.addEventListener(\"change\", update);\n  \n  update();\n\n  return wrapper;\n})();",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#xác-suất-có-điều-kiện",
    "href": "bayes.html#xác-suất-có-điều-kiện",
    "title": "2  Bayesian",
    "section": "",
    "text": "Nam\nNữ\nTổng\n\n\n\n\nLớp A\n30\n10\n40\n\n\nLớp B\n20\n20\n40\n\n\nLớp C\n15\n25\n40\n\n\nTổng\n65\n55\n120",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#ví-dụ",
    "href": "bayes.html#ví-dụ",
    "title": "2  Bayesian",
    "section": "2.2 Ví dụ",
    "text": "2.2 Ví dụ\nBạn đang muốn tìm một đối tượng để hẹn hò nghiêm túc. Bạn có 2 ứng viên mập mờ tiềm năng: A và B. Bạn cần quyết định chọn ai trong 2 người để thực sự nghiêm túc.\nTrước khi đi hẹn hò, bạn đã có sẵn một thiên kiến ban đầu. Có thể bạn hơi nghiêng về A vì cả hai có nhiều sở thích chung hơn, hoặc có thể bạn hoàn toàn trung lập.\n\nHãy hình dung một hình vuông lớn đại diện cho 100% niềm tin của bạn\nHình vuông này được chia làm 2 phần, bên trái dành cho A bên phải dành cho B\nChiều rộng của mỗi ô là thiên kiến ban đầu, trong thống kê Bayesian gọi là Xác suất tiên nghiệm (Prior) của bạn đối với mỗi người\n\nBạn quyết định đi date với từng người để thu thập dữ liệu thực tế. Sau khi đi date, bạn chấm điểm buổi date đó.\n\nPhần được tô màu là điểm buổi date của từng người, trong thống kê Bayesian gọi là Hàm khả năng (Likelihood)\n\nSau khi đã đi date với từng người, bạn muốn tính xác suất mình nên chọn A \\(\\mathbb{P}(A|Date)\\)\n\nTư duy Bayes: Chúng ta so sánh Diện tích tô màu của A so với B. Đây là Xác suất hậu nghiệm (Posterior).\n\nBiểu đồ này được tạo theo phương pháp trong video Bayes theorem, the geometry of changing beliefs của kênh 3Blue1Brown.\n\nviewof prior = Inputs.range([0, 1], {\n  label: \"Prior A\", \n  value: 0.5, \n  step: 0.05\n})\n\nviewof like_alex = Inputs.range([0, 1], {\n  label: \"Likelihood A\", \n  value: 0.8, \n  step: 0.05\n})\n\nviewof like_ben = Inputs.range([0, 1], {\n  label: \"Likelihood B\", \n  value: 0.15, \n  step: 0.05\n})\n\n// 2. THE CALCULATIONS\nrect_data = [\n  // --- COLUMN 1: ALEX (Left Side) ---\n  {\n    label: \"Thích A\",\n    x1: 0, x2: prior, y1: 0, y2: like_alex,\n    color: \"#6ecae1\" \n  },\n  {\n    label: \"Không thích A\",\n    x1: 0, x2: prior, y1: like_alex, y2: 1,\n    color: \"#1a1a1a\" \n  },\n  // --- COLUMN 2: BEN (Right Side) ---\n  {\n    label: \"Thích B\",\n    x1: prior, x2: 1, y1: 0, y2: like_ben,\n    color: \"#2f7e9b\" \n  },\n  {\n    label: \"Không thích B\",\n    x1: prior, x2: 1, y1: like_ben, y2: 1,\n    color: \"#0f0f0f\" \n  }\n]\n\nPlot.plot({\n  width: 550, height: 450,\n  marginTop: 50,\n  marginLeft: 60,\n  marginRight: 60,\n  marginBottom: 20,\n\n  style: {\n    background: \"black\",\n    color: \"white\",\n    fontSize: \"16px\" \n  },\n  \n  x: { axis: null, domain: [0, 1] },\n  y: { axis: null, domain: [0, 1] },\n\n  marks: [\n    // --- PART 1: THE ANNOTATIONS ---\n    // Fix: Use [1] as dummy data, and arrow functions `() =&gt;` for text strings.\n\n    // A. TOP ANNOTATION: Prior P(H)\n    Plot.ruleY([1], { \n      y: 1.03,           \n      x1: 0, x2: prior,  \n      stroke: \"#000\", strokeWidth: 2,\n      clip: false\n    }),\n    Plot.text([1], {\n      x: prior / 2,      \n      y: 1.03, dy: -10,\n      text: () =&gt; `P(A) = ${prior.toFixed(2)}`, // &lt;--- Arrow function required\n      fill: \"#000\", fontWeight: \"bold\", fontSize: 16,\n      clip: false\n    }),\n\n    // B. LEFT ANNOTATION: P(E|H)\n    Plot.ruleX([1], {\n      x: -0.03,          \n      y1: 0, y2: like_alex, \n      stroke: \"#6ecae1\", strokeWidth: 2,\n      clip: false\n    }),\n    Plot.text([1], {\n      x: -0.03,          \n      y: like_alex / 2, \n      dx: -15, // Push slightly left away from the line\n      rotate: -90, // &lt;--- Rotates text vertically\n      text: () =&gt; `P(Date|A) = ${like_alex.toFixed(2)}`, // Removed \\n for cleaner vertical look\n      fill: \"#6ecae1\", \n      textAnchor: \"middle\", // Centers text on the bar height\n      fontWeight: \"bold\", fontSize: 16, clip: false\n    }),\n\n    // C. RIGHT ANNOTATION: P(E|¬H)\n    Plot.ruleX([1], {\n      x: 1.03,           \n      y1: 0, y2: like_ben, \n      stroke: \"#2f7e9b\", strokeWidth: 2, clip: false\n    }),\n    Plot.text([1], {\n      x: 1.03,           \n      y: like_ben / 2, \n      dx: 15, // Push slightly right away from the line\n      rotate: -90, // &lt;--- Rotates text vertically\n      text: () =&gt; `P(Date|B) = ${like_ben.toFixed(2)}`, \n      fill: \"#2f7e9b\", \n      textAnchor: \"middle\", \n      fontWeight: \"bold\", fontSize: 16, clip: false\n    }),\n\n    // --- PART 2: THE MOSAIC ---\n    Plot.rect(rect_data, {\n      x1: \"x1\", x2: \"x2\", y1: \"y1\", y2: \"y2\", \n      fill: \"color\", stroke: \"white\", strokeWidth: 1,\n      tip: {\n        fill: \"#222\", stroke: \"white\",\n        maxRadius: 100,\n        title: \"label\",\n        channels: {\n          \"Diện tích\": d =&gt; ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)\n        },\n        format: {\n          \"Diện tích\": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false\n        }\n      }\n    }),\n    \n    // Labels inside boxes\n    Plot.text(rect_data, {\n      x: d =&gt; (d.x1 + d.x2) / 2, \n      y: d =&gt; (d.y1 + d.y2) / 2, \n      text: d =&gt; (d.y2 - d.y1) &gt; 0.1 && (d.x2 - d.x1) &gt; 0.1 ? d.label : \"\", \n      fill: \"white\", fontWeight: \"bold\", pointerEvents: \"none\" \n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narea_alex = prior * like_alex\narea_ben  = (1 - prior) * like_ben\ntotal_area = area_alex + area_ben\nposterior_alex = area_alex / total_area\n\nhtml`\n  &lt;div style=\"display: flex; align-items: center; flex-wrap: wrap;\"&gt;\n    &lt;div style=\"font-weight: bold; margin-right: 5px;\"&gt;\n      P(A | Date) = \n    &lt;/div&gt;\n\n    &lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 5px;\"&gt;\n      \n      &lt;div style=\"border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;\"&gt;\n        &lt;span style=\"color: #6ecae1;\"&gt;${area_alex.toFixed(3)}&lt;/span&gt;\n      &lt;/div&gt;\n      \n      &lt;div style=\"padding-top: 5px; text-align: center;\"&gt;\n        &lt;span style=\"color: #6ecae1;\"&gt;${area_alex.toFixed(3)}&lt;/span&gt; + \n        &lt;span style=\"color: #2f7e9b;\"&gt;${area_ben.toFixed(3)}&lt;/span&gt;\n      &lt;/div&gt;\n      \n    &lt;/div&gt;\n\n    &lt;div style=\"font-weight: bold; color: #6ecae1; margin-left: 5px;\"&gt;\n      = ${(posterior_alex * 100).toFixed(1)}%\n    &lt;/div&gt;\n  &lt;/div&gt;\n`",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "bayes.html#ứng-dụng",
    "href": "bayes.html#ứng-dụng",
    "title": "2  Bayesian",
    "section": "2.3 Ứng dụng",
    "text": "2.3 Ứng dụng\nGiả sử một bệnh nhân nhận kết quả xét nghiệm dương tính với một căn bệnh. Các thông số của xét nghiệm như sau:\n\nĐộ nhạy (Sensitivity): 95%\nĐộ đặc hiệu (Specificity): 90%\nTỉ lệ hiện mắc: Căn bệnh này chiếm 10% dân số\n\nXác suất thực sự người đó bị bệnh khi cầm kết quả dương tính \\(\\mathbb{P}(B|D)\\) là bao nhiêu?\nCách khác để đặt câu hỏi này là: Trong số những người cầm tờ giấy xét nghiệm Dương tính, có bao nhiêu phần trăm là Dương tính thật? Để trả lời, ta cần tìm Tổng diện tích Dương tính, rồi lấy Diện tích Dương tính thật chia cho tổng số đó.\nChúng ta sẽ áp dụng phương pháp “Hình vuông niềm tin” để giải quyết:\n\nHãy hình dung một hình vuông lớn đại diện cho 100% dân số\nHình vuông này được chia làm 2 phần, bên trái là tỉ lệ người bệnh trong dân số, bên phải là tỉ lệ người không bệnh\nTrong cột người bệnh, độ nhạy là 95%, tô màu 95% chiều cao của cột này, đây là phần dương tính thật, diện tích là \\(0.10 \\times 0.95 = 0.095\\)\nTrong cột người không bệnh, độ đặc hiệu là 90%, tô màu 10% chiều cao của cột này, đây là phần dương tính giả, diện tích là \\(0.90 \\times 0.10 = 0.09\\)\n\nBây giờ, hãy nhìn vào toàn bộ phần được tô màu trên hình vuông.\n\nTổng diện tích màu (tổng dương tính) là \\(0.095 \\text{ (Thật)} + 0.09 \\text{ (Giả)} = 0.185\\)\nPhần bị chiếm bởi dương tính thật chính là xác suất thực sự mắc bệnh khi có kết quả dương tính\n\n\nviewof prev = Inputs.range([0, 1], {\n  label: \"Tỉ lệ bệnh\", \n  value: 0.1, \n  step: 0.01\n})\n\nviewof sens = Inputs.range([0, 1], {\n  label: \"Độ nhạy\", \n  value: 0.95, \n  step: 0.01\n})\n\nviewof spec = Inputs.range([0, 1], {\n  label: \"Độ đặc hiệu\", \n  value: 0.9, \n  step: 0.01\n})\n\n// 2. THE CALCULATIONS (Reactive Data)\n// This array automatically updates whenever the sliders above move.\n// We define the 4 quadrants of the mosaic.\n\nrect_data2 = [\n  // --- COLUMN 1: ALEX (Left Side) ---\n  // The Width is determined by the 'prior'\n  \n  // 1. The \"Evidence\" Box (The bottom colored part)\n  {\n    label: \"Dương thật\",\n    x1: 0, \n    x2: prev, \n    y1: 0, \n    y2: sens, \n    color: \"#6ecae1\" // Light Blue (Strong Evidence)\n  },\n  \n  // 2. The \"Void\" Box (The top dark part)\n  {\n    label: \"Âm giả\",\n    x1: 0, \n    x2: prev, \n    y1: sens, \n    y2: 1, \n    color: \"#1a1a1a\" // Dark Grey\n  },\n\n  // --- COLUMN 2: BEN (Right Side) ---\n  // The Width starts where Alex ends ('prior') and goes to 1\n  \n  // 3. The \"Evidence\" Box (The bottom colored part)\n  {\n    label: \"Dương giả\",\n    x1: prev, \n    x2: 1, \n    y1: 0, \n    y2: 1 - spec, \n    color: \"#2f7e9b\" // Teal (Competing Evidence)\n  },\n  \n  // 4. The \"Void\" Box (The top dark part)\n  {\n    label: \"Âm thật\",\n    x1: prev, \n    x2: 1, \n    y1: 1 - spec, \n    y2: 1, \n    color: \"#0f0f0f\" // Black\n  }\n]\n\nPlot.plot({\n  width: 550, height: 450,\n  marginTop: 50,\n  marginLeft: 60,\n  marginRight: 60,\n  marginBottom: 20,\n\n  style: {\n    background: \"black\",\n    color: \"white\",\n    fontSize: \"16px\" \n  },\n  \n  x: { axis: null, domain: [0, 1] },\n  y: { axis: null, domain: [0, 1] },\n\n  marks: [\n    // --- PART 1: THE ANNOTATIONS ---\n    // Fix: Use [1] as dummy data, and arrow functions `() =&gt;` for text strings.\n\n    // A. TOP ANNOTATION: Prior P(H)\n    Plot.ruleY([1], { \n      y: 1.03,           \n      x1: 0, x2: prev,  \n      stroke: \"#000\", strokeWidth: 2,\n      clip: false\n    }),\n    Plot.text([1], {\n      x: prev / 2,      \n      y: 1.03, dy: -10,\n      text: () =&gt; `Tỉ lệ bệnh = ${prev.toFixed(2)}`, // &lt;--- Arrow function required\n      fill: \"#000\", fontWeight: \"bold\", fontSize: 16,\n      clip: false\n    }),\n\n    // B. LEFT ANNOTATION: P(E|H)\n    Plot.ruleX([1], {\n      x: -0.03,          \n      y1: 0, y2: sens, \n      stroke: \"#6ecae1\", strokeWidth: 2,\n      clip: false\n    }),\n    Plot.text([1], {\n      x: -0.03,          \n      y: sens / 2, \n      dx: -15, // Push slightly left away from the line\n      rotate: -90, // &lt;--- Rotates text vertically\n      text: () =&gt; `Độ nhạy = ${sens.toFixed(2)}`, // Removed \\n for cleaner vertical look\n      fill: \"#6ecae1\", \n      textAnchor: \"middle\", // Centers text on the bar height\n      fontWeight: \"bold\", fontSize: 16, clip: false\n    }),\n\n    // C. RIGHT ANNOTATION: P(E|¬H)\n    Plot.ruleX([1], {\n      x: 1.03,           \n      y1: 1 - spec, y2: 1, \n      stroke: \"#000\", strokeWidth: 2, clip: false\n    }),\n    Plot.text([1], {\n      x: 1.03,           \n      y: 1 - spec / 2, \n      dx: 15, // Push slightly right away from the line\n      rotate: -90, // &lt;--- Rotates text vertically\n      text: () =&gt; `Độ đặc hiệu = ${spec.toFixed(2)}`, \n      fill: \"#000\", \n      textAnchor: \"middle\", \n      fontWeight: \"bold\", fontSize: 16, clip: false\n    }),\n\n    // --- PART 2: THE MOSAIC ---\n    Plot.rect(rect_data2, {\n      x1: \"x1\", x2: \"x2\", y1: \"y1\", y2: \"y2\", \n      fill: \"color\", stroke: \"white\", strokeWidth: 1,\n      tip: {\n        fill: \"#222\", stroke: \"white\",\n        maxRadius: 100,\n        title: \"label\",\n        channels: {\n          \"Diện tích\": d =&gt; ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)\n        },\n        format: {\n          \"Diện tích\": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false\n        }\n      }\n    }),\n    \n    // Labels inside boxes\n    Plot.text(rect_data2, {\n      x: d =&gt; (d.x1 + d.x2) / 2, \n      y: d =&gt; (d.y1 + d.y2) / 2, \n      text: d =&gt; (d.y2 - d.y1) &gt; 0.1 && (d.x2 - d.x1) &gt; 0.1 ? d.label : \"\", \n      fill: \"white\", fontWeight: \"bold\", pointerEvents: \"none\" \n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narea_tpr = prev * sens\narea_fpr  = (1 - prev) * (1 - spec)\ntotal_area_risk = area_tpr + area_fpr\nposterior_risk = area_tpr / total_area_risk\n\nhtml`\n  &lt;div style=\"display: flex; align-items: center; flex-wrap: wrap;\"&gt;\n    &lt;div style=\"font-weight: bold; margin-right: 5px;\"&gt;\n      P(B | D) = \n    &lt;/div&gt;\n\n    &lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 5px;\"&gt;\n      \n      &lt;div style=\"border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;\"&gt;\n        &lt;span style=\"color: #6ecae1;\"&gt;${area_tpr.toFixed(3)}&lt;/span&gt;\n      &lt;/div&gt;\n      \n      &lt;div style=\"padding-top: 5px; text-align: center;\"&gt;\n        &lt;span style=\"color: #6ecae1;\"&gt;${area_tpr.toFixed(3)}&lt;/span&gt; + \n        &lt;span style=\"color: #2f7e9b;\"&gt;${area_fpr.toFixed(3)}&lt;/span&gt;\n      &lt;/div&gt;\n      \n    &lt;/div&gt;\n\n    &lt;div style=\"font-weight: bold; color: #6ecae1; margin-left: 5px;\"&gt;\n      = ${(posterior_risk * 100).toFixed(1)}%\n    &lt;/div&gt;\n  &lt;/div&gt;\n`",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayesian</span>"
    ]
  },
  {
    "objectID": "distr-shape.html",
    "href": "distr-shape.html",
    "title": "3  Hình dạng phân phối",
    "section": "",
    "text": "3.1 Moments\nXác suất của mỗi giá trị trong một phân phối được xác định bằng hàm mật độ xác suất (với biến liên tục) hoặc hàm khối lượng xác suất (với biến rời rạc).\nHình dạng của phân phối là hình dạng của các hàm số này, được xác định bằng những giá trị gọi là mô-men (moment) của hàm. Thuật ngữ này được mượn từ Vật lý: mô-men (hay mô-men lực) còn gọi là lực xoắn, là lực làm quay một vật thể quanh một điểm tựa. Tưởng tượng một cái mỏ lết quay quanh một con ốc.\nTrong thống kê, moment đo lường vị trí của phân phối so với một điểm mốc. Đối với một biến ngẫu nhiên \\(X\\), moment cấp \\(n\\) quanh điểm \\(a\\) (the \\(n\\)-th moment about \\(a\\)) là:\n\\[E[(X - a)^n]\\]\nCó 2 loại moment:\nCấp của moment có thể từ 0 đến \\(\\infty\\). Nếu biết hết toàn bộ các moment sẽ có thể vẽ lại chính xác hình dạng của đồ thị phân phối đó. Chúng ta thường quan tâm tới 4 loại moment sau:\n*Độ lệch và Độ nhọn thường được chuẩn hóa (standardised) bằng cách chia cho độ lệch chuẩn \\(\\sigma\\), ý nghĩa là gấp bao nhiêu lần độ lệch chuẩn.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hình dạng phân phối</span>"
    ]
  },
  {
    "objectID": "distr-shape.html#moments",
    "href": "distr-shape.html#moments",
    "title": "3  Hình dạng phân phối",
    "section": "",
    "text": "Moment gốc (raw moment, xoay quanh điểm 0): khi \\(a = 0\\), moment là \\(E[X^n]\\).\nMoment tập trung (central moment, xoay quanh giá trị trung bình): khi \\(a = E[X]\\), moment là \\(E[(X - E[X])^n]\\).\n\n\n\n\n\n\n\n\n\n\n\nLoại moment\nKí hiệu\nTên thường gọi\nÝ nghĩa\n\n\n\n\nGốc cấp 1\n\\(E[X]\\)\nKỳ vọng (Mean)\nVị trí (tâm của phân phối)\n\n\nTập trung cấp 2\n\\(E[(X - E[X])^2]\\)\nPhương sai (Variance)\nĐộ phân tán (dữ liệu biến động thế nào)\n\n\nTập trung cấp 3\n\\(E[(X - E[X])^3]\\)\nĐộ lệch (Skewness)*\nTính bất đối xứng (bên nào có đuôi dài hơn)\n\n\nTập trung cấp 4\n\\(E[(X - E[X])^4]\\)\nĐộ nhọn (Kurtosis)*\nĐộ dày của đuôi\n\n\n\n\n\n\n3.1.1 Moment gốc cấp 1\nCho biết vị trí trọng tâm của phân phối nằm ở đâu so với điểm 0.\n\\[E[X] = \\frac{\\sum^N_{i = 1}x_i}{N} = \\sum^N_{i = 1}x_i \\mathbb{P}(x_i)\\]\n\n\n3.1.2 Moment tập trung cấp 2\nCho biết khoảng cách của từng giá trị trong phân phối so với giá trị trung bình. Phép bình phương giúp ngăn chặn các độ lệch âm và dương triệt tiêu lẫn nhau.\n\\[E[(X - E[X])^2] = E[X^2] - (E[X])^2\\]\n\n\n3.1.3 Moment tập trung cấp 3\nThường được gọi là Độ lệch (Skewness). Nó phản ánh sự không đối xứng.\n\\[E\\left[\\left(\\frac{X - E[X]}{\\sigma}\\right)^3\\right]\\]\nLũy thừa bậc 3 giữ nguyên dấu (số âm mũ 3 vẫn là âm)\n\n\n3.1.4 Moment tập trung cấp 4\nThường được gọi là Độ nhọn (Kurtosis). Tên gọi này bắt nguồn từ tiếng Hy Lạp: κυρτός - kyrtos, nghĩa là “cong, vòm”.\n\\[E\\left[\\left(\\frac{X - E[X]}{\\sigma}\\right)^4\\right]\\]\nLũy thừa bậc 4 làm cho những giá trị nhỏ (gần trung bình) trở nên siêu nhỏ, và những giá trị lớn (xa trung bình - outliers) trở nên lớn hơn nhiều lần. Moment này càng lớn thì đuôi của phân phối càng dày, nghĩa là xác suất xảy ra các sự kiện cực đoan càng lớn.\nLeptokurtic (tiền tố lepto- nghĩa là nhỏ, mảnh khảnh): độ nhọn &gt; 3.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ lubridate 1.9.4     ✔ tibble    3.3.0\n✔ purrr     1.2.0     ✔ tidyr     1.3.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks plotly::filter(), stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(patchwork) # Great for combining plots\n\n# --- DATA GENERATION ---\n# We create a sequence of X values\nx_seq &lt;- seq(-6, 6, length.out = 2000)\n\n# Create a data frame with three different densities\ndf_kurtosis &lt;- data.frame(x = x_seq) |&gt;\n  mutate(\n    # Reference: Standard Normal (Mesokurtic)\n    Normal = dnorm(x, mean = 0, sd = 1),\n\n    # High Kurtosis (Leptokurtic): Using a t-distribution with low df\n    # t-dist has heavier tails than normal.\n    High_Kurtosis = dt(x, df = 3),\n\n    # Low Kurtosis (Platykurtic): Using a bounded distribution approach\n    # A uniform distribution is the extreme version of low kurtosis.\n    # To make it look comparable, we use a wider normal and truncate it,\n    # or simply use a uniform density scaled to match roughly.\n    # A simpler visual proxy for platykurtic is a low-variance uniform:\n    Low_Kurtosis = dunif(x, min = -sqrt(3), max = sqrt(3))\n  ) |&gt;\n  # Reshape for ggplot\n  pivot_longer(cols = -x, names_to = \"Type\", values_to = \"Density\") |&gt;\n  mutate(Type = factor(Type, levels = c(\"High_Kurtosis\", \"Normal\", \"Low_Kurtosis\")))\n\n# --- PLOT 1: THE BIG PICTURE ---\np1 &lt;- ggplot(df_kurtosis, aes(x = x, y = Density, color = Type, size = Type)) +\n  geom_line() +\n  scale_color_manual(values = c(\"red\", \"black\", \"blue\")) +\n  scale_size_manual(values = c(1.2, 0.8, 1.2)) +\n  theme_minimal() +\n  labs(title = \"1. The Big Picture (Peak vs Shoulders)\",\n       subtitle = \"Notice the red peak is highest, but its 'shoulders' are lower than normal.\",\n       y = \"Probability Density\") +\n  theme(legend.position = \"bottom\") +\n  coord_cartesian(xlim = c(-5, 5), ylim = c(0, 0.45))\n\n\n# --- PLOT 2: THE TAIL ZOOM ---\n# We use the exact same data, just zoom the coordinates\np2 &lt;- ggplot(df_kurtosis, aes(x = x, y = Density, color = Type, size = Type)) +\n  geom_line() +\n  scale_color_manual(values = c(\"red\", \"black\", \"blue\")) +\n  scale_size_manual(values = c(1.5, 0.8, 1.5)) + # Thicker lines for emphasis\n  theme_minimal() +\n  # IMPORTANT: The zoom focus areas\n  coord_cartesian(xlim = c(2.5, 6), ylim = c(0, 0.025)) +\n  labs(title = \"2. The Tail Zoom (Where outliers live)\",\n       subtitle = \"Crucial: The red line is now HIGHER than the others.\",\n       y = \"\", x = \"X (Extreme Values)\") +\n  theme(legend.position = \"none\",\n        axis.text.y = element_blank(),\n        panel.grid.minor = element_blank())\n\n# --- COMBINE WITH PATCHWORK ---\nfinal_plot &lt;- p1 + p2 + plot_layout(widths = c(2, 1))\n\nprint(final_plot)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nEstimate\nEstimand\nEstimator",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hình dạng phân phối</span>"
    ]
  },
  {
    "objectID": "distr-d.html",
    "href": "distr-d.html",
    "title": "4  Phân phối rời rạc",
    "section": "",
    "text": "4.1 Phép thử Bernoulli (Bernoulli trial, hay binomial trial)\nLà một lần thử nghiệm duy nhất, không gian mẫu chỉ có đúng 2 kết quả: Thành công (Success) hoặc Thất bại (Failure)\nVí dụ: tung đồng xu (mặt sấp, mặt ngửa), xét nghiệm một ca nghi ngờ (dương tính, âm tính)\nKhi ta thực hiện phép thử Bernoulli nhiều lần liên tiếp (ví dụ: tung một đồng xu nhiều lần, dùng một loại xét nghiệm để test nhiều người), ta đang thực hiện 1 chuỗi Bernoulli (Bernoulli process). Chuỗi Bernoulli chuẩn cần thỏa 2 điều kiện:\nHầu hết các phân phối rời rạc đều xuất phát từ chuỗi Bernoulli với các mục tiêu khác nhau.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối rời rạc</span>"
    ]
  },
  {
    "objectID": "distr-d.html#phép-thử-bernoulli-bernoulli-trial-hay-binomial-trial",
    "href": "distr-d.html#phép-thử-bernoulli-bernoulli-trial-hay-binomial-trial",
    "title": "4  Phân phối rời rạc",
    "section": "",
    "text": "Độc lập (Independent): Kết quả của lần thử này không ảnh hưởng đến lần thử khác.\nXác suất không đổi: Xác suất thành công (\\(p\\)) phải giống hệt nhau ở mọi lần thử.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối rời rạc</span>"
    ]
  },
  {
    "objectID": "distr-d.html#đếm-số-lần-thành-công",
    "href": "distr-d.html#đếm-số-lần-thành-công",
    "title": "4  Phân phối rời rạc",
    "section": "4.2 Đếm số lần thành công",
    "text": "4.2 Đếm số lần thành công\nChúng ta quyết định trước sẽ bỏ ra bao nhiêu công sức (\\(n\\) lần thử), và đếm xem thu được bao nhiêu phần thưởng (\\(k\\) thành công).\n\n4.2.1 Phân phối Nhị thức (Binomial distribution)\nĐếm số lần thành công (\\(k\\)) trong một số lượng cố định các phép thử Bernoulli độc lập (\\(n\\)).\nXác suất để đạt được đúng \\(k\\) lần thành công là:\n\\[\\mathbb{P}(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}\\]\nVới:\n\n\\(n\\): Tổng số lần thực hiện phép thử\n\\(p\\): Xác suất thành công của mỗi lần thử (không đổi)\n\n\n\n\n\n\n\nNoteGiải thích\n\n\n\n\\[\\underbrace{\\binom{n}{k}}_{\\text{Số cách chọn}} \\cdot \\underbrace{p^k}_{k \\text{ lần thành công}} \\cdot \\underbrace{(1-p)^{n-k}}_{n-k \\text{ lần thất bại}}\\]\n\n\n\n4.2.1.1 Ví dụ\nTung 1 đồng xu 10 lần, khả năng đếm được 1, 2, 3… mặt ngửa là bao nhiêu?\n\nTổng số lần thực hiện phép thử: \\(n = 10\\)\nXác suất ra mặt ngửa mỗi lần: \\(p = 0.5\\)\n\n\nviewof coin_sim_manual = (() =&gt; {\n  // --- 1. SETUP DOM & STYLES ---\n  const container = document.createElement(\"div\");\n  // Rigid container size: 400px width, 340px height (40px controls + 300px canvas)\n  container.style.cssText = `\n    width: 400px;\n    height: 340px; \n    margin: 0 auto;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    border: 1px solid transparent;\n  `;\n\n  // Inject UI HTML directly (Total Control, Zero Shift)\n  container.innerHTML = `\n    &lt;style&gt;\n      .coin-controls-row {\n        width: 100%;\n        height: 40px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 0px;\n      }\n      .coin-btn {\n        padding: 6px 14px;\n        border-radius: 6px;\n        border: 1px solid #d1d5db;\n        background-color: white;\n        color: #374151;\n        font-size: 14px;\n        font-weight: 600;\n        cursor: pointer;\n        line-height: 1.2;\n      }\n      .coin-btn:hover { background-color: #f3f4f6; }\n      \n      .coin-btn-primary {\n        background-color: #3b82f6; \n        color: white; \n        border-color: #2563eb;\n      }\n      .coin-btn-primary:hover { background-color: #2563eb; color: white; }\n      \n      .coin-toggle {\n        display: flex; align-items: center; gap: 6px;\n        font-size: 14px; font-weight: 500; color: #4b5563;\n        cursor: pointer; user-select: none;\n      }\n      .coin-toggle input { width: 16px; height: 16px; accent-color: #10b981; cursor: pointer; }\n      \n      canvas { display: block; } /* Removes ghost margin */\n    &lt;/style&gt;\n\n    &lt;div class=\"coin-controls-row\"&gt;\n      &lt;button id=\"btn-flip\" class=\"coin-btn coin-btn-primary\"&gt;Tung đồng xu&lt;/button&gt;\n      &lt;label class=\"coin-toggle\"&gt;\n        &lt;input type=\"checkbox\" id=\"chk-auto\"&gt;\n        Tự động chạy\n      &lt;/label&gt;\n      &lt;button id=\"btn-reset\" class=\"coin-btn\"&gt;Làm lại&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n\n  // --- 2. CANVAS SETUP ---\n  const width = 400;\n  const height = 300;\n  const canvas = document.createElement(\"canvas\");\n  const dpr = window.devicePixelRatio || 1;\n  \n  canvas.width = width * dpr;\n  canvas.height = height * dpr;\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  \n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n  ctx.scale(dpr, dpr);\n  container.appendChild(canvas);\n\n  // --- 3. STATE & CONSTANTS ---\n  const N = 10;\n  const P = 0.5;\n  \n  // Colors\n  const BG_COLOR=\"#fff\", TEXT_COLOR=\"#2c3e50\";\n  const HEAD_COLOR=\"#f1c40f\", HEAD_BORDER=\"#d4ac0d\";\n  const TAIL_COLOR=\"#bdc3c7\", TAIL_BORDER=\"#95a5a6\";\n  const CHART_BAR=\"#3498db\", CHART_ACTIVE=\"#2980b9\", CHART_THEO=\"rgba(44, 62, 80, 0.1)\";\n\n  // Math Helper\n  function binomial(k, n, p) {\n    function nCr(n, r) {\n        if (r &lt; 0 || r &gt; n) return 0;\n        let res = 1;\n        for(let i=0; i&lt;r; i++) res = res * (n - i) / (i + 1);\n        return res;\n    }\n    return nCr(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  }\n\n  // Simulation State\n  const S = {\n     history: [], \n     counts: {},  \n     totalFlips: 0,\n     currentResult: [], \n     animation: 0, \n     cooldown: 0,\n     isAuto: false\n  };\n  for(let i=0; i&lt;=N; i++) S.counts[i] = 0;\n\n  // --- 4. LOGIC ---\n  function runFlip() {\n     let heads = 0;\n     const res = [];\n     for(let i=0; i&lt;N; i++) {\n        const isHead = Math.random() &lt; P;\n        res.push(isHead ? 1 : 0);\n        if (isHead) heads++;\n     }\n     \n     const coinSize = 28;\n     const gap = 6;\n     const totalW = N * coinSize + (N-1)*gap;\n     const startX = (width - totalW) / 2 + coinSize/2;\n\n     S.currentResult = res.map((val, i) =&gt; ({\n        val: val,\n        x: width/2, \n        y: 50,\n        targetX: startX + i * (coinSize + gap), \n        targetY: 85,\n        r: coinSize / 2,\n        t: 0\n     }));\n\n     S.history.push(heads);\n     S.counts[heads] = (S.counts[heads] || 0) + 1;\n     S.totalFlips++;\n     S.animation = 1;\n     S.cooldown = 0;\n  }\n\n  function reset() {\n     S.history = [];\n     for(let i=0; i&lt;=N; i++) S.counts[i] = 0;\n     S.totalFlips = 0;\n     S.currentResult = [];\n     S.animation = 0;\n  }\n\n  // --- 5. LOOP ---\n  function update() {\n     // Auto Run Logic\n     if (S.isAuto && S.animation === 0) {\n        S.cooldown++;\n        if (S.cooldown &gt; 20) runFlip(); // Speed: ~0.3s\n     }\n\n     // Animation Logic\n     if (S.animation === 1) {\n       let done = true;\n       for (let c of S.currentResult) {\n          if (c.t &lt; 1) {\n             c.t += 0.2; \n             if (c.t &gt; 1) c.t = 1;\n             const ease = 1 - Math.pow(1 - c.t, 3);\n             c.x = width/2 + (c.targetX - width/2) * ease;\n             c.y = c.targetY - Math.sin(c.t * Math.PI) * 20;\n             done = false;\n          }\n       }\n       if (done) S.animation = 0;\n    }\n  }\n\n  function draw() {\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, width, height);\n\n    ctx.save();\n    ctx.font = \"bold 14px -apple-system, BlinkMacSystemFont, sans-serif\";\n    ctx.fontVariantNumeric = \"tabular-nums\";\n    \n    // 1. Text Info\n    // Left: Count\n    ctx.textAlign = \"left\"; ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(`Lần chạy: ${S.totalFlips}`, 20, 30);\n    \n    // Center: Status\n    if (S.isAuto) {\n       ctx.textAlign = \"center\"; ctx.fillStyle = \"#27ae60\";\n       ctx.fillText(\"● Đang chạy...\", 170, 30); // Adjusted center for visual balance\n    }\n    \n    // Right: Result\n    if (S.currentResult.length &gt; 0) {\n       const hCount = S.currentResult.filter(c =&gt; c.val===1).length;\n       ctx.textAlign = \"right\"; ctx.fillStyle = \"#d35400\";\n       ctx.fillText(`Mặt Ngửa: ${hCount} / ${N}`, width - 20, 30);\n    }\n    ctx.restore();\n\n    // 2. Coins\n    for (let c of S.currentResult) {\n       ctx.beginPath();\n       ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);\n       ctx.fillStyle = c.val === 1 ? HEAD_COLOR : TAIL_COLOR;\n       ctx.fill();\n       ctx.lineWidth = 2;\n       ctx.strokeStyle = c.val === 1 ? HEAD_BORDER : TAIL_BORDER;\n       ctx.stroke();\n       ctx.fillStyle = \"white\";\n       ctx.textAlign = \"center\"; ctx.textBaseline = \"middle\";\n       ctx.font = `bold ${c.r}px sans-serif`;\n       ctx.fillText(c.val === 1 ? \"N\" : \"S\", c.x, c.y + 1);\n    }\n\n    // 3. Chart\n    const chartY = 280; \n    const chartH = 140; \n    const chartX = 40;\n    const chartW = width - 60;\n    \n    ctx.beginPath();\n    ctx.strokeStyle = \"#bdc3c7\"; ctx.lineWidth = 1;\n    ctx.moveTo(chartX, chartY); ctx.lineTo(chartX + chartW, chartY); ctx.stroke();\n\n    const barW = chartW / (N + 1);\n    const MAX_PROB = 0.246; \n    const Y_SCALE_MAX = MAX_PROB * 1.2; \n    const activeHeads = S.currentResult.filter(c =&gt; c.val===1).length;\n\n    for (let k = 0; k &lt;= N; k++) {\n       const cx = chartX + k * barW + barW/2;\n       \n       // Theoretical\n       const prob = binomial(k, N, P);\n       const theoH = (prob / Y_SCALE_MAX) * chartH;\n       ctx.fillStyle = CHART_THEO;\n       ctx.fillRect(cx - barW*0.3, chartY - theoH, barW*0.6, theoH);\n       \n       // Actual\n       let observedProb = 0;\n       if (S.totalFlips &gt; 0) observedProb = S.counts[k] / S.totalFlips;\n       let barH = (observedProb / Y_SCALE_MAX) * chartH;\n       if (barH &gt; chartH + 10) barH = chartH + 10;\n\n       const isActive = (S.animation === 0 && k === activeHeads && S.totalFlips &gt; 0);\n       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_BAR;\n       ctx.fillRect(cx - barW*0.3, chartY - barH, barW*0.6, barH);\n       \n       // Labels\n       ctx.save();\n       ctx.fontVariantNumeric = \"tabular-nums\";\n       ctx.fillStyle = TEXT_COLOR;\n       ctx.font = \"10px sans-serif\";\n       ctx.textAlign = \"center\";\n       ctx.fillText(k, cx, chartY + 15);\n       ctx.restore();\n    }\n    \n    // Y-Axis Label\n    ctx.save();\n    ctx.translate(12, chartY - chartH/2);\n    ctx.rotate(-Math.PI/2);\n    ctx.textAlign = \"center\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"#7f8c8d\";\n    ctx.fillText(\"Tần suất\", 0, 0);\n    ctx.restore();\n  }\n\n  // --- 6. BINDINGS ---\n  const btnFlip = container.querySelector(\"#btn-flip\");\n  const btnReset = container.querySelector(\"#btn-reset\");\n  const chkAuto = container.querySelector(\"#chk-auto\");\n\n  btnFlip.onclick = () =&gt; runFlip();\n  btnReset.onclick = () =&gt; reset();\n  chkAuto.onchange = (e) =&gt; { S.isAuto = e.target.checked; };\n\n  let frameId;\n  function tick() {\n    update();\n    draw();\n    frameId = requestAnimationFrame(tick);\n  }\n  tick();\n\n  if (this && this.invalidation) this.invalidation.then(() =&gt; cancelAnimationFrame(frameId));\n\n  return container;\n})();\n\n\n\n\n\n\n\n\n4.2.1.2 Bảng Galton\nBảng Galton (Galton board) là một tấm bảng dựng đứng, được đóng các hàng đinh so le nhau theo hình tam giác. Ta thả những viên bi nhỏ từ đỉnh tháp. Khi một viên bi chạm vào một chiếc đinh, nó sẽ nảy sang trái hoặc sang phải. Sau khi đi hết các hàng đinh, viên bi sẽ rơi vào các ô chứa để hứng bi. Số lượng bi trong các ô chứa này tuân theo phân phối Nhị thức.\n\nviewof galton_sharp = Inputs.form({\n  rows: Inputs.range([8, 20], {value: 10, step: 1, label: \"Số hàng đinh\"}),\n  speed: Inputs.range([0.5, 3], {value: 2, step: 0.1, label: \"Tốc độ\"}),\n  total: Inputs.range([50, 800], {value: 200, step: 10, label: \"Số viên bi\"})\n})\n\nviewof galton_sim_dense = (() =&gt; {\n  // --- 1. CONFIGURATION ---\n  const config = {\n      rows: galton_sharp.rows,\n      speed: galton_sharp.speed,\n      maxBalls: galton_sharp.total\n  };\n\n  // --- 2. SETUP CONTAINER (Centered) ---\n  const outerWrapper = document.createElement(\"div\");\n  outerWrapper.style.cssText = `\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    margin-top: 20px;\n  `;\n\n  const container = document.createElement(\"div\");\n  container.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    width: 380px; \n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n  `;\n  outerWrapper.appendChild(container);\n\n  // --- 3. INJECT UI ---\n  container.innerHTML = `\n    &lt;style&gt;\n      .galton-ctrl-row {\n        width: 100%;\n        display: flex;\n        justify-content: center;\n        gap: 12px;\n        margin-bottom: 10px;\n      }\n      .galton-btn {\n        padding: 6px 16px;\n        border-radius: 6px;\n        border: 1px solid #d1d5db;\n        background-color: white;\n        color: #374151;\n        font-size: 14px;\n        font-weight: 600;\n        cursor: pointer;\n        transition: all 0.1s ease;\n      }\n      .galton-btn:hover { background-color: #f3f4f6; }\n      \n      .galton-btn-primary {\n        background-color: #3b82f6; \n        color: white; \n        border-color: #2563eb;\n      }\n      .galton-btn-primary:hover { background-color: #2563eb; color: white; }\n\n      canvas {\n        border-radius: 4px;\n      }\n    &lt;/style&gt;\n\n    &lt;div class=\"galton-ctrl-row\"&gt;\n      &lt;button id=\"btn-start\" class=\"galton-btn galton-btn-primary\"&gt;Bắt đầu&lt;/button&gt;\n      &lt;button id=\"btn-stop\" class=\"galton-btn\"&gt;Dừng&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n\n  // --- 4. CANVAS SETUP ---\n  // INCREASED HEIGHT from 500 -&gt; 600\n  const logicalWidth = 380;\n  const logicalHeight = 600; \n  const dpr = window.devicePixelRatio || 1;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = logicalWidth * dpr;\n  canvas.height = logicalHeight * dpr;\n  canvas.style.width = `${logicalWidth}px`;\n  canvas.style.height = `${logicalHeight}px`;\n  \n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n  ctx.scale(dpr, dpr);\n  container.appendChild(canvas);\n\n  // --- 5. GEOMETRY & STATE ---\n  const pegSpacing = logicalWidth / (config.rows + 3);\n  const startY = 60;\n  const pegRadius = pegSpacing * 0.12; \n  const ballRadius = pegSpacing * 0.23; \n  const rowHeight = pegSpacing * 0.85;\n\n  // Bin Geometry\n  const floorY = logicalHeight - 10;\n  const binWidth = pegSpacing;\n  const totalBinWidth = (config.rows + 1) * binWidth;\n  const binsStartX = (logicalWidth - totalBinWidth) / 2;\n  const wallsTopY = startY + (config.rows) * rowHeight + 15;\n\n  // DENSE PACKING FACTOR\n  // 70% Overlap means the vertical step is small.\n  // Normal Diameter = 2*r.\n  // We use step = 0.6 * r. This is very dense.\n  const stackStep = ballRadius * 0.6; \n\n  // Pre-calculate Peg Positions\n  const pegGrid = []; \n  for (let r = 0; r &lt; config.rows; r++) {\n    const rowPegs = [];\n    const pegsInThisRow = r + 1;\n    const rowWidth = (pegsInThisRow - 1) * pegSpacing;\n    const rowStartX = (logicalWidth - rowWidth) / 2;\n    for (let p = 0; p &lt; pegsInThisRow; p++) {\n      rowPegs.push({\n        x: rowStartX + p * pegSpacing,\n        y: startY + r * rowHeight\n      });\n    }\n    pegGrid.push(rowPegs);\n  }\n\n  // Simulation State\n  const S = {\n    balls: [],\n    bins: new Array(config.rows + 1).fill(0),\n    spawned: 0,\n    running: false\n  };\n\n  // --- 6. LOGIC ---\n  function createBall() {\n    let currentInd = 0; \n    let path = [];\n    path.push({ x: logicalWidth / 2, y: startY - 20 }); \n\n    for (let r = 0; r &lt; config.rows; r++) {\n       const peg = pegGrid[r][currentInd];\n       path.push({ x: peg.x, y: peg.y - pegRadius - ballRadius });\n       if (Math.random() &gt; 0.5) currentInd++; \n    }\n\n    const binX = binsStartX + currentInd * binWidth + binWidth/2;\n    path.push({ x: binX, y: wallsTopY });\n    path.push({ x: binX, y: floorY, isFloor: true, binIndex: currentInd });\n\n    return {\n      path: path,\n      segment: 0, t: 0, active: true,\n      x: path[0].x, y: path[0].y\n    };\n  }\n\n  function spawn() {\n     if (S.spawned &gt;= config.maxBalls) return;\n     \n     // Check capacity using new DENSE packing logic\n     // Available height = floorY - wallsTopY\n     // Height consumed = count * stackStep\n     const centerBin = Math.floor(config.rows/2);\n     const currentHeight = S.bins[centerBin] * stackStep;\n     \n     if (currentHeight &gt; (floorY - wallsTopY - 20)) return; // -20 buffer\n     \n     S.balls.push(createBall());\n     S.spawned++;\n  }\n\n  function update(dt) {\n    if (S.running) {\n        const spawnChance = 0.25 * config.speed; \n        if (Math.random() &lt; spawnChance) spawn();\n    }\n\n    for (let i = 0; i &lt; S.balls.length; i++) {\n        const b = S.balls[i];\n        if (!b.active) continue;\n        if (!S.running) continue;\n\n        const moveSpeed = 3.0 * config.speed * dt;\n        b.t += moveSpeed;\n\n        if (b.t &gt;= 1) {\n            b.t = 0;\n            b.segment++;\n            if (b.segment &gt;= b.path.length - 1) {\n                b.active = false;\n                const finalPt = b.path[b.path.length - 1];\n                S.bins[finalPt.binIndex]++;\n                continue;\n            }\n        }\n\n        const p0 = b.path[b.segment];\n        const p1 = b.path[b.segment + 1];\n        const t = b.t;\n        const ease = t * t; \n        \n        b.x = p0.x + (p1.x - p0.x) * t;\n        b.y = p0.y + (p1.y - p0.y) * (p1.isFloor ? ease : ease);\n    }\n    \n    if (S.balls.length &gt; config.maxBalls + 50) {\n        S.balls = S.balls.filter(b =&gt; b.active);\n    }\n  }\n\n  // --- 7. DRAW LOOP ---\n  function draw() {\n    // Clear\n    ctx.fillStyle = \"#f8f9fa\";\n    ctx.fillRect(0, 0, logicalWidth, logicalHeight);\n\n    // Pegs\n    ctx.fillStyle = \"#9ca3af\";\n    ctx.beginPath();\n    for (let r = 0; r &lt; pegGrid.length; r++) {\n      for (let p = 0; p &lt; pegGrid[r].length; p++) {\n         const peg = pegGrid[r][p];\n         ctx.moveTo(peg.x + pegRadius, peg.y);\n         ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI*2);\n      }\n    }\n    ctx.fill(); \n\n    // Active Balls\n    ctx.fillStyle = \"#3b82f6\";\n    ctx.beginPath();\n    for (let i = 0; i &lt; S.balls.length; i++) {\n       const b = S.balls[i];\n       if (b.active) {\n         ctx.moveTo(b.x + ballRadius, b.y);\n         ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2);\n       }\n    }\n    ctx.fill(); \n\n    // BINS (Dense Stacking)\n    ctx.fillStyle = \"#3b82f6\";\n    ctx.strokeStyle = \"#1d4ed8\"; // Darker border for definition\n    ctx.lineWidth = 1;\n    \n    for (let i = 0; i &lt; S.bins.length; i++) {\n       const count = S.bins[i];\n       if (count === 0) continue;\n       \n       const cx = binsStartX + i * binWidth + binWidth/2;\n       \n       ctx.beginPath();\n       for (let j = 0; j &lt; count; j++) {\n          // DENSE LOGIC: stackStep = 0.6 * r\n          const cy = floorY - ballRadius - (j * stackStep);\n          \n          if (cy &lt; wallsTopY) break; \n          ctx.moveTo(cx + ballRadius, cy);\n          ctx.arc(cx, cy, ballRadius, 0, Math.PI*2);\n       }\n       ctx.fill();\n       ctx.stroke();\n    }\n\n    // Walls/Floor\n    ctx.strokeStyle = \"#d1d5db\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(binsStartX, floorY);\n    ctx.lineTo(binsStartX + totalBinWidth, floorY);\n    for (let i = 0; i &lt;= config.rows + 1; i++) {\n       const x = binsStartX + i * binWidth;\n       ctx.moveTo(x, wallsTopY);\n       ctx.lineTo(x, floorY);\n    }\n    ctx.stroke();\n\n    // Text\n    ctx.fillStyle = \"#374151\";\n    ctx.font = \"bold 14px sans-serif\";\n    ctx.fillText(`Số bi: ${S.spawned} / ${config.maxBalls}`, 10, 25);\n  }\n\n  // --- 8. RUNTIME ---\n  let lastTime = performance.now();\n  let frameId;\n  \n  function tick(now) {\n    const dt = Math.min((now - lastTime) / 1000, 0.1); \n    lastTime = now;\n    \n    update(dt);\n    draw();\n    frameId = requestAnimationFrame(tick);\n  }\n\n  // Bind Buttons\n  const btnStart = container.querySelector(\"#btn-start\");\n  const btnStop = container.querySelector(\"#btn-stop\");\n\n  btnStart.onclick = () =&gt; {\n     if (!S.running && S.spawned === 0) {\n         S.running = true;\n     } else {\n         S.running = true;\n         if (S.spawned &gt;= config.maxBalls) {\n             S.balls = [];\n             S.bins.fill(0);\n             S.spawned = 0;\n         }\n     }\n  };\n  \n  btnStop.onclick = () =&gt; {\n      S.running = false;\n  };\n\n  tick(performance.now());\n  invalidation.then(() =&gt; cancelAnimationFrame(frameId));\n\n  return outerWrapper;\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTại sao lại là phân phối Nhị thức?\n\nMỗi lần viên bi chạm vào chiếc đinh, có hai trường hợp xảy ra: viên bi sẽ nảy sang trái hoặc sang phải, xác suất nảy sang mỗi bên là \\(p = 0.5\\), giống như tung đồng xu. Đây là một phép thử Bernoulli.\nNếu bảng có 10 hàng đinh, viên bi sẽ thực hiện chuỗi Bernoulli có 10 phép thử liên tiếp.\nCác ô chứa tương ứng với số lần viên bi nảy về bên phải. Để vào ô giữa, viên bi phải nảy sang bên phải 5 lần (và bên trái 5 lần), để vào ô cuối cùng, viên bi phải nảy sang bên phải 10 lần (và bên trái 0 lần).\n\n\n\n4.2.1.3 Hồi quy logistic\n\nglm(formula, data, family = binomial(link = \"logit\"))\nglm(formula, data, family = \"binomial\")\n\nTại sao trong hồi quy logistic lại ghi family = \"binomial\"?\nVí dụ: Hút thuốc lá có làm tăng nguy cơ ung thư phổi không?\n\nBiến độc lập: Số điếu thuốc hút mỗi ngày\nBiến phụ thuộc: Tình trạng ung thư phổi (1 = Có bệnh, 0 = Không bệnh)\n\nKhi xây dựng mô hình, chúng ta xem xét từng cá nhân trong dữ liệu như một phép thử ngẫu nhiên:\n\nVới một người cụ thể (ví dụ: anh A, hút 1 gói/ngày), việc anh ta có bị ung thư hay không giống như việc tung một đồng xu: mặt ngửa (1) là bị ung thư, mặt sấp (0) là không bị ung thư. Nhưng xác suất tung ra mặt ngửa của đồng xu này không phải là 0.5, mà phụ thuộc vào việc anh ta hút bao nhiêu thuốc.\nKhi chúng ta tiến hành nghiên cứu trên \\(n\\) người, đây là 1 chuỗi Bernoulli, vì vậy có thể chọn phân phối Binomial để mô hình nó.\n\nKhai báo family = \"binomial\" nghĩa là: “Biến kết quả (\\(Y\\)) là đếm số lần thành công (hoặc thất bại) từ các phép thử nhị phân, hãy dùng công thức xác suất của phân phối Nhị thức để ước lượng.”\n\n\n4.2.1.4 Xấp xỉ phân phối Chuẩn\nĐịnh lý Moivre-Laplace (một dạng đặc biệt của Định lý Giới hạn Trung tâm): Khi số lượng phép thử \\(n\\) đủ lớn, hình dáng của phân phối Nhị thức sẽ tiệm cận về phân phối Chuẩn.\n\nviewof normal_approx_fixed_axis = (() =&gt; {\n  // --- 1. SETUP CONTAINER ---\n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    margin-top: 20px;\n    width: 100%;\n    min-height: 500px;\n  `;\n\n  // --- 2. INPUT CREATION ---\n  function createInput(id, label, min, max, step, val) {\n    const container = document.createElement(\"div\");\n    container.style.cssText = \"display: flex; flex-direction: column; width: 220px;\";\n    \n    const labelEl = document.createElement(\"label\");\n    labelEl.htmlFor = id;\n    labelEl.style.cssText = \"font-size: 14px; font-weight: 600; color: #374151; margin-bottom: 6px;\";\n    labelEl.innerHTML = `${label} &lt;span style=\"color: #be185d;\"&gt;${val}&lt;/span&gt;`;\n    \n    const input = document.createElement(\"input\");\n    input.type = \"range\";\n    input.id = id;\n    input.min = min;\n    input.max = max;\n    input.step = step;\n    input.value = val;\n    input.style.width = \"100%\";\n    input.style.accentColor = \"#be185d\"; \n    \n    container.appendChild(labelEl);\n    container.appendChild(input);\n    return { container, input, labelEl };\n  }\n\n  const nCtrl = createInput(\"n_val_fx\", \"Số phép thử (n):\", 10, 500, 10, 50);\n  const pCtrl = createInput(\"p_val_fx\", \"Xác suất (p):\", 0.05, 0.95, 0.05, 0.5);\n\n  const controlsDiv = document.createElement(\"div\");\n  controlsDiv.style.cssText = \"display: flex; flex-wrap: wrap; gap: 30px; justify-content: center; margin-bottom: 20px; width: 100%;\";\n  controlsDiv.appendChild(nCtrl.container);\n  controlsDiv.appendChild(pCtrl.container);\n  wrapper.appendChild(controlsDiv);\n\n  // Stats Display\n  const statsDiv = document.createElement(\"div\");\n  statsDiv.style.cssText = \"font-size: 16px; color: #374151; margin-bottom: 10px; font-weight: 500; font-family: monospace;\";\n  wrapper.appendChild(statsDiv);\n  \n  // Plot Container\n  const plotContainer = document.createElement(\"div\");\n  wrapper.appendChild(plotContainer);\n\n  // --- 3. MATH KERNEL ---\n  function logFact(n) {\n    if (n &lt;= 1) return 0;\n    return n * Math.log(n) - n + 0.5 * Math.log(2 * Math.PI * n);\n  }\n\n  function getBinomialProb(k, n, p) {\n    if (k &lt; 0 || k &gt; n) return 0;\n    if (p &lt;= 0) return k === 0 ? 1 : 0;\n    if (p &gt;= 1) return k === n ? 1 : 0;\n    \n    const logP = logFact(n) - logFact(k) - logFact(n - k) + k * Math.log(p) + (n - k) * Math.log(1 - p);\n    return Math.exp(logP);\n  }\n\n  function normalPDF(x, mu, sigma) {\n    if (sigma &lt;= 0) return 0;\n    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));\n  }\n\n  // --- 4. RENDER LOGIC ---\n  function update() {\n    const n = parseFloat(nCtrl.input.value);\n    const p = parseFloat(pCtrl.input.value);\n\n    // Update Text\n    nCtrl.labelEl.querySelector(\"span\").textContent = n;\n    pCtrl.labelEl.querySelector(\"span\").textContent = p.toFixed(2);\n\n    const mu = n * p;\n    const sigma = Math.sqrt(n * p * (1 - p));\n\n    // Stats\n    statsDiv.innerHTML = `&mu; = &lt;b&gt;${mu.toFixed(2)}&lt;/b&gt; &nbsp;|&nbsp; &sigma; = &lt;b&gt;${sigma.toFixed(2)}&lt;/b&gt;`;\n\n    // CALCULATION WINDOW: We still optimize calculation to +/- 4 sigma\n    // to keep performance high, even though visual axis is 0-n.\n    let startK = Math.floor(mu - 4 * sigma);\n    let endK = Math.ceil(mu + 4 * sigma);\n    if (startK &lt; 0) startK = 0;\n    if (endK &gt; n) endK = n;\n\n    // 1. Generate Binomial Data\n    const binomData = [];\n    for (let k = startK; k &lt;= endK; k++) {\n      binomData.push({ \n          k: k, \n          x1: k - 0.5, \n          x2: k + 0.5,\n          prob: getBinomialProb(k, n, p) \n      });\n    }\n\n    // 2. Generate Normal Data\n    const normalData = [];\n    const step = (endK - startK) / 100;\n    const safeStep = step &gt; 0.1 ? step : 0.1;\n    \n    for (let x = startK; x &lt;= endK; x += safeStep) {\n      normalData.push({ x: x, y: normalPDF(x, mu, sigma) });\n    }\n\n    // 3. Plot\n    const chart = Plot.plot({\n      width: 600,\n      height: 380,\n      marginTop: 30,\n      marginLeft: 40,\n      marginBottom: 30,\n      x: { \n        label: \"Số lần thành công (k)\",\n        // FIX: Hard-code domain to full range [0, n] to prevent jumping\n        domain: [0, n]\n      },\n      y: { \n        label: \"Xác suất\", \n        grid: true \n      },\n      marks: [\n        // Binomial\n        Plot.rectY(binomData, {\n          x1: \"x1\", \n          x2: \"x2\", \n          y: \"prob\", \n          fill: \"#3b82f6\", \n          fillOpacity: 0.5,\n          title: d =&gt; `k: ${d.k}\\nP: ${d.prob.toFixed(4)}`\n        }),\n        \n        // Normal Curve\n        Plot.line(normalData, {\n          x: \"x\", \n          y: \"y\", \n          stroke: \"#be185d\", \n          strokeWidth: 3\n        }),\n        \n        // Mean Line\n        Plot.ruleX([mu], {\n          stroke: \"#374151\", \n          strokeDasharray: \"4,4\", \n          strokeOpacity: 0.6\n        })\n      ]\n    });\n\n    plotContainer.innerHTML = \"\";\n    plotContainer.appendChild(chart);\n  }\n\n  nCtrl.input.addEventListener(\"input\", update);\n  pCtrl.input.addEventListener(\"input\", update);\n  \n  update();\n\n  return wrapper;\n})();\n\n\n\n\n\n\n\n\n\n4.2.2 Phân phối Siêu bội (Hypergeometric distribution)\nNếu phân phối Nhị thức là việc tung đồng xu, thì Phân phối Siêu bội giống như việc chia bài.\nTình huống: Bạn có bộ bài 52 lá, trong đó có 4 lá Át. Bạn rút 10 lá và hỏi “Tôi rút được bao nhiêu lá Át?”.\nLuật chơi:\n\nSố lần thử cố định (\\(n\\))\nCác lần thử phụ thuộc nhau\nLấy mẫu không hoàn lại từ một quần thể hữu hạn (\\(N\\))\n\nKhi bạn rút được một lá Át ra khỏi bộ bài và giữ nó lại, xác suất rút được lá Át tiếp theo sẽ thay đổi (vì trong bộ bài giờ đây thiếu mất 1 lá Át và tổng số lá cũng giảm đi 1). Đây là đặc trưng của việc lấy mẫu không hoàn lại.\nPhân phối Siêu bội mô tả xác suất lấy được đúng \\(k\\) phần tử thành công trong \\(n\\) lần lấy mẫu từ một quần thể hữu hạn gồm \\(N\\) phần tử, mà không có sự thay thế (không hoàn lại).\n\\[\\mathbb{P}(X=k) = \\frac{\\binom{K}{k} \\binom{N-K}{n-k}}{\\binom{N}{n}}\\]\n\n\\(N\\): Tổng kích thước quần thể (Ví dụ: 52 lá bài)\n\\(n\\): Kích thước mẫu lấy ra (Ví dụ: Rút 5 lá trên tay)\n\\(K\\): Tổng số phần tử thành công có trong quần thể (Ví dụ: 4 lá Át)\n\\(k\\): Số lượng thành công mong muốn trong mẫu (Ví dụ: Muốn có đúng 2 lá Át)\n\\(N-K\\): Số lượng phần tử thất bại trong quần thể (Ví dụ: 48 lá bài còn lại)\n\\(n-k\\): Số lượng thất bại phải lấy trong mẫu (Ví dụ: 3 lá còn lại trong tay phải là lá thường).\n\n\n\n\n\n\n\nNoteGiải thích\n\n\n\n\\[\\frac{ \\overbrace{\\binom{K}{k}}^{\\text{Chọn } k \\text{ thành công}} \\cdot \\overbrace{\\binom{N-K}{n-k}}^{\\text{Chọn } n-k \\text{ thất bại}} }{ \\underbrace{\\binom{N}{n}}_{\\text{Tổng số cách chọn ra } n \\text{ mẫu}} }\\]\n\n\n\nviewof ace_sim_manual = (() =&gt; {\n  // --- 1. SETUP DOM & STYLES ---\n  const container = document.createElement(\"div\");\n  container.style.cssText = `\n    width: 400px;\n    height: 440px; \n    margin: 0 auto;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    border: 1px solid transparent; /* Prevents margin collapse */\n  `;\n\n  // Inject UI HTML directly (Total Control)\n  container.innerHTML = `\n    &lt;style&gt;\n      .ace-controls-row {\n        width: 100%;\n        height: 40px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 5px;\n      }\n      .ace-btn {\n        padding: 6px 14px;\n        border-radius: 6px;\n        border: 1px solid #d1d5db;\n        background-color: white;\n        color: #374151;\n        font-size: 14px;\n        font-weight: 600;\n        cursor: pointer;\n        line-height: 1.2;\n      }\n      .ace-btn:hover { background-color: #f3f4f6; }\n      .ace-btn-primary {\n        background-color: #3b82f6; \n        color: white; \n        border-color: #2563eb;\n      }\n      .ace-btn-primary:hover { background-color: #2563eb; color: white; }\n      \n      .ace-toggle {\n        display: flex; align-items: center; gap: 6px;\n        font-size: 14px; font-weight: 500; color: #4b5563;\n        cursor: pointer; user-select: none;\n      }\n      .ace-toggle input { width: 16px; height: 16px; accent-color: #10b981; cursor: pointer; }\n      \n      canvas { display: block; } /* Removes ghost margin */\n    &lt;/style&gt;\n\n    &lt;div class=\"ace-controls-row\"&gt;\n      &lt;button id=\"btn-draw\" class=\"ace-btn ace-btn-primary\"&gt;Rút 10 lá&lt;/button&gt;\n      &lt;label class=\"ace-toggle\"&gt;\n        &lt;input type=\"checkbox\" id=\"chk-auto\"&gt;\n        Tự động chạy\n      &lt;/label&gt;\n      &lt;button id=\"btn-reset\" class=\"ace-btn\"&gt;Làm lại&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n\n  // --- 2. CANVAS SETUP ---\n  const width = 400;\n  const height = 380;\n  const canvas = document.createElement(\"canvas\");\n  const dpr = window.devicePixelRatio || 1;\n  \n  canvas.width = width * dpr;\n  canvas.height = height * dpr;\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  \n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n  ctx.scale(dpr, dpr);\n  container.appendChild(canvas);\n\n  // --- 3. STATE & CONSTANTS ---\n  const SUITS = [\"♠\", \"♥\", \"♣\", \"♦\"];\n  const RANKS = [\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"];\n  const CARD_W = 30, CARD_H = 45;\n  \n  // Layout Constants\n  const Y_HEADER = 45;\n  const Y_CARDS = 85;\n  const Y_CHART_BASE = 320;\n  const CHART_H = 60;\n  \n  // Colors\n  const BG_COLOR=\"#fff\", TEXT_COLOR=\"#333333\", ACE_COLOR=\"#d35400\", ACE_BG=\"#fffbe6\";\n  const CARD_BG=\"#ffffff\", CARD_BORDER=\"#cccccc\", RED=\"#e74c3c\", BLACK=\"#2c3e50\";\n  const CHART_THEO=\"rgba(44, 62, 80, 0.1)\", CHART_ACT=\"#009688\", CHART_ACTIVE=\"#00796b\";\n  const DECK_BACK=\"#c0392b\";\n\n  function hypergeom(k, N, K, n) {\n     function nCr(n, r) {\n        if (r &lt; 0 || r &gt; n) return 0;\n        let res = 1;\n        for(let i=0; i&lt;r; i++) res = res * (n - i) / (i + 1);\n        return res;\n     }\n     return (nCr(K, k) * nCr(N - K, n - k)) / nCr(N, n);\n  }\n  const THEORETICAL = [];\n  for(let k=0; k&lt;=4; k++) THEORETICAL[k] = hypergeom(k, 52, 4, 10);\n\n  const S = {\n     counts: [0, 0, 0, 0, 0], \n     totalDeals: 0,\n     lastHand: [],\n     animation: 0, \n     cooldown: 0,\n     isAuto: false\n  };\n\n  // --- 4. LOGIC ---\n  function runDeal() {\n    let deck = [];\n    for(let s of SUITS) {\n      for(let r of RANKS) deck.push({ rank: r, suit: s, isAce: r === \"A\" });\n    }\n    for(let i=deck.length-1; i&gt;0; i--) {\n       const j = Math.floor(Math.random() * (i+1));\n       [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n    \n    const hand = deck.slice(0, 10);\n    const aceCount = hand.filter(c =&gt; c.isAce).length;\n    S.counts[aceCount]++;\n    S.totalDeals++;\n    \n    // Animation targets\n    const startX = (width - (5 * (CARD_W + 8))) / 2 + 4;\n    S.lastHand = hand.map((c, i) =&gt; {\n       const row = Math.floor(i / 5);\n       const col = i % 5;\n       return {\n         ...c,\n         x: 30, y: 30,\n         targetX: startX + col * (CARD_W + 8),\n         targetY: Y_CARDS + row * (CARD_H + 12),\n         t: 0\n       };\n    });\n    S.animation = 1;\n    S.cooldown = 0; \n  }\n\n  function reset() {\n     S.counts = [0,0,0,0,0];\n     S.totalDeals = 0;\n     S.lastHand = [];\n     S.animation = 0;\n  }\n\n  // --- 5. LOOP ---\n  function update() {\n     if (S.isAuto && S.animation === 0) {\n        S.cooldown++;\n        if (S.cooldown &gt; 40) runDeal();\n     }\n\n     if (S.animation === 1) {\n       let done = true;\n       for (let c of S.lastHand) {\n          if (c.t &lt; 1) {\n             c.t += 0.1; \n             if (c.t &gt; 1) c.t = 1;\n             const ease = 1 - Math.pow(1 - c.t, 3);\n             c.x = 30 + (c.targetX - 30) * ease;\n             c.y = 30 + (c.targetY - 30) * ease;\n             done = false;\n          }\n       }\n       if (done) S.animation = 0;\n    }\n  }\n\n  function draw() {\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, width, height);\n    \n    ctx.save();\n    ctx.font = \"bold 14px -apple-system, BlinkMacSystemFont, sans-serif\";\n    ctx.fontVariantNumeric = \"tabular-nums\";\n\n    // Header\n    ctx.textAlign = \"left\"; ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(`Lần rút: ${S.totalDeals}`, 75, Y_HEADER); \n    \n    if (S.isAuto) {\n        ctx.textAlign = \"center\"; ctx.fillStyle = CHART_ACT;\n        ctx.fillText(\"● Đang chạy...\", width/2, Y_HEADER);\n    }\n\n    if (S.lastHand.length &gt; 0) {\n       const aces = S.lastHand.filter(c=&gt;c.isAce).length;\n       ctx.textAlign = \"right\"; ctx.fillStyle = ACE_COLOR;\n       ctx.fillText(`Kết quả: ${aces} lá Át`, width - 30, Y_HEADER); \n    }\n    ctx.restore();\n\n    // Deck\n    for(let i=0; i&lt;3; i++) {\n      ctx.fillStyle = \"white\"; ctx.strokeStyle = \"#ccc\";\n      ctx.fillRect(30-i*2, 30-i*2, CARD_W, CARD_H);\n      ctx.strokeRect(30-i*2, 30-i*2, CARD_W, CARD_H);\n    }\n    ctx.fillStyle = DECK_BACK; ctx.fillRect(30, 30, CARD_W, CARD_H);\n    ctx.strokeStyle = \"white\"; ctx.lineWidth = 2; ctx.strokeRect(34, 34, CARD_W-8, CARD_H-8);\n    ctx.lineWidth = 1;\n\n    // Hand\n    for (let c of S.lastHand) {\n        ctx.fillStyle = c.isAce ? ACE_BG : CARD_BG;\n        ctx.fillRect(c.x, c.y, CARD_W, CARD_H);\n        \n        ctx.strokeStyle = c.isAce ? ACE_COLOR : CARD_BORDER;\n        ctx.strokeRect(c.x, c.y, CARD_W, CARD_H);\n\n        const isRed = (c.suit === \"♥\" || c.suit === \"♦\");\n        ctx.fillStyle = c.isAce ? ACE_COLOR : (isRed ? RED : BLACK);\n        ctx.textAlign = \"left\"; ctx.textBaseline = \"top\";\n        ctx.font = \"bold 14px sans-serif\";\n        ctx.fillText(c.rank, c.x + 3, c.y + 4);\n        ctx.font = \"16px sans-serif\";\n        ctx.fillText(c.suit, c.x + 3, c.y + 20);\n    }\n\n    // Chart\n    const chartX = 50, barW = 40, gap = 25;\n    \n    ctx.beginPath(); ctx.strokeStyle = \"#bdc3c7\"; ctx.lineWidth = 1;\n    ctx.moveTo(chartX - 10, Y_CHART_BASE); ctx.lineTo(width - 20, Y_CHART_BASE); ctx.stroke();\n    \n    ctx.save();\n    ctx.fillStyle = TEXT_COLOR; ctx.font = \"12px sans-serif\"; ctx.textAlign = \"center\";\n    ctx.fillText(\"Số lá Át rút được (k)\", width/2 + 15, Y_CHART_BASE + 35);\n    \n    ctx.translate(20, Y_CHART_BASE - CHART_H/2);\n    ctx.rotate(-Math.PI/2);\n    ctx.fillStyle = \"#7f8c8d\";\n    ctx.fillText(\"Tần suất\", 0, 0);\n    ctx.restore();\n\n    const activeAces = S.lastHand.filter(c=&gt;c.isAce).length;\n\n    for (let k = 0; k &lt;= 4; k++) {\n       const x = chartX + k * (barW + gap);\n       const Y_SCALE = 0.5;\n       \n       const theoH = (THEORETICAL[k] / Y_SCALE) * CHART_H;\n       ctx.fillStyle = CHART_THEO;\n       ctx.fillRect(x, Y_CHART_BASE - theoH, barW, theoH);\n       \n       let count = S.counts[k];\n       let pct = S.totalDeals &gt; 0 ? count / S.totalDeals : 0;\n       let barH = (pct / Y_SCALE) * CHART_H;\n       if (barH &gt; CHART_H + 10) barH = CHART_H + 10;\n       \n       const isActive = (S.animation === 0 && S.totalDeals &gt; 0 && k === activeAces);\n       ctx.fillStyle = isActive ? CHART_ACTIVE : CHART_ACT;\n       ctx.fillRect(x, Y_CHART_BASE - barH, barW, barH);\n       \n       ctx.save();\n       ctx.fontVariantNumeric = \"tabular-nums\";\n       ctx.fillStyle = TEXT_COLOR; ctx.font = \"12px sans-serif\"; ctx.textAlign = \"center\";\n       ctx.fillText(k, x + barW/2, Y_CHART_BASE + 15);\n       ctx.restore();\n    }\n  }\n\n  // --- 6. BINDINGS ---\n  const btnDraw = container.querySelector(\"#btn-draw\");\n  const btnReset = container.querySelector(\"#btn-reset\");\n  const chkAuto = container.querySelector(\"#chk-auto\");\n\n  btnDraw.onclick = () =&gt; runDeal();\n  btnReset.onclick = () =&gt; reset();\n  chkAuto.onchange = (e) =&gt; { S.isAuto = e.target.checked; };\n\n  let frameId;\n  function tick() {\n    update();\n    draw();\n    frameId = requestAnimationFrame(tick);\n  }\n  tick();\n\n  // Clean up\n  if (this && this.invalidation) this.invalidation.then(() =&gt; cancelAnimationFrame(frameId));\n\n  return container;\n})();",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối rời rạc</span>"
    ]
  },
  {
    "objectID": "distr-d.html#đếm-số-lần-thử",
    "href": "distr-d.html#đếm-số-lần-thử",
    "title": "4  Phân phối rời rạc",
    "section": "4.3 Đếm số lần thử",
    "text": "4.3 Đếm số lần thử\nChúng ta quyết định trước phần thưởng mình muốn đạt được (\\(k\\) thành công), và đếm xem phải tốn bao nhiêu công sức (\\(n\\) lần thử) để đạt được nó. Nhánh này mô hình hóa sự “kiên trì” hoặc “sức chịu đựng”.\n\n4.3.1 Phân phối hình học (geometric distribution)\nTình huống: Một gia đình phong kiến trọng nam khinh nữ muốn có một đứa con trai, họ cứ sinh con cho đến khi có con trai thì thôi\nCâu hỏi: Họ phải sinh bao nhiêu con cho đến khi có con trai?\nĐặc tính: Không có bộ nhớ (Memoryless). Dù đã sinh 10 con gái liên tiếp, xác suất đứa tiếp theo là trai vẫn y như lúc bắt đầu.\n\n\n4.3.2 Phân phối Nhị thức âm (negative binomial distribution)\nTình huống: Gia đình phong kiến đã sinh được con trai nhưng vẫn muốn có con trai nữa, thầy bói nói nhà phải có 3 đứa con trai mới giàu được\nCâu hỏi: Họ sẽ sinh bao nhiêu con trước khi có được đứa con trai thứ 3?\nVề lý thuyết, đây là tổng của \\(k\\) biến thuộc phân phối hình học.\nTrong sinh học thực tế (ví dụ: đếm số ký sinh trùng, ấu trùng muỗi), phương sai thường lớn hơn trung bình rất nhiều (do hiện tượng tụ đám/clumping). Phân phối Nhị thức Âm khớp với kiểu dữ liệu này tốt hơn nhiều so với Poisson hay Nhị thức.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối rời rạc</span>"
    ]
  },
  {
    "objectID": "distr-d.html#đếm-sự-kiện-khi-biết-tốc-độ-trung-bình",
    "href": "distr-d.html#đếm-sự-kiện-khi-biết-tốc-độ-trung-bình",
    "title": "4  Phân phối rời rạc",
    "section": "4.4 Đếm sự kiện khi biết tốc độ trung bình",
    "text": "4.4 Đếm sự kiện khi biết tốc độ trung bình\n\n4.4.1 Phân phối Poisson\nKhác với những phân phối kể trên, phân phối Poisson không dựa trên chuỗi Bernoulli, mà dựa trên quá trình Poisson (Poisson process).\nQuá trình Poisson là 1 cơ chế xảy ra biến cố với các điều kiện:\n\nCác biến cố xảy ra độc lập nhau (independent): biến cố này xảy ra không ảnh hưởng đến xác suất xảy ra của biến cố tiếp theo\nCác biến cố xảy ra với 1 tốc độ trung bình không đổi: Số lượng sự kiện trung bình trên một đơn vị thời gian là hằng số (ví dụ: trung bình có 5 chiếc xe chạy trên con đường này mỗi giờ)\nCác biến cố không xảy ra cùng 1 lúc\n\nPhân phối Poisson dùng để đếm số lượng biến cố ngẫu nhiên xảy ra trong 1 khoảng thời gian cố định (với điều kiện \\(\\lambda\\) không thay đổi trong khoảng thời gian này) của quá trình Poisson.\n\\[P(X=k) = \\frac{e^{-\\lambda} \\lambda^k}{k!}\\]\nTrong đó:\n\n\\(\\lambda\\): Tốc độ trung bình (kỳ vọng) số sự kiện trong khoảng thời gian đó.\n\\(k\\): Số sự kiện muốn tính xác suất.\n\n\n\n4.4.2 Ví dụ\nTại một phòng cấp cứu, trung bình cứ 1 giờ lại có 3 bệnh nhân đến khám (\\(\\lambda = 3\\)). Xác suất để trong 1 giờ tới có chính xác 5 ca đến khám là bao nhiêu?\nÁp dụng công thức với \\(\\lambda = 3\\) và \\(k = 5\\):\n\\[P(X=5) = \\frac{e^{-3} \\cdot 3^5}{5!} = \\frac{0.0498 \\times 243}{120} \\approx 0.1008 \\quad (\\approx 10\\%)\\]\nPoisson là giới hạn của Nhị thức khi \\(n \\to \\infty\\) và xác suất thành công \\(p \\to 0\\), sao cho \\(np = \\lambda\\)\nHãy tưởng tượng bạn đang ngồi đợi tin nhắn điện thoại trong 1 giờ. Dựa vào kinh nghiệm, trung bình bạn nhận được \\(\\lambda = 5\\) tin nhắn/giờ. Xác suất trong 1 giờ tới bạn chỉ nhận được 2 tin nhắn là bao nhiêu?\n\nBạn chia 1 giờ thành 60 phút. Mỗi phút là một phép thử Bernoulli (có tin nhắn/không tin nhắn). Bạn có \\(n = 60\\) phép thử liên tiếp.\nBạn chia nhỏ thời gian ra nữa. Lúc này số phép thử \\(n\\) trở nên vô cùng lớn, và xác suất có tin nhắn trong một khoảnh khắc siêu nhỏ (\\(p\\)) trở nên vô cùng nhỏ. Càng chia nhỏ, bạn sẽ thấy phân phối nhị thức càng gần với Poisson.\n\n\nviewof poisson_visual_final = (() =&gt; {\n  // --- 1. CONFIGURATION ---\n  const lambda = 5; \n  \n  // Input Slider (Width 400px to match binning bar)\n  const form = Inputs.range([10, 360], {\n    value: 10, \n    step: 5, \n    label: \"Chia 1 giờ thành n khoảng (n)\"\n  });\n  \n  const wrapper = document.createElement(\"div\");\n  wrapper.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    margin-top: 20px;\n  `;\n  \n  // --- 2. TIME BIN VISUALIZATION (Canvas) ---\n  const timeCanvas = document.createElement(\"canvas\");\n  const timeW = 400; // REDUCED WIDTH\n  const timeH = 50;\n  const dpr = window.devicePixelRatio || 1;\n  \n  timeCanvas.width = timeW * dpr;\n  timeCanvas.height = timeH * dpr;\n  timeCanvas.style.width = `${timeW}px`;\n  timeCanvas.style.height = `${timeH}px`;\n  timeCanvas.style.marginTop = \"10px\"; \n  timeCanvas.style.marginBottom = \"5px\";\n  \n  const tCtx = timeCanvas.getContext(\"2d\");\n  tCtx.scale(dpr, dpr);\n\n  // --- 3. STATS DISPLAY ---\n  const statsDiv = document.createElement(\"div\");\n  statsDiv.style.cssText = `\n    margin-bottom: 5px; \n    font-size: 16px; \n    color: #333;\n    font-weight: 500;\n  `;\n  \n  // --- 4. APPEND ELEMENTS (Order: Input -&gt; Binning -&gt; Stats -&gt; Plot) ---\n  wrapper.appendChild(form);       \n  wrapper.appendChild(timeCanvas); \n  wrapper.appendChild(statsDiv);   \n  const plotContainer = document.createElement(\"div\");\n  wrapper.appendChild(plotContainer); \n\n  // --- 5. MATH HELPERS ---\n  function getBinomialData(n, p) {\n    const data = [];\n    let prob = Math.pow(1 - p, n); \n    for (let k = 0; k &lt;= 16; k++) {\n      data.push({k, type: \"Binomial\", prob});\n      if (k &lt; n) {\n        prob = prob * ((n - k) / (k + 1)) * (p / (1 - p));\n      } else {\n        prob = 0;\n      }\n    }\n    return data;\n  }\n\n  const poissonData = [];\n  {\n    let prob = Math.exp(-lambda); \n    for (let k = 0; k &lt;= 16; k++) {\n      poissonData.push({k, type: \"Poisson\", prob});\n      prob = prob * lambda / (k + 1);\n    }\n  }\n\n  // --- 6. RENDER LOOPS ---\n  function drawTimeBins(n) {\n    tCtx.clearRect(0, 0, timeW, timeH);\n    \n    const barX = 0; // Start at 0 since canvas is now exact width\n    const barY = 15;\n    const barW = timeW;\n    const barH = 20;\n    \n    // Background\n    tCtx.fillStyle = \"#f3f4f6\";\n    tCtx.fillRect(barX, barY, barW, barH);\n    tCtx.strokeStyle = \"#9ca3af\";\n    tCtx.lineWidth = 1;\n    tCtx.strokeRect(barX, barY, barW, barH);\n    \n    // Draw Dividers\n    tCtx.beginPath();\n    tCtx.strokeStyle = n &gt; 150 ? \"rgba(107, 114, 128, 0.5)\" : \"#6b7280\";\n    tCtx.lineWidth = n &gt; 200 ? 0.5 : 1; \n\n    const binSize = barW / n;\n    \n    // Draw internal lines\n    for (let i = 1; i &lt; n; i++) {\n        const x = Math.floor(barX + i * binSize) + 0.5;\n        tCtx.moveTo(x, barY);\n        tCtx.lineTo(x, barY + barH);\n    }\n    tCtx.stroke();\n    \n    // Labels\n    tCtx.fillStyle = \"#374151\";\n    tCtx.font = \"bold 12px sans-serif\";\n    \n    tCtx.textAlign = \"left\"; \n    tCtx.fillText(\"0\", barX, barY + barH + 14);\n    \n    tCtx.textAlign = \"right\"; \n    tCtx.fillText(\"1h\", barX + barW, barY + barH + 14);\n    \n    // Center Label (Changed Text)\n    tCtx.textAlign = \"center\"; \n    tCtx.fillStyle = \"#3b82f6\";\n    tCtx.fillText(`${n} phép thử liên tiếp`, timeW / 2, barY - 5);\n  }\n\n  function update() {\n    const n = form.value;\n    const p = lambda / n; \n    \n    // Update Stats\n    statsDiv.innerHTML = `n = ${n} &nbsp;|&nbsp; p = ${p.toFixed(4)} &nbsp;|&nbsp; np = ${(n*p).toFixed(1)}`;\n\n    // Update Top Canvas\n    drawTimeBins(n);\n\n    // Update Plot\n    const binomData = getBinomialData(n, p);\n    const combinedData = poissonData.concat(binomData);\n    const xDomain = Array.from({length: 17}, (_, i) =&gt; i);\n\n    const chart = Plot.plot({\n      width: 600,\n      height: 320,\n      marginTop: 20,\n      x: { \n        type: \"band\", \n        domain: xDomain, \n        label: \"Số tin nhắn (k)\",\n        padding: 0.1\n      },\n      y: { label: \"Xác suất\", domain: [0, 0.2] },\n      marks: [\n        // Binomial Bars\n        Plot.barY(combinedData.filter(d =&gt; d.type === \"Binomial\"), {\n          x: \"k\", \n          y: \"prob\", \n          fill: \"#3b82f6\", \n          fillOpacity: 0.6,\n          title: d =&gt; `Binomial: ${d.prob.toFixed(4)}`\n        }),\n        // Poisson Line\n        Plot.line(combinedData.filter(d =&gt; d.type === \"Poisson\"), {\n          x: \"k\", \n          y: \"prob\", \n          stroke: \"#be185d\", \n          strokeWidth: 3,\n          curve: \"monotone-x\"\n        }),\n        // Poisson Dots\n        Plot.dot(combinedData.filter(d =&gt; d.type === \"Poisson\"), {\n          x: \"k\", \n          y: \"prob\", \n          fill: \"#be185d\",\n          r: 4\n        }),\n        Plot.ruleY([0])\n      ]\n    });\n\n    plotContainer.innerHTML = \"\";\n    plotContainer.appendChild(chart);\n  }\n\n  form.addEventListener(\"input\", update);\n  update();\n\n  return wrapper;\n})();",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối rời rạc</span>"
    ]
  },
  {
    "objectID": "thanks.html",
    "href": "thanks.html",
    "title": "6  Lời cảm ơn",
    "section": "",
    "text": "Em Thịnh xin gửi lời cảm ơn chân thành đến:\n\nTS. Marc Choisy, GS. Louise Thwaites, GS. Ronald Geskus (mặc dù các thầy cô không hiểu tiếng Việt). Cảm ơn các thầy cô đã kiên nhẫn hướng dẫn, chia sẻ tài liệu và định hình sự nghiệp của em. Sự dẫn dắt này đã thực sự thay đổi cuộc đời em từ khi bắt đầu làm NCS\nTS. Lưu Phúc Lợi. Cảm ơn thầy đã dạy em những bước đầu tiên về thống kê và lập trình, giúp em hết sợ code và công thức toán, giới thiệu giáo trình “STATS 210: Statistical Theory” và luôn hỗ trợ em từ chuyện chuyên môn đến những vấn đề cá nhân",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Lời cảm ơn</span>"
    ]
  },
  {
    "objectID": "distr-d.html#ứng-dụng",
    "href": "distr-d.html#ứng-dụng",
    "title": "4  Phân phối rời rạc",
    "section": "4.5 Ứng dụng",
    "text": "4.5 Ứng dụng\nDữ liệu dạng đếm (ví dụ: số ca bệnh trong 1 tuần):\n\nPoisson\nNegative binomial\n\nDữ liệu là tỉ lệ:\nCác phân phối phức tạp có thể được tạo ra bằng cách cộng các phân phối đơn giản:\n\n\n\n\n\n\n\n\nNếu cộng\nSẽ có\nĐiều kiện\n\n\n\n\nNhiều Bernoulli\nNhị thức\nCùng \\(p\\).\n\n\nNhiều Nhị thức\nNhị thức\n\\(X+Y \\sim \\text{Bin}(n+m, p)\\)\n\n\nNhiều Hình học\nNhị thức âm\nChờ \\(k\\) thành công thực chất là chờ 1 thành công, lặp lại \\(k\\) lần\n\n\nNhiều Nhị thức âm\nNhị thức âm\n\\(X+Y \\sim \\text{NB}(r_1+r_2, p)\\)\n\n\nNhiều Poisson\nPoisson\n\\(X+Y \\sim \\text{Pois}(\\lambda_1 + \\lambda_2)\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Phân phối rời rạc</span>"
    ]
  }
]