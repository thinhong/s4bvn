---
title: "sampling"
format: html
---

```{ojs}
//| echo: false
viewof galton_buttons = Inputs.form({
  rows: Inputs.range([8, 20], {value: 12, step: 1, label: "Rows"}),
  speed: Inputs.range([0.5, 3], {value: 2, step: 0.1, label: "Speed"}),
  total: Inputs.range([50, 800], {value: 250, step: 10, label: "Total Beads"})
})


viewof control_actions = Inputs.form({
  start: Inputs.button("Start / Reset", {value: null, reduce: () => "START"}),
  stop: Inputs.button("Stop", {value: null, reduce: () => "STOP"})
})


{
  const rows = galton_buttons.rows;
  const speed = galton_buttons.speed;
  const maxBalls = galton_buttons.total;
  
  // Listen to the buttons
  const action = control_actions; 

  // 1. SETUP
  const width = 360;
  const height = 600;
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");

  // Geometry
  const pegSpacing = width / (rows + 2);
  const rowHeight = pegSpacing * 0.85; 
  const startY = 60;
  const pegRadius = pegSpacing * 0.12; 
  const ballRadius = pegSpacing * 0.23; 

  // Bin Dimensions
  const floorY = height - 10;
  const binWidth = pegSpacing;
  const totalBinWidth = (rows + 1) * binWidth;
  const binsStartX = (width - totalBinWidth) / 2;
  const wallsTopY = startY + (rows) * rowHeight + 10;

  // 2. PRE-COMPUTE BOARD
  const pegGrid = []; 
  for (let r = 0; r < rows; r++) {
    const rowPegs = [];
    const pegsInThisRow = r + 1;
    const rowWidth = (pegsInThisRow - 1) * pegSpacing;
    const rowStartX = (width - rowWidth) / 2;
    for (let p = 0; p < pegsInThisRow; p++) {
      rowPegs.push({
        x: rowStartX + p * pegSpacing,
        y: startY + r * rowHeight
      });
    }
    pegGrid.push(rowPegs);
  }

  // 3. STATE
  let balls = [];
  let bins = new Array(rows + 1).fill(0);
  let spawnedCount = 0;
  
  // Internal Running Flag (Starts False)
  let isRunning = false;

  // 4. CONTROL LOGIC
  // We hook into the 'action' dependency. 
  // Whenever the user clicks a button, this cell re-runs, but we want to persist state.
  // Actually, for animation loops in Observable, it's better to handle clicks via event listeners
  // or checks within the cell if we want to avoid full re-initialization.
  
  // However, since we want "Start/Reset" to clear everything, re-initialization is actually fine 
  // for the Start button, but bad for Stop (we don't want to lose beads).
  
  // BETTER APPROACH: Use a mutable object or event listeners attached to the DOM buttons above.
  // But since we are inside a generator/cell, let's use a closure pattern that persists.
  
  // We'll attach specific behavior to the inputs provided in the viewof above.
  const startBtn = viewof control_actions.querySelector("button"); 
  // The 'stop' button is the second one in the form
  const stopBtn = viewof control_actions.querySelectorAll("button")[1];

  startBtn.onclick = () => {
    // RESET AND START
    balls = [];
    bins = new Array(rows + 1).fill(0);
    spawnedCount = 0;
    isRunning = true;
  };

  stopBtn.onclick = () => {
    // STOP ONLY
    isRunning = false;
  };

  // 5. PATH LOGIC
  function createBall() {
    let currentInd = 0; 
    let path = [];
    path.push({ x: width / 2, y: startY - 20 });

    for (let r = 0; r < rows; r++) {
       const peg = pegGrid[r][currentInd];
       path.push({ x: peg.x, y: peg.y - pegRadius - ballRadius });
       if (Math.random() > 0.5) currentInd++; 
    }

    const binX = binsStartX + currentInd * binWidth + binWidth/2;
    path.push({ x: binX, y: wallsTopY });
    path.push({ x: binX, y: floorY - ballRadius, isFloor: true, binIndex: currentInd });

    return {
      path: path,
      segment: 0,      
      t: 0,            
      active: true,
      x: path[0].x,
      y: path[0].y
    };
  }

  function spawnBall() {
    if (!isRunning) return;
    if (spawnedCount >= maxBalls) return;
    
    // Safety Overflow Check
    const centerBinIdx = Math.floor(rows / 2);
    const maxCapacity = (floorY - wallsTopY) / (ballRadius * 0.6); 
    if (bins[centerBinIdx] >= maxCapacity) return;

    balls.push(createBall());
    spawnedCount++;
  }

  function update(dt) {
    // Even if stopped, we let existing balls finish falling (optional, but looks better)
    // If you want "Freeze" stop, uncomment this:
    // if (!isRunning && balls.length === 0) return; 

    // Spawning only happens if running
    const spawnRate = 0.15 / speed; 
    if (isRunning && Math.random() < dt / spawnRate) spawnBall();

    for (let b of balls) {
      if (!b.active) continue;
      
      // If stopped, should falling balls freeze? 
      // Usually "Stop" means stop spawning. 
      // If you want hard freeze: if (!isRunning) continue;
      // Let's assume "Stop Spawning" but let gravity finish (cleaner).
      // If you want HARD STOP, uncomment:
      if (!isRunning) continue; 

      const moveSpeed = 3.5 * speed * dt; 
      b.t += moveSpeed;

      if (b.t >= 1) {
        b.t = 0;
        b.segment++;
        if (b.segment >= b.path.length - 1) {
           b.active = false;
           const finalPt = b.path[b.path.length - 1];
           bins[finalPt.binIndex]++;
           continue;
        }
      }

      const p0 = b.path[b.segment];
      const p1 = b.path[b.segment + 1];
      
      b.x = p0.x + (p1.x - p0.x) * b.t;
      if (p1.isFloor) {
         b.y = p0.y + (p1.y - p0.y) * (b.t * b.t); 
      } else {
         b.y = p0.y + (p1.y - p0.y) * (b.t * b.t); 
      }
    }
    balls = balls.filter(b => b.active);
  }

  function draw() {
    ctx.fillStyle = "#E8E0C5";
    ctx.fillRect(0, 0, width, height);

    // Pegs
    ctx.fillStyle = "#666";
    for (let row of pegGrid) {
      for (let p of row) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, pegRadius, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Walls
    ctx.strokeStyle = "#998866";
    ctx.lineWidth = 1;
    for (let i = 0; i <= rows + 1; i++) {
      const x = binsStartX + i * binWidth;
      ctx.beginPath();
      ctx.moveTo(x, wallsTopY);
      ctx.lineTo(x, height);
      ctx.stroke();
    }

    // Balls
    ctx.fillStyle = "#0033CC";
    for (let b of balls) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2);
      ctx.fill();
    }

    // Stacked Balls
    for (let i = 0; i < bins.length; i++) {
      const count = bins[i];
      const cx = binsStartX + i * binWidth + binWidth/2;
      ctx.strokeStyle = "#4d79ff";
      ctx.lineWidth = 0.5;

      for (let j = 0; j < count; j++) {
        const cy = floorY - j * (ballRadius * 0.6); 
        if (cy < wallsTopY) break;
        ctx.beginPath();
        ctx.arc(cx, cy, ballRadius, 0, Math.PI*2);
        ctx.fillStyle = "#0033CC";
        ctx.fill();
        ctx.stroke();
      }
    }
    
    // Status Text
    ctx.fillStyle = "#444";
    ctx.font = "bold 12px sans-serif";
    let status = isRunning ? "Running..." : "Stopped";
    if (spawnedCount >= maxBalls) status = "Completed";
    
    ctx.fillText(`Status: ${status}`, 10, 20);
    ctx.fillText(`Beads: ${spawnedCount} / ${maxBalls}`, 10, 35);
  }

  let lastTime = performance.now();
  let frameId;
  function tick(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    update(dt); // Always update (to allow falling even if spawning stopped)
    draw();
    frameId = requestAnimationFrame(tick);
  }
  
  // Initial Draw
  draw();
  tick(lastTime);
  
  return Object.assign(canvas, {
    remove: () => cancelAnimationFrame(frameId)
  });
}
```

