---
title: "Bayesian"
format: html
---

## Xác suất có điều kiện

```{ojs}
//| echo: false
viewof condition_waffle = Inputs.radio(
  ["Tất cả sinh viên", "Sinh viên nữ"], 
  { label: "Xem", value: "Tất cả sinh viên" }
)

// 1. RAW DATA (The counts)
counts = [
  { group: "Lớp A", boys: 70, girls: 30 },
  { group: "Lớp B", boys: 30, girls: 40 },
  { group: "Lớp C", boys: 10, girls: 40 }
]

// 2. GRID GENERATION (The magic part)
// We create a dot for every student and assign it a specific x/y coordinate.
waffle_data = counts.flatMap((d, class_idx) => {
  const students = [];
  
  // We put Girls first so they fill the bottom rows (y=0, y=1...)
  for (let i = 0; i < d.girls; i++) students.push("Girl");
  for (let i = 0; i < d.boys; i++) students.push("Boy");
  
  // Now map each student to a grid position
  return students.map((gender, i) => ({
    group: d.group,
    gender: gender,
    // X Logic: Offset by Class (class_idx * 14) + Column (i % 10)
    // * 14 gives us 10 columns for the class + 4 empty columns gap
    x: (class_idx * 14) + (i % 10), 
    // Y Logic: Row is integer division of index
    y: Math.floor(i / 10)
  }));
})

// 3. LOGIC & ANNOTATIONS
is_cond_waffle = condition_waffle === "Sinh viên nữ"
// Helper to calculate probability dynamically
total_girls_w = counts.reduce((sum, d) => sum + d.girls, 0)
target_girls_w = counts.find(d => d.group === "Lớp C").girls
prob_w = is_cond_waffle 
  ? (target_girls_w / total_girls_w * 100).toFixed(1)
  : (100 / 300 * 100).toFixed(1)

// 4. STYLING FUNCTIONS
color_waffle = (d) => {
  if (is_cond_waffle) return d.gender === "Boy" ? "#e0e0e0" : "#ff006e";
  return d.gender === "Boy" ? "#4cc9f0" : "#f72585";
}

opacity_waffle = (d) => {
  if (is_cond_waffle && d.gender === "Boy") return 0.2;
  return 1;
}

Plot.plot({
  width: 700,
  height: 300,
  marginTop: 60,
  marginLeft: 20,
  marginRight: 20,
  marginBottom: 50,
  style: {
    fontSize: "16px",
    background: "white"
  },
  // Hide axes because the grid implies the count
  x: { axis: null },
  y: { axis: null },
  
  marks: [
    // THE DOTS (Using explicit x and y)
    Plot.dot(waffle_data, {
      x: "x",
      y: "y",
      r: 6, // Slightly larger dots
      fill: d => color_waffle(d),
      fillOpacity: d => opacity_waffle(d),
      stroke: "white",
      strokeWidth: 0.5,
      title: d => `${d.gender} (${d.group})`
    }),

    // LABELS FOR CLASSES (Below the grids)
    Plot.text(["Lớp A", "Lớp B", "Lớp C"], {
      x: (d, i) => (i * 14) + 4.5, // Center text: 0 offset + 4.5 (middle of 10)
      y: -1.5, // Below the bottom row (0)
      text: d => d,
      fontWeight: "bold",
      fontSize: 20,
      clip: false
    })
  ]
})
```

## Ví dụ

Bạn đang muốn tìm một đối tượng để hẹn hò nghiêm túc. Bạn có 2 ứng viên mập mờ tiềm năng: A và B. Bạn cần quyết định chọn ai trong 2 người để thực sự nghiêm túc.

Trước khi đi hẹn hò, bạn đã có sẵn một thiên kiến ban đầu. Có thể bạn hơi nghiêng về A vì cả hai có nhiều sở thích chung hơn, hoặc có thể bạn hoàn toàn trung lập.

- Hãy hình dung một hình vuông lớn đại diện cho 100% niềm tin của bạn
- Hình vuông này được chia làm 2 phần, bên trái dành cho A bên phải dành cho B
- Chiều rộng của mỗi ô là thiên kiến ban đầu, trong thống kê Bayesian gọi là Xác suất tiên nghiệm (Prior) của bạn đối với mỗi người

Bạn quyết định đi date với từng người để thu thập dữ liệu thực tế. Sau khi đi date, bạn chấm điểm buổi date đó.

- Phần được tô màu là điểm buổi date của từng người, trong thống kê Bayesian gọi là Hàm khả năng (Likelihood)

Sau khi đã đi date với từng người, bạn muốn tính xác suất mình nên chọn A $\mathbb{P}(A|Date)$

- Tư duy Bayes: Chúng ta so sánh **Diện tích tô màu** của A so với B. Đây là Xác suất hậu nghiệm (Posterior).

Biểu đồ này được tạo theo phương pháp trong video [
Bayes theorem, the geometry of changing beliefs](https://www.youtube.com/watch?v=HZGCoVF3YvM) của kênh 3Blue1Brown.

```{ojs}
//| echo: false

viewof prior = Inputs.range([0, 1], {
  label: "Prior A", 
  value: 0.5, 
  step: 0.05
})

viewof like_alex = Inputs.range([0, 1], {
  label: "Likelihood A", 
  value: 0.8, 
  step: 0.05
})

viewof like_ben = Inputs.range([0, 1], {
  label: "Likelihood B", 
  value: 0.15, 
  step: 0.05
})

// 2. THE CALCULATIONS
rect_data = [
  // --- COLUMN 1: ALEX (Left Side) ---
  {
    label: "Thích A",
    x1: 0, x2: prior, y1: 0, y2: like_alex,
    color: "#6ecae1" 
  },
  {
    label: "Không thích A",
    x1: 0, x2: prior, y1: like_alex, y2: 1,
    color: "#1a1a1a" 
  },
  // --- COLUMN 2: BEN (Right Side) ---
  {
    label: "Thích B",
    x1: prior, x2: 1, y1: 0, y2: like_ben,
    color: "#2f7e9b" 
  },
  {
    label: "Không thích B",
    x1: prior, x2: 1, y1: like_ben, y2: 1,
    color: "#0f0f0f" 
  }
]

Plot.plot({
  width: 550, height: 450,
  marginTop: 50,
  marginLeft: 60,
  marginRight: 60,
  marginBottom: 20,

  style: {
    background: "black",
    color: "white",
    fontSize: "16px" 
  },
  
  x: { axis: null, domain: [0, 1] },
  y: { axis: null, domain: [0, 1] },

  marks: [
    // --- PART 1: THE ANNOTATIONS ---
    // Fix: Use [1] as dummy data, and arrow functions `() =>` for text strings.

    // A. TOP ANNOTATION: Prior P(H)
    Plot.ruleY([1], { 
      y: 1.03,           
      x1: 0, x2: prior,  
      stroke: "#000", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: prior / 2,      
      y: 1.03, dy: -10,
      text: () => `P(A) = ${prior.toFixed(2)}`, // <--- Arrow function required
      fill: "#000", fontWeight: "bold", fontSize: 16,
      clip: false
    }),

    // B. LEFT ANNOTATION: P(E|H)
    Plot.ruleX([1], {
      x: -0.03,          
      y1: 0, y2: like_alex, 
      stroke: "#6ecae1", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: -0.03,          
      y: like_alex / 2, 
      dx: -15, // Push slightly left away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `P(Date|A) = ${like_alex.toFixed(2)}`, // Removed \n for cleaner vertical look
      fill: "#6ecae1", 
      textAnchor: "middle", // Centers text on the bar height
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // C. RIGHT ANNOTATION: P(E|¬H)
    Plot.ruleX([1], {
      x: 1.03,           
      y1: 0, y2: like_ben, 
      stroke: "#2f7e9b", strokeWidth: 2, clip: false
    }),
    Plot.text([1], {
      x: 1.03,           
      y: like_ben / 2, 
      dx: 15, // Push slightly right away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `P(Date|B) = ${like_ben.toFixed(2)}`, 
      fill: "#2f7e9b", 
      textAnchor: "middle", 
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // --- PART 2: THE MOSAIC ---
    Plot.rect(rect_data, {
      x1: "x1", x2: "x2", y1: "y1", y2: "y2", 
      fill: "color", stroke: "white", strokeWidth: 1,
      tip: {
        fill: "#222", stroke: "white",
        maxRadius: 100,
        title: "label",
        channels: {
          "Diện tích": d => ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)
        },
        format: {
          "Diện tích": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false
        }
      }
    }),
    
    // Labels inside boxes
    Plot.text(rect_data, {
      x: d => (d.x1 + d.x2) / 2, 
      y: d => (d.y1 + d.y2) / 2, 
      text: d => (d.y2 - d.y1) > 0.1 && (d.x2 - d.x1) > 0.1 ? d.label : "", 
      fill: "white", fontWeight: "bold", pointerEvents: "none" 
    })
  ]
})
```

```{ojs}
//| echo: false

area_alex = prior * like_alex
area_ben  = (1 - prior) * like_ben
total_area = area_alex + area_ben
posterior_alex = area_alex / total_area

html`
  <div style="display: flex; align-items: center; flex-wrap: wrap;">
    <div style="font-weight: bold; margin-right: 5px;">
      P(A | Date) = 
    </div>

    <div style="display: flex; flex-direction: column; align-items: center; margin: 0 5px;">
      
      <div style="border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;">
        <span style="color: #6ecae1;">${area_alex.toFixed(3)}</span>
      </div>
      
      <div style="padding-top: 5px; text-align: center;">
        <span style="color: #6ecae1;">${area_alex.toFixed(3)}</span> + 
        <span style="color: #2f7e9b;">${area_ben.toFixed(3)}</span>
      </div>
      
    </div>

    <div style="font-weight: bold; color: #6ecae1; margin-left: 5px;">
      = ${(posterior_alex * 100).toFixed(1)}%
    </div>
  </div>
`
```

## Ứng dụng

Giả sử một bệnh nhân nhận kết quả xét nghiệm dương tính với một căn bệnh. Các thông số của xét nghiệm như sau:

- Độ nhạy (Sensitivity): 95%
- Độ đặc hiệu (Specificity): 90%
- Tỷ lệ hiện mắc: Căn bệnh này chiếm 10% dân số

Xác suất thực sự người đó bị bệnh khi cầm kết quả dương tính $\mathbb{P}(B|D)$ là bao nhiêu?

Cách khác để đặt câu hỏi này là: Trong số những người cầm tờ giấy xét nghiệm Dương tính, có bao nhiêu phần trăm là Dương tính thật? Để trả lời, ta cần tìm Tổng diện tích Dương tính, rồi lấy Diện tích Dương tính thật chia cho tổng số đó.

Chúng ta sẽ áp dụng phương pháp "Hình vuông niềm tin" để giải quyết:

- Hãy hình dung một hình vuông lớn đại diện cho 100% dân số
- Hình vuông này được chia làm 2 phần, bên trái là tỉ lệ người bệnh trong dân số, bên phải là tỉ lệ người không bệnh
- Trong cột người bệnh, độ nhạy là 95%, tô màu 95% chiều cao của cột này, đây là phần dương tính thật, diện tích là $0.10 \times 0.95 = 0.095$
- Trong cột người bệnh, độ đặc hiệu là 90%, tô màu 10% chiều cao của cột này, đây là phần dương tính giả, diện tích là $0.90 \times 0.10 = 0.09$

Bây giờ, hãy nhìn vào toàn bộ phần được tô màu trên hình vuông.

- Tổng diện tích màu (tổng dương tính) là $0.095 \text{ (Thật)} + 0.09 \text{ (Giả)} = 0.185$
- Phần bị chiếm bởi dương tính thật chính là xác suất thực sự mắc bệnh khi có kết quả dương tính

```{ojs}
//| echo: false

viewof prev = Inputs.range([0, 1], {
  label: "Tỉ lệ bệnh", 
  value: 0.1, 
  step: 0.01
})

viewof sens = Inputs.range([0, 1], {
  label: "Độ nhạy", 
  value: 0.95, 
  step: 0.01
})

viewof spec = Inputs.range([0, 1], {
  label: "Độ đặc hiệu", 
  value: 0.9, 
  step: 0.01
})

// 2. THE CALCULATIONS (Reactive Data)
// This array automatically updates whenever the sliders above move.
// We define the 4 quadrants of the mosaic.

rect_data2 = [
  // --- COLUMN 1: ALEX (Left Side) ---
  // The Width is determined by the 'prior'
  
  // 1. The "Evidence" Box (The bottom colored part)
  {
    label: "Dương thật",
    x1: 0, 
    x2: prev, 
    y1: 0, 
    y2: sens, 
    color: "#6ecae1" // Light Blue (Strong Evidence)
  },
  
  // 2. The "Void" Box (The top dark part)
  {
    label: "Âm giả",
    x1: 0, 
    x2: prev, 
    y1: sens, 
    y2: 1, 
    color: "#1a1a1a" // Dark Grey
  },

  // --- COLUMN 2: BEN (Right Side) ---
  // The Width starts where Alex ends ('prior') and goes to 1
  
  // 3. The "Evidence" Box (The bottom colored part)
  {
    label: "Dương giả",
    x1: prev, 
    x2: 1, 
    y1: 0, 
    y2: 1 - spec, 
    color: "#2f7e9b" // Teal (Competing Evidence)
  },
  
  // 4. The "Void" Box (The top dark part)
  {
    label: "Âm thật",
    x1: prev, 
    x2: 1, 
    y1: 1 - spec, 
    y2: 1, 
    color: "#0f0f0f" // Black
  }
]

Plot.plot({
  width: 550, height: 450,
  marginTop: 50,
  marginLeft: 60,
  marginRight: 60,
  marginBottom: 20,

  style: {
    background: "black",
    color: "white",
    fontSize: "16px" 
  },
  
  x: { axis: null, domain: [0, 1] },
  y: { axis: null, domain: [0, 1] },

  marks: [
    // --- PART 1: THE ANNOTATIONS ---
    // Fix: Use [1] as dummy data, and arrow functions `() =>` for text strings.

    // A. TOP ANNOTATION: Prior P(H)
    Plot.ruleY([1], { 
      y: 1.03,           
      x1: 0, x2: prev,  
      stroke: "#000", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: prev / 2,      
      y: 1.03, dy: -10,
      text: () => `Tỉ lệ bệnh = ${prev.toFixed(2)}`, // <--- Arrow function required
      fill: "#000", fontWeight: "bold", fontSize: 16,
      clip: false
    }),

    // B. LEFT ANNOTATION: P(E|H)
    Plot.ruleX([1], {
      x: -0.03,          
      y1: 0, y2: sens, 
      stroke: "#6ecae1", strokeWidth: 2,
      clip: false
    }),
    Plot.text([1], {
      x: -0.03,          
      y: sens / 2, 
      dx: -15, // Push slightly left away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `Độ nhạy = ${sens.toFixed(2)}`, // Removed \n for cleaner vertical look
      fill: "#6ecae1", 
      textAnchor: "middle", // Centers text on the bar height
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // C. RIGHT ANNOTATION: P(E|¬H)
    Plot.ruleX([1], {
      x: 1.03,           
      y1: 1 - spec, y2: 1, 
      stroke: "#000", strokeWidth: 2, clip: false
    }),
    Plot.text([1], {
      x: 1.03,           
      y: 1 - spec / 2, 
      dx: 15, // Push slightly right away from the line
      rotate: -90, // <--- Rotates text vertically
      text: () => `Độ đặc hiệu = ${spec.toFixed(2)}`, 
      fill: "#000", 
      textAnchor: "middle", 
      fontWeight: "bold", fontSize: 16, clip: false
    }),

    // --- PART 2: THE MOSAIC ---
    Plot.rect(rect_data2, {
      x1: "x1", x2: "x2", y1: "y1", y2: "y2", 
      fill: "color", stroke: "white", strokeWidth: 1,
      tip: {
        fill: "#222", stroke: "white",
        maxRadius: 100,
        title: "label",
        channels: {
          "Diện tích": d => ((d.x2 - d.x1) * (d.y2 - d.y1)).toFixed(3)
        },
        format: {
          "Diện tích": true, x: false, y: false, fill: false, stroke: false, x1: false, y1: false, x2: false, y2: false
        }
      }
    }),
    
    // Labels inside boxes
    Plot.text(rect_data2, {
      x: d => (d.x1 + d.x2) / 2, 
      y: d => (d.y1 + d.y2) / 2, 
      text: d => (d.y2 - d.y1) > 0.1 && (d.x2 - d.x1) > 0.1 ? d.label : "", 
      fill: "white", fontWeight: "bold", pointerEvents: "none" 
    })
  ]
})
```

```{ojs}
//| echo: false

area_tpr = prev * sens
area_fpr  = (1 - prev) * (1 - spec)
total_area_risk = area_tpr + area_fpr
posterior_risk = area_tpr / total_area_risk

html`
  <div style="display: flex; align-items: center; flex-wrap: wrap;">
    <div style="font-weight: bold; margin-right: 5px;">
      P(B | D) = 
    </div>

    <div style="display: flex; flex-direction: column; align-items: center; margin: 0 5px;">
      
      <div style="border-bottom: 2px solid; padding-bottom: 5px; text-align: center; width: 100%;">
        <span style="color: #6ecae1;">${area_tpr.toFixed(3)}</span>
      </div>
      
      <div style="padding-top: 5px; text-align: center;">
        <span style="color: #6ecae1;">${area_tpr.toFixed(3)}</span> + 
        <span style="color: #2f7e9b;">${area_fpr.toFixed(3)}</span>
      </div>
      
    </div>

    <div style="font-weight: bold; color: #6ecae1; margin-left: 5px;">
      = ${(posterior_risk * 100).toFixed(1)}%
    </div>
  </div>
`
```