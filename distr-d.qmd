---
title: "Phân phối rời rạc"
format: html
---

## Phép thử Bernoulli (Bernoulli trial, hay binomial trial)

Là một lần thử nghiệm duy nhất, không gian mẫu chỉ có đúng 2 kết quả: Thành công (Success) hoặc Thất bại (Failure)

Ví dụ: tung đồng xu (mặt sấp, mặt ngửa), xét nghiệm một ca nghi ngờ (dương tính, âm tính)

Khi ta thực hiện phép thử Bernoulli nhiều lần liên tiếp (ví dụ: tung một đồng xu nhiều lần, dùng một loại xét nghiệm để test nhiều người), ta đang thực hiện 1 chuỗi Bernoulli (Bernoulli process). Chuỗi Bernoulli chuẩn cần thỏa 2 điều kiện:

-   Độc lập (Independent): Kết quả của lần thử này không ảnh hưởng đến lần thử khác.
-   Xác suất không đổi: Xác suất thành công ($p$) phải giống hệt nhau ở mọi lần thử.

Hầu hết các phân phối rời rạc đều xuất phát từ chuỗi Bernoulli với các mục tiêu khác nhau.

## Đếm số lần thành công

Chúng ta quyết định trước sẽ bỏ ra bao nhiêu công sức ($n$ lần thử), và đếm xem thu được bao nhiêu phần thưởng ($k$ thành công).

### Phân phối nhị nhức (binomial distribution)

Đếm số lần thành công ($k$) trong một số lượng cố định các phép thử Bernoulli độc lập ($n$).

Xác suất để đạt được đúng $k$ lần thành công là:

$$P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}$$

Với:

- $n$: Tổng số lần thực hiện phép thử
- $p$: Xác suất thành công của mỗi lần thử (không đổi)

#### Ví dụ

Tung 1 đồng xu 10 lần, sau 10 lần tung, khả năng đếm được 1, 2, 3... mặt ngửa là bao nhiêu?

- Tổng số lần thực hiện phép thử: $n = 10$
- Xác suất ra mặt ngửa mỗi lần: $p = 0.5$

```{ojs}
//| echo: false

viewof n_coins = Inputs.range([1, 20], {label: "Coins per Flip (n)", value: 10, step: 1})
viewof p_head = Inputs.range([0.01, 0.99], {label: "Prob. of Heads (p)", value: 0.5, step: 0.01})
viewof speed = Inputs.range([10, 1000], {label: "Speed (ms)", value: 200, transform: x => 1010 - x})

viewof flipBtn = Inputs.button("Flip Once")
viewof autoBtn = Inputs.button("Start/Stop Auto-Flip")
viewof resetCoinBtn = Inputs.button("Reset Data")

// A. STATE CONTAINER
// Holds the data history.
coin_state = {
  // We define it once. It persists until you reload the page.
  return {
    history: [], 
    currentToss: [],
    totalHeads: 0,
    count: 0,
    lastReset: 0
  };
}

// B. GAME LOGIC
// This cell runs whenever you click a button.
coin_logic = {
  // 1. LISTEN TO TRIGGERS
  flipBtn;
  autoBtn;
  resetCoinBtn;
  
  // 2. HANDLE RESET
  // We check if the reset button counter has increased
  if (resetCoinBtn > coin_state.lastReset) {
      coin_state.history = [];
      coin_state.currentToss = [];
      coin_state.totalHeads = 0;
      coin_state.count = 0;
      coin_state.lastReset = resetCoinBtn;
      // Return immediately to clear the plot
      return coin_state.count; 
  }

  // 3. DEFINE THE FLIP FUNCTION
  const doFlip = () => {
    let heads = 0;
    const outcome = [];
    for(let i=0; i<n_coins; i++) {
      const isHead = Math.random() < p_head;
      outcome.push(isHead ? 1 : 0);
      if(isHead) heads++;
    }
    coin_state.currentToss = outcome;
    coin_state.history.push(heads);
    coin_state.totalHeads = heads;
    coin_state.count++;
  };

  // 4. EXECUTION MODE
  // If Auto Button is ODD (1, 3, 5...), we are in Auto Mode
  const isAuto = (autoBtn % 2) !== 0;

  if (isAuto) {
    // --- AUTO MODE (Loop) ---
    while (true) {
      doFlip();
      yield coin_state.count; // Yield updates the plot!
      await new Promise(r => setTimeout(r, 1010 - speed));
    }
  } else {
    // --- MANUAL MODE (Single Shot) ---
    // If we aren't in auto, and this cell ran, it means 'flipBtn' was clicked
    // (or a slider changed). We flip once.
    if (coin_state.count > 0 || flipBtn > 0) {
       doFlip();
    }
    return coin_state.count;
  }
}

// 3. THE VISUALIZATION (Fixed: Split into two plots)
{
  // DEPENDENCY: Listen to the logic!
  coin_logic; 
  
  // Plot A: The Coins (Top Strip)
  const coinPlot = Plot.plot({
    width: 600,
    height: 80, // Fixed height for just the coins
    title: `Toss #${coin_state.count}: Result`,
    x: {axis: null, domain: [0, n_coins]},
    y: {axis: null},
    marks: [
      Plot.dot(coin_state.currentToss.map((d, i) => ({x: i, val: d})), {
        x: (d, i) => mapRange(i, 0, n_coins-1, 0.5, n_coins-0.5), 
        y: 0, 
        r: 12,
        fill: d => d.val === 1 ? "#f7941d" : "#ccc", 
        stroke: "black",
        strokeWidth: 2
      }),
      Plot.text(coin_state.currentToss.map((d, i) => ({x: i, val: d})), {
        x: (d, i) => mapRange(i, 0, n_coins-1, 0.5, n_coins-0.5), 
        y: 0, 
        text: d => d.val === 1 ? "H" : "T",
        fill: "black", fontWeight: "bold", dy: 1
      })
    ]
  });

  // Plot B: The Histogram (Bottom Chart)
  const histPlot = Plot.plot({
    width: 600,
    height: 350,
    title: `Distribution of Heads (Total: ${coin_state.history.length} experiments)`,
    x: {label: "Number of Heads", domain: [0, n_coins]},
    y: {label: "Frequency", grid: true}, // Standard quantitative axis (Bottom-Up)
    marks: [
      // 1. The Blue Histogram
      Plot.rectY(coin_state.history, Plot.binX(
        {y: "count"}, 
        {x: d => d, domain: [0, n_coins], thresholds: d3.range(0, n_coins + 2), fill: "#4e79a7", opacity: 0.6}
      )),
      
      // 2. The Theoretical Red Line
      Plot.line(d3.range(0, n_coins + 1), {
        x: d => d + 0.5, 
        y: d => binomialPMF(d, n_coins, p_head) * coin_state.history.length,
        stroke: "red", strokeWidth: 2, curve: "natural"
      }),
      
      Plot.ruleY([0])
    ]
  });

  // Return both stacked together
  return htl.html`<div>${coinPlot}${histPlot}</div>`;
}

// Helper Functions
function mapRange(value, low1, high1, low2, high2) {
    if (high1 === low1) return low2;
    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
}

function factorial(n) {
  if (n === 0 || n === 1) return 1;
  let result = 1; 
  for (let i = 2; i <= n; i++) result *= i; 
  return result; 
}

function combination(n, k) {
  return factorial(n) / (factorial(k) * factorial(n - k));
}

function binomialPMF(k, n, p) {
  return combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
}
```

#### Bảng Galton

Bảng Galton là một tấm bảng dựng đứng, được đóng các hàng đinh so le nhau theo hình tam giác. Ta thả những viên bi nhỏ từ đỉnh tháp. Khi một viên bi chạm vào một chiếc đinh, nó sẽ nảy sang trái hoặc sang phải. Sau khi đi hết các hàng đinh, viên bi sẽ rơi vào các ô chứa để hứng bi. Số lượng bi trong các ô chứa này tuân theo phân phối nhị thức.

```{ojs}
//| echo: false
viewof galton_sharp = Inputs.form({
  rows: Inputs.range([8, 20], {value: 10, step: 1, label: "Số hàng đinh"}),
  speed: Inputs.range([0.5, 3], {value: 2, step: 0.1, label: "Tốc độ"}),
  total: Inputs.range([50, 800], {value: 200, step: 10, label: "Số viên bi"})
})

viewof control_sharp = Inputs.form({
  start: Inputs.button("Bắt đầu", {value: null, reduce: () => "START"}),
  stop: Inputs.button("Dừng", {value: null, reduce: () => "STOP"})
})

{
  const rows = galton_sharp.rows;
  const speed = galton_sharp.speed;
  const maxBalls = galton_sharp.total;
  
  // 1. DIMENSIONS
  // The "Logical" size (how big it looks on screen)
  const logicalWidth = 360;
  const logicalHeight = 600;

  // 2. HIGH-DPI SCALING
  // We detect the user's screen density (e.g., 2.0 for Retina)
  const dpr = window.devicePixelRatio || 1;
  
  const canvas = document.createElement("canvas");
  // Set the "Real" size (pixels in memory) higher
  canvas.width = logicalWidth * dpr;
  canvas.height = logicalHeight * dpr;
  // Set the "CSS" size (pixels on screen) standard
  canvas.style.width = `${logicalWidth}px`;
  canvas.style.height = `${logicalHeight}px`;
  
  const ctx = canvas.getContext("2d");
  // Scale all drawing operations automatically
  ctx.scale(dpr, dpr);

  // --- GEOMETRY (Uses logical units) ---
  const pegSpacing = logicalWidth / (rows + 2);
  const rowHeight = pegSpacing * 0.85; 
  const startY = 60;
  const pegRadius = pegSpacing * 0.12; 
  const ballRadius = pegSpacing * 0.23; 

  const floorY = logicalHeight - 10;
  const binWidth = pegSpacing;
  const totalBinWidth = (rows + 1) * binWidth;
  const binsStartX = (logicalWidth - totalBinWidth) / 2;
  const wallsTopY = startY + (rows) * rowHeight + 10;

  // PRE-COMPUTE BOARD
  const pegGrid = []; 
  for (let r = 0; r < rows; r++) {
    const rowPegs = [];
    const pegsInThisRow = r + 1;
    const rowWidth = (pegsInThisRow - 1) * pegSpacing;
    const rowStartX = (logicalWidth - rowWidth) / 2;
    for (let p = 0; p < pegsInThisRow; p++) {
      rowPegs.push({
        x: rowStartX + p * pegSpacing,
        y: startY + r * rowHeight
      });
    }
    pegGrid.push(rowPegs);
  }

  // STATE
  let balls = [];
  let bins = new Array(rows + 1).fill(0);
  let spawnedCount = 0;
  let isRunning = false;

  // CONTROLS
  const startBtn = viewof control_sharp.querySelector("button"); 
  const stopBtn = viewof control_sharp.querySelectorAll("button")[1];

  startBtn.onclick = () => {
    balls = [];
    bins = new Array(rows + 1).fill(0);
    spawnedCount = 0;
    isRunning = true;
  };
  stopBtn.onclick = () => { isRunning = false; };

  // PATH LOGIC
  function createBall() {
    let currentInd = 0; 
    let path = [];
    path.push({ x: logicalWidth / 2, y: startY - 20 });

    for (let r = 0; r < rows; r++) {
       const peg = pegGrid[r][currentInd];
       path.push({ x: peg.x, y: peg.y - pegRadius - ballRadius });
       if (Math.random() > 0.5) currentInd++; 
    }

    const binX = binsStartX + currentInd * binWidth + binWidth/2;
    path.push({ x: binX, y: wallsTopY });
    path.push({ x: binX, y: floorY - ballRadius, isFloor: true, binIndex: currentInd });

    return {
      path: path,
      segment: 0, t: 0, active: true,
      x: path[0].x, y: path[0].y
    };
  }

  function spawnBall() {
    if (!isRunning) return;
    if (spawnedCount >= maxBalls) return;
    
    const centerBinIdx = Math.floor(rows / 2);
    const maxCapacity = (floorY - wallsTopY) / (ballRadius * 0.6); 
    if (bins[centerBinIdx] >= maxCapacity) return;

    balls.push(createBall());
    spawnedCount++;
  }

  function update(dt) {
    const spawnRate = 0.15 / speed; 
    if (isRunning && Math.random() < dt / spawnRate) spawnBall();

    for (let b of balls) {
      if (!b.active) continue;
      if (!isRunning) continue; 

      const moveSpeed = 3.5 * speed * dt; 
      b.t += moveSpeed;

      if (b.t >= 1) {
        b.t = 0;
        b.segment++;
        if (b.segment >= b.path.length - 1) {
           b.active = false;
           const finalPt = b.path[b.path.length - 1];
           bins[finalPt.binIndex]++;
           continue;
        }
      }

      const p0 = b.path[b.segment];
      const p1 = b.path[b.segment + 1];
      
      b.x = p0.x + (p1.x - p0.x) * b.t;
      if (p1.isFloor) {
         b.y = p0.y + (p1.y - p0.y) * (b.t * b.t); 
      } else {
         b.y = p0.y + (p1.y - p0.y) * (b.t * b.t); 
      }
    }
    balls = balls.filter(b => b.active);
  }

  function draw() {
    // Clear the full logical area
    ctx.fillStyle = "#E8E0C5";
    ctx.fillRect(0, 0, logicalWidth, logicalHeight);

    // Pegs
    ctx.fillStyle = "#666";
    for (let row of pegGrid) {
      for (let p of row) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, pegRadius, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Walls
    ctx.strokeStyle = "#998866";
    ctx.lineWidth = 1;
    for (let i = 0; i <= rows + 1; i++) {
      const x = binsStartX + i * binWidth;
      ctx.beginPath();
      ctx.moveTo(x, wallsTopY);
      ctx.lineTo(x, logicalHeight);
      ctx.stroke();
    }

    // Active Balls
    ctx.fillStyle = "#0033CC";
    for (let b of balls) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, ballRadius, 0, Math.PI*2);
      ctx.fill();
    }

    // Stacked Balls
    for (let i = 0; i < bins.length; i++) {
      const count = bins[i];
      const cx = binsStartX + i * binWidth + binWidth/2;
      ctx.strokeStyle = "#4d79ff";
      ctx.lineWidth = 0.5;

      for (let j = 0; j < count; j++) {
        const cy = floorY - j * (ballRadius * 0.6); 
        if (cy < wallsTopY) break;
        ctx.beginPath();
        ctx.arc(cx, cy, ballRadius, 0, Math.PI*2);
        ctx.fillStyle = "#0033CC";
        ctx.fill();
        ctx.stroke();
      }
    }
    
    // Status Text
    ctx.fillStyle = "#444";
    ctx.font = "bold 14px sans-serif"; // Slightly bigger font
    let status = isRunning ? "Đang chạy..." : "Dừng";
    if (spawnedCount >= maxBalls) status = "Kết thúc";
    
    ctx.fillText(`Trạng thái: ${status}`, 10, 25);
    ctx.fillText(`Số viên bi: ${spawnedCount} / ${maxBalls}`, 10, 45);
  }

  let lastTime = performance.now();
  let frameId;
  function tick(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    update(dt);
    draw();
    frameId = requestAnimationFrame(tick);
  }
  
  draw();
  tick(lastTime);
  
  return Object.assign(canvas, {
    remove: () => cancelAnimationFrame(frameId)
  });
}
```

**Tại sao lại là phân phối nhị thức?**

- Mỗi lần viên bi chạm vào chiếc đinh, có hai trường hợp xảy ra: viên bi sẽ nảy sang trái hoặc sang phải, xác suất nảy sang mỗi bên là $p = 0.5$, giống như tung đồng xu. Đây là một phép thử Bernoulli.
- Nếu bảng có 10 hàng đinh, viên bi sẽ thực hiện 10 lần tung đồng xu liên tiếp.
- Các ô chứa tương ứng với số lần viên bi nảy về bên phải. Để vào ô giữa, viên bi phải nảy sang bên phải 5 lần, để vào ô cuối cùng, viên bi phải nảy sang bên phải 10 lần.

### Phân phối siêu bội (hypergeometric distribution)

Tình huống: Bạn có bộ bài 52 lá, trong đó có 4 lá hậu. Bạn rút 5 lá.

Luật chơi:

-   Số lần thử cố định ($n$)
-   Các lần thử phụ thuộc nhau
-   Lấy mẫu không hoàn lại từ một quần thể hữu hạn ($N$)

Câu hỏi: "Tôi rút được bao nhiêu lá hậu?"

## Đếm số lần thử

Chúng ta quyết định trước phần thưởng mình muốn đạt được ($k$ thành công), và đếm xem phải tốn bao nhiêu công sức ($n$ lần thử) để đạt được nó. Nhánh này mô hình hóa sự "kiên trì" hoặc "sức chịu đựng".

### Phân phối hình học (geometric distribution)

Tình huống: Một gia đình phong kiến trọng nam khinh nữ muốn có một đứa con trai, họ cứ sinh con cho đến khi có con trai thì thôi

Câu hỏi: Họ phải sinh bao nhiêu con cho đến khi có con trai?

Đặc tính: Không có bộ nhớ (Memoryless). Dù đã sinh 10 con gái liên tiếp, xác suất đứa tiếp theo là trai vẫn y như lúc bắt đầu.

### Phân phối nhị thức âm (negative binomial distribution)

Tình huống: Gia đình phong kiến đã sinh được con trai nhưng vẫn muốn có con trai nữa, thầy bói nói nhà phải có 3 đứa con trai mới giàu được

Câu hỏi: Họ sẽ sinh bao nhiêu con trước khi có được đứa con trai thứ 3?

Về lý thuyết, đây là tổng của $k$ biến thuộc phân phối hình học.

Trong sinh học thực tế (ví dụ: đếm số ký sinh trùng, ấu trùng muỗi), phương sai thường lớn hơn trung bình rất nhiều (do hiện tượng tụ đám/clumping). Phân phối Nhị thức Âm khớp với kiểu dữ liệu này tốt hơn nhiều so với Poisson hay Nhị thức.

## Đếm sự kiện khi biết tốc độ trung bình

### Phân phối Poisson

Poisson là giới hạn của nhị thức khi $n \to \infty$ và $p \to 0$, sao cho $np = \lambda$

Các phân phối phức tạp có thể được tạo ra bằng cách cộng các phân phối đơn giản:

| Nếu cộng | Sẽ có | Điều kiện |
|------------------------|------------------------|------------------------|
| Nhiều Bernoulli | Nhị thức | Cùng $p$. |
| Nhiều Nhị thức | Nhị thức | $X+Y \sim \text{Bin}(n+m, p)$ |
| Nhiều Hình học | Nhị thức âm | Chờ $k$ thành công thực chất là chờ 1 thành công, lặp lại $k$ lần |
| Nhiều Nhị thức âm | Nhị thức âm | $X+Y \sim \text{NB}(r_1+r_2, p)$ |
| Nhiều Poisson | Poisson | $X+Y \sim \text{Pois}(\lambda_1 + \lambda_2)$ |
